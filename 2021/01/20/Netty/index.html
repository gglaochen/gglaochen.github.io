<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Netty | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、NettyNetty 与 JDK 原生 NIO 相比，提供了非常简单易用的 API。 1. 主要优点 API 使用简单 - 开发门槛低 功能强大 - 预制了多种编码功能，支持多种主流协议 定制能力强 - 可以通过 ChannelHandler 对通信框架进行灵活扩展 性能高 - 与其他业界主流的 NIO 框架对比，Netty 的综合性能最优 成熟、稳定 - Netty 修复了已经发现的所有 J">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty">
<meta property="og:url" content="http://example.com/2021/01/20/Netty/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、NettyNetty 与 JDK 原生 NIO 相比，提供了非常简单易用的 API。 1. 主要优点 API 使用简单 - 开发门槛低 功能强大 - 预制了多种编码功能，支持多种主流协议 定制能力强 - 可以通过 ChannelHandler 对通信框架进行灵活扩展 性能高 - 与其他业界主流的 NIO 框架对比，Netty 的综合性能最优 成熟、稳定 - Netty 修复了已经发现的所有 J">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-01-19T16:00:00.000Z">
<meta property="article:modified_time" content="2021-01-20T06:09:09.332Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="框架及中间件">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Netty" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/20/Netty/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T16:00:00.000Z" itemprop="datePublished">2021-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Netty
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、Netty"><a href="#一、Netty" class="headerlink" title="一、Netty"></a>一、Netty</h1><p>Netty 与 JDK 原生 NIO 相比，提供了非常简单易用的 API。</p>
<h2 id="1-主要优点"><a href="#1-主要优点" class="headerlink" title="1. 主要优点"></a>1. 主要优点</h2><ul>
<li>API 使用简单 - 开发门槛低</li>
<li>功能强大 - 预制了多种编码功能，支持多种主流协议</li>
<li>定制能力强 - 可以通过 ChannelHandler 对通信框架进行灵活扩展</li>
<li>性能高 - 与其他业界主流的 NIO 框架对比，Netty 的综合性能最优</li>
<li>成熟、稳定 - Netty 修复了已经发现的所有 JDK NIO 中的 BUG，业务开发人员不需要再为 NIO 的 BUG 而烦恼</li>
<li>社区活跃 - 版本迭代周期短，发现的 BUG 可以被及时修复</li>
</ul>
<h2 id="2-IO底层原理"><a href="#2-IO底层原理" class="headerlink" title="2. IO底层原理"></a>2. IO底层原理</h2><p>用户程序进行 IO 读写，依赖于底层的 IO 读写。</p>
<p>需要注意的是，上层应用的IO操作实际上并不是物理设别级别的读写，而是缓存的复制：读取操作并不是直接从物理设备把数据读取到内存中，而是把数据从<code>内核缓冲区</code>复制到<code>进程缓冲区（用户缓冲区）</code>；而写操作也不是直接把数据写入物理设备，而是把数据从<code>进程缓冲区</code>复制到<code>内核缓冲区</code>，而底层的读写交换，由操作系统内核完成</p>
<p>内核缓冲区位于操作系统的内核空间，而进程缓冲区位于用户空间。</p>
<p><strong>缓冲区</strong></p>
<p>缓冲区的设计的目的，是为了避免频繁地与设备之间的物理交换。底层操作会对内核缓冲区进行监控，等待缓冲区达到一定数量后，集中执行物理设备的实际IO操作</p>
<p><strong>完成一次Java服务端的socket请求与响应流程</strong></p>
<ul>
<li>客户端请求 - Linux通过网卡读取客户端请求，将请求数据读取到内核缓冲区</li>
<li>获取请求数据 - Java进程从Linux内核缓冲区赋值数据到Java进程缓冲区</li>
<li>Java进程处理服务 - Java进程在自己的用户空间处理客户端的请求</li>
<li>返回数据 - Java进程处理完成后，构建响应数据并从用户缓冲区写入内核缓冲区</li>
<li>响应 - Linux内核通过网络IO，将内核缓冲区中的数据写入网卡，网卡通过底层通信协议，将数据响应给客户</li>
</ul>
<p><strong>阻塞与非阻塞的区别？同步与异步的区别？</strong></p>
<p>阻塞非阻塞 - 是用户空间程序的执行状态。</p>
<p><strong>阻塞</strong> 需要内核IO彻底完成后，才返回到用户空间执行用户的操作，此过程一直是阻塞状态(此过程不需要消耗CPU资源，但基本一个请求就需要占用一个线程，不适合高并发场景)</p>
<p><strong>非阻塞</strong> 这里分两种情况，如果用户进程请求的数据在内核缓冲区中存在，是阻塞的，会直到数据从内核缓冲区复制到用户缓冲区后返回；如果没有数据，调用会立刻返回，返回一个调用失败信息，然后需要用户进程不停调用（需要额外的CPU资源，但一个线程可以干更多事，需要注意的是Java的NIO不完全是同步非阻塞IO模型，虽然两种模型的英文缩写一样，Java中NIO模型是IO多路复用模型）</p>
<p>同步异步 - 是一种用户空间与内核空间的IO发起方式。</p>
<p><strong>同步IO</strong> 是指用户空间的线程是主动发起IO请求的一方，内核空间是被动接受方。</p>
<p><strong>异步IO</strong> 指系统内核是主动发起IO请求的一方，用户空间的线程是被动接受方，有点类似Java的回调模式，用户空间线程向内核空间注册IO事件的回调函数，由内核去主动调用。（需要内核提供支持，目前Windows通过IOCP实现真正异步IO，但Linux异步IO不完善，其底层是epoll模型，与IO多路复用相同）</p>
<h2 id="3-IO多路复用模型"><a href="#3-IO多路复用模型" class="headerlink" title="3. IO多路复用模型"></a>3. IO多路复用模型</h2><p>IO多路复用模型最大的优点就是避免了同步非阻塞IO模型中轮询等待的问题。</p>
<p>指一个进程/线程可以同时监视多个文件描述符（一个网络连接，操作系统底层使用一个文件描述符表示），一旦其中一个或多个文件可读或者可写，操作系统内核就通知该进程/线程。</p>
<p>目前支持IO多路复用的系统调用，有select、epoll等，select系统调用，几乎在所有的操作系统上都有支持，具有良好的跨平台特性，epoll是在Linux 2.6内核中提出的，是select系统调用的Linux增强版本</p>
<p>IO多路复用模型的一次请求流程如下：</p>
<ol>
<li>选择器注册 - 将客户端的请求的目标socket网络连接注册到选择器中，Java中对应的选择器类是Selector类</li>
<li>就绪状态的轮询 - 选择器轮询注册过的所有socket连接的就绪状态，内核会返回一个就绪的socket列表，如果和注册的socket匹配就可以将就绪的状态添加到一个选择器的集合（选择键集合）中</li>
<li>根据选择键集合执行实际的IO事件</li>
</ol>
<h2 id="4-修改Linux支持的最大句柄数"><a href="#4-修改Linux支持的最大句柄数" class="headerlink" title="4. 修改Linux支持的最大句柄数"></a>4. 修改Linux支持的最大句柄数</h2><p>为了支持更多的网络连接并发，需要修改Linux操作系统的支持的最大句柄数。</p>
<p>文件句柄，也叫文件描述符，是内核为了高效管理已被打开的文件所创建的索引，它是一个非负整数，用来指代被打开的文件。</p>
<p>如果文件句柄数不够，系统就会报Can’t open so many files的错误。</p>
<p>可以通过以下命令修改Linux最大句柄数(默认是1024)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n 1000000</span><br></pre></td></tr></table></figure>
<p>但这个命令是临时的，如果连接中断，用户退出，数值又会变回1024，所以需要修改开机启动文件/etc/rc.local</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -SHn 1000000</span><br></pre></td></tr></table></figure>
<p>添加以上内容，-S表示软性极限值，超过这个极限值，内核会发出警告，-H是硬性极限值</p>
<p>但是普通用户无法修改软性极限值，可以通过编辑/etc/security/limits.conf，加入以下内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soft nofile 1000000</span><br><span class="line">hard nofile 1000000</span><br></pre></td></tr></table></figure>
<p>在使用分布式搜索引擎ES的时候就必须修改这个文件</p>
<h2 id="5-Java-NIO"><a href="#5-Java-NIO" class="headerlink" title="5. Java NIO"></a>5. Java NIO</h2><p>Java NIO 由以下三个核心组件组成：</p>
<ul>
<li><p>Channel（通道）</p>
<p>在 JDK1.4 之前的OIO中，同一个网络连接会关联到两个流：一个输入流，一个输出流。通过这两个流，不断进行输入输出操作。NIO中，同一个网络连接使用一个通道表示，既可以从通道读，也可以从通道写</p>
</li>
<li><p>Buffer（缓冲区）</p>
<p>与通道直接交互的就是缓冲区，是OIO中没有的概念</p>
</li>
<li><p>Selector（选择器）</p>
<p>是一个IO事件的查询器，通过选择器，一个线程就可以查询多个通道的IO事件的就绪状态</p>
</li>
</ul>
<h3 id="5-1-缓冲区Buffer"><a href="#5-1-缓冲区Buffer" class="headerlink" title="5.1 缓冲区Buffer"></a>5.1 缓冲区Buffer</h3><p>NIO的Buffer类（缓冲区）是一个抽象类，位于java.nio包中，其本质是一个内存块(数组)，但它提供了一组更加有效的方法，用来进行写入和读取的交替访问。</p>
<p>需要强调的是 Buffer 是一个非线程安全的类</p>
<p>Buffer抽象类的子类有ByteBuffer(最常用)、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer、MappedByteBuffer</p>
<p><strong>Buffer的三个主要属性</strong></p>
<ul>
<li>capacity容量 - 一经初始化无法修改，存储单位是Buffer子类型的单位</li>
<li>position读写位置 - 初始是0，每写入一个+1，调用flip翻转方法切换为读模式时，position置0</li>
<li>limit读写长度限制 - 写入时，默认值和capacity相同，最大能写入的position为limit-1，调用flip方法后limit的值为翻转前position的值</li>
</ul>
<p><strong>主要方法</strong></p>
<ul>
<li><p>allocate()创建缓冲区</p>
<p>static IntBuffer intBuffer = IntBuffer.allocate(20); //分配了20*4个字节的空间,position:0;capacity,limit:20</p>
</li>
<li><p>put()写入缓冲区</p>
<p>intBuffer.put(1); //position:1</p>
</li>
<li><p>flip()翻转</p>
<p>intBuffer.flip(); //position:0;capacity:20;limit:1，要重新切换回写方法，可以使用clear()清空 或 compact()压缩方法，缓冲区是可以重复写的</p>
</li>
<li><p>get()读缓冲区</p>
<p>int a = intBuffer.get();  //position+1，当positon和limit相等时再执行get()会报错</p>
</li>
<li><p>rewind()倒带</p>
<p>可以重新读已经读完的缓冲区，即position置0，并清除mark标记</p>
</li>
<li><p>mark()与reset()</p>
<p>mark将当前position值保存起来，reset将postion重新设为mark的值</p>
</li>
<li><p>clear()清空缓冲区</p>
<p>缓冲区切为写模式，postion置空，limit赋为capacity的值</p>
</li>
</ul>
<h3 id="5-2-通道Channel"><a href="#5-2-通道Channel" class="headerlink" title="5.2 通道Channel"></a>5.2 通道Channel</h3><p>NIO的一个连接可以用一个Channel来表示</p>
<p>Java Channel中最重要的四种通道：FileChannel、SocketChannel、ServerSocketChannel、DatagramChannel</p>
<ul>
<li><p>FileChannel文件通道</p>
<p>用于文件的数据读写，是阻塞模式，不能设置为非阻塞模式</p>
<ul>
<li><p>获取通道</p>
<p>可以根据输入、输出流获取通道</p>
<p>fileInputStream.getChannel();</p>
<p>也可以通过文件随机访问类，获取通道</p>
<p>RandomAccessFile file = new RandomAccessFile ([filename.txt],[rw]);</p>
<p>FileChannel channel = file.getChannel();</p>
</li>
<li><p>读取通道</p>
<p>通过int read(ByteBuffer buf);方法从通道读取数据，并写入到缓冲区中</p>
<p>ByteBuffer byteBuffer = ByteBuffer.allocate(20);</p>
<p>int length = -1;</p>
<p>while((length = channel.read(buf)) != -1){</p>
<p>//处理读取到的buf的数据</p>
<p>}</p>
</li>
<li><p>写入通道</p>
<p>通过int write(ByteBuffer buf);方法从缓冲区读取数据，并写入到通道中</p>
<p>buffer.flip();//翻转缓冲区为读模式</p>
<p>int outLength = 0;</p>
<p>while((outLength = outchannel.write(buffer)) != 0){</p>
<p>sout(写入的字节数：outLength);</p>
<p>}</p>
</li>
<li><p>关闭通道</p>
<p>channel.close();</p>
</li>
<li><p>强制刷新到磁盘</p>
<p>在将缓冲区数据写入通道时，处于性能原因，操作系统不可能实时将通道数据写入文件，可以通过force()方法将数据强制写入文件</p>
<p>channel.force(true);</p>
</li>
</ul>
</li>
<li><p>SocketChannel套接字通道</p>
<p>用于Socket套接字TCP连接的数据读写</p>
</li>
<li><p>ServerSocketChannel服务器嵌套字通道</p>
<p>允许我们监听TCP连接请求，为每个监听到的请求，创建一个SocketChannel套接字通道</p>
<p>ServerSocketChannel应用于服务器端，而SocketChannel同时处于服务器端和客户端，两种通道都支持阻塞或非阻塞的配置通过configureBlocking方法，true为阻塞，false为非阻塞</p>
<ul>
<li><p>获取SocketChannel通道</p>
<p>在客户端，通过socketChannel对服务器ip,端口发起连接：</p>
<p>SocketChannel socketChannnel = SocketChannel.open();</p>
<p>socketChannel.configureBlocking(false); //非阻塞方式</p>
<p>socketChannel.connet(new InetSocketAddress([127.0.0.1],80));</p>
<p>while(! socketChannel.finishConnect()){//因为是异步所以需要轮询检查完成情况</p>
<p>}</p>
<p>在服务端，通过ServerSocketChannel监听获取SocketChannel：</p>
<p>ServerSocketChannel server = (ServerSocketChannel) key.channel();//通过事件获取监听通道</p>
<p>SocketChannel socketchannel = server.accept();</p>
<p>socketchannel.configureBlocking(false);</p>
</li>
<li><p>读取SocketChannel</p>
<p>和文件通道读取访问一样</p>
<p>ByteBuffer buf = ByteBuffer.allocate(1024);</p>
<p>int bytesRead = socketChannel.read(buf);</p>
<p>但和文件通道不一样的是，socket通道是异步的，所以需要根据返回值(读取的字节数)判断是否读到数据，如果返回的是-1表示通道数据读完，可以关闭通道了。这样非常复杂，所以就需要Selector选择器</p>
</li>
<li><p>写入SocketChannel</p>
<p>buffer.flip();</p>
<p>socketChannel.write(buffer);</p>
</li>
<li><p>关闭SocketChannel</p>
<p>在关闭前，如果传输通道用来写入数据，则先调shutdownOutput()终止输出方法，然后调用socketChannel.close()方法，关闭套接字连接</p>
<p>socketChannel.shutdownOutput();</p>
<p>IOUtil.closeQuiely(socketChannel);</p>
</li>
</ul>
</li>
<li><p>DatagramChannel数据报通道</p>
<p>用于UDP协议的读写，和Socket套接字不同在于，UDP不是面向连接的协议，所以只要知道服务器的ip和端口，就可以发送数据</p>
<ul>
<li><p>获取通道</p>
<p>DatagramChannel channel = DatagramChannel.open();</p>
<p>channel.configureBlocking(false);</p>
</li>
<li><p>绑定数据报监听端口</p>
<p>channel.socket().bind(new InetSocketAddress(10222));</p>
</li>
<li><p>读取通道</p>
<p>ByteBuffer buf = ByteBuffer.allocate(1024);</p>
<p>SocketAddress clientAddr = channel.receive(buf);//返回值是发送端的ip和端口</p>
<p>非阻塞模式下需要选择器确认什么时候可读</p>
</li>
<li><p>写入通道</p>
<p>buffer.flip();</p>
<p>sendChannel.send(buffer,new InetAddress(ip,port));</p>
<p>buffer.clear();</p>
</li>
<li><p>关闭通道</p>
<p>channel.close();</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-3-选择器Selector"><a href="#5-3-选择器Selector" class="headerlink" title="5.3 选择器Selector"></a>5.3 选择器Selector</h3><p>选择器可以监控多个通道的IO状态，并把状态达成的事件放入SelelctKey集合中（可以从SelectKey中获取IO事件类型、IO事件发生的通道、绑定的附件等）。</p>
<p><strong>那么通道如何注册到选择器上呢?</strong></p>
<p>channel.register(Selector sel , int ops)</p>
<p>第一个参数是要注册到的选择器，第二个参数指定选择器要监控的IO事件类型</p>
<p>可供选择器监控的通道IO事件类型，包括以下四种</p>
<ul>
<li>可读SelectionKey.OP_READ：通道有数据可读状态</li>
<li>可写SelectionKey.OP_WRITE：一个等待写入数据的通道状态</li>
<li>连接SelectionKey.OP_CONNECT：SocketChannel完成了和对端的连接状态</li>
<li>接收SelectionKey.OP_ACCEPT：ServerSocketChannel监听到了一个新连接的到来</li>
</ul>
<p>如果要监控多个事件，使用按位或的方式实现SelectionKey.OP_READ|SelectionKey.OP_WRITE</p>
<p><strong>所有通道类型都可以被选择器监控吗？</strong></p>
<p>并不是，只有继承了抽象类SelectableChannel的才可以被监控</p>
<p><strong>以下为选择器的使用流程：</strong></p>
<ol>
<li><p>获取选择器实例</p>
<p>Selector selector = Selector.open();</p>
</li>
<li><p>将通道注册到选择器实例</p>
<p>ServerSocketChannel channel = ServerSocketChannel.open();</p>
<p>channnel.configureBlocking(false);//需要注意，注册到选择器的通道必须是非阻塞模式</p>
<p>channnel.bind(new InetAddress(port));</p>
<p>channel.register(selector,SelectionKey.OP_ACCEPT);</p>
</li>
<li><p>选出感兴趣的IO就绪事件（选择键集合）</p>
<p>while(selector.select() &gt; 0 ){//阻塞调用，一直到至少有一个通道发生了注册IO事件</p>
<p>Iterator keyIterator = selector.selectedKeys().iterator();</p>
<p>while(keyIterator.hasNext()){</p>
<p>SelectionKey key = keyIterator.next();</p>
<p>if(key.isAcceptable()){//通道处于可接收状态，执行注册的IO事件</p>
<p>}else if(key.isConnectable()){//通道处于连接状态，执行注册的IO事件</p>
<p>}else if(key.isReadable()){//通道处于可读状态，执行注册的IO事件</p>
<p>}else if(key.isWritable()){//通道处于可写状态，执行注册的IO事件</p>
<p>}</p>
<p>keyIterator.remove();//处理完成后移除选择键</p>
<p>}}</p>
</li>
</ol>
<h2 id="6-Reactor反应器模式"><a href="#6-Reactor反应器模式" class="headerlink" title="6. Reactor反应器模式"></a>6. Reactor反应器模式</h2><p>Reactor反应器模式是高性能网络编程在设计和架构层面的基础模式。其在Nginx、Redis、Netty中都有应用。</p>
<h3 id="6-1-定义及优缺点"><a href="#6-1-定义及优缺点" class="headerlink" title="6.1 定义及优缺点"></a>6.1 定义及优缺点</h3><p>反应器模式由Reactor反应器线程、Handlers处理器两大角色组成</p>
<ul>
<li>Reactor反应器线程的职责：负责响应IO事件，并且分发到Handlers处理器</li>
<li>Handlers负责非阻塞的执行业务逻辑</li>
</ul>
<p>优点</p>
<ol>
<li>响应快 - 虽然同一反应器线程本身是同步的，但不会被单个连接的同步IO阻塞</li>
<li>编程相对简单 - 最大程度避免了多线程同步数据问题，也避免了多线程的各个进程切换的开销</li>
<li>可拓展，可以方便地通过增加反应器线程的个数来充分利用CPU资源</li>
</ol>
<p>缺点</p>
<ol>
<li>反应器模式增加了一定的复杂性，因而有一定的门槛，而不易于调试</li>
<li>反应器模式需要操作系统底层的IO多路复用的支持，如Linux中的epoll。如果操作系统的底层不支持IO多路复用，反应器模式不会那么高效</li>
</ol>
<h3 id="6-2-多线程OIO"><a href="#6-2-多线程OIO" class="headerlink" title="6.2 多线程OIO"></a>6.2 多线程OIO</h3><p>最初的网络服务器程序使用以下逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">socket = accept();<span class="comment">//阻塞，接收线程</span></span><br><span class="line">handle(socket);<span class="comment">//业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最大的问题是：如果前一个handle没有处理完，后面的连接请求就无法接收，影响服务器吞吐量</p>
<p>于是出现了经典的Connection Per Thread（一个线程处理一个连接）模式</p>
<blockquote>
<p>一个线程轮询接收任务，接收到任务后创建一个执行线程异步执行</p>
</blockquote>
<p>早期的Tomcat服务器就是这样实现的，但同样存在一个问题，对于大量的连接，需要耗费大量的线程资源。</p>
<p>解决方式是使用Reactor反应器模式，对线程数量进行控制，做到一个线程处理大量的连接</p>
<h3 id="6-3-单线程Reactor反应器模式"><a href="#6-3-单线程Reactor反应器模式" class="headerlink" title="6.3 单线程Reactor反应器模式"></a>6.3 单线程Reactor反应器模式</h3><p>Reactor反应器模式类似事件驱动模型</p>
<p>在事件驱动模式中，当有事件触发时，事件源会将事件dispatch分发到handle处理器进行事件处理。反应器中的反应器角色，类似事件驱动模式中 dispatcher 事件分发器角色。</p>
<ul>
<li>Reactor反应器：负责查询IO事件，当检测到一个IO事件，将其发送给相应的Handler处理器去处理。这里的IO事件，就是NIO中选择器监控的通道IO事件</li>
<li>Handler处理器：与IO事件绑定，负责IO事件的处理。完成真正的连接建立、通道的读取、处理业务逻辑、负责将结果写出到通道等</li>
</ul>
<p>而单线程Reactor反应器模式就是反应器和处理器在一个线程中执行，那么是如何实现的，主要基于以下方法：</p>
<ul>
<li><p>void attach(Object o)</p>
<p>此方法可以把任何java对象作为附件添加到SelectionKey中，当现场Reactor需要将Handler处理器实例，作为附件添加到SelectionKey中</p>
</li>
<li><p>Object attachment()</p>
<p>此方法是取出SelectionKey的附件</p>
</li>
</ul>
<p>所以单线程Reactor反应器实现如下</p>
<ol>
<li>注册通道到选择器上后(register方法有返回值SelectionKey)，根据返回值绑定Handler实例(一个Runable实现类)</li>
<li>反应器轮询拿到触发了事件的SelectionKey，再分发给绑定在SelectionKey上的Handler业务处理器，并执行</li>
</ol>
<p>最后通过一个Reactor反应器项目(回显服务器)来完整的了解单线程的Reactor反应器模式</p>
<p>EchoServer回显服务器的功能很简单：读取客户端的输入，回显到客户端，所以也叫回显服务器。</p>
<p>这里主要涉及了3个重要的类：</p>
<ol>
<li>反应器类：EchoServerReactor类</li>
<li>两个处理器类：AcceptorHandler 新连接处理器、EchoHandler回显处理器</li>
</ol>
<p>反应器类EchoServerReactor:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleReactor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Selector selector;</span><br><span class="line">    ServerSocketChannel serverSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleReactor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//...获取选择器、开启 serverSocket 服务监听通道</span></span><br><span class="line">        <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">        <span class="keyword">this</span>.serverSocket = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//需要注意，注册到选择器的通道必须是非阻塞模式</span></span><br><span class="line">        serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">10002</span>));</span><br><span class="line">        SelectionKey sk = serverSocket.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">//...绑定AcceptorHandler 新连接处理器到selectKey</span></span><br><span class="line">        sk.attach(<span class="keyword">new</span> AcceptorHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 轮询和分发事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//线程不被中断就一直轮询</span></span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                selector.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; selected = selector.selectedKeys();</span><br><span class="line">                <span class="keyword">for</span> (SelectionKey sk : selected) &#123;</span><br><span class="line">                    <span class="comment">//反应器负责 dispatch 收到的事件</span></span><br><span class="line">                    dispatch(sk);</span><br><span class="line">                &#125;</span><br><span class="line">                selected.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey sk)</span> </span>&#123;</span><br><span class="line">        Runnable handler = (Runnable) sk.attachment();</span><br><span class="line">        <span class="comment">//调用之前 attach 绑定到选择键的 handler 处理器对象</span></span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handler.run();<span class="comment">//因为是run不是start所以不会创建新线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handler:新连接处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AcceptorHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SocketChannel channel = serverSocket.accept();</span><br><span class="line">                <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">new</span> SingleReactorHandler(selector, channel);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">          <span class="keyword">new</span> Thread(<span class="keyword">new</span> SingleReactor()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EchoHandler 回显处理器，主要是完成客户端的内容读取和回显，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleReactorHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line">    <span class="keyword">final</span> SelectionKey sk;</span><br><span class="line">    <span class="keyword">final</span> ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECEVING = <span class="number">0</span>, SENDING = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> state = RECEVING;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleReactorHandler</span><span class="params">(Selector selector, SocketChannel c)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = c;</span><br><span class="line">        c.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//获取选择键，再设置感兴趣的IO事件，这里注册到和反应器同一个选择器中</span></span><br><span class="line">        <span class="keyword">this</span>.sk = channel.register(selector, RECEVING);</span><br><span class="line">        <span class="comment">//将 Handler 自身作为选择器的附件</span></span><br><span class="line">        sk.attach(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//注册Read就绪事件</span></span><br><span class="line">        sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        selector.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (state == SENDING) &#123;</span><br><span class="line">                <span class="comment">//写入通道</span></span><br><span class="line">                channel.write(byteBuffer);</span><br><span class="line">                <span class="comment">//写完后，准备开始从通道读，byteBuffer切换成写入模式</span></span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">                <span class="comment">//写完后，切换为接收的状态</span></span><br><span class="line">                state = RECEVING;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == RECEVING) &#123;</span><br><span class="line">                <span class="comment">//从通道读</span></span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((length = channel.read(byteBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    log.info(<span class="keyword">new</span> String(byteBuffer.array(), <span class="number">0</span>, length));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//读完后，准备开始写入通道，buteBuffer 切换成读取模式</span></span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                <span class="comment">//注册write就绪事件</span></span><br><span class="line">                sk.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">                <span class="comment">//读完后，进入发送状态</span></span><br><span class="line">                state = SENDING;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理结束后不能关闭selectKey，需要重复使用</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>单线程Reactor反应器模式，是基于Java的NIO实现的。相较于传统的多线程OIO，反应器模式不再需要启动成千上万条线程。</p>
<p>但同样有问题，当其中某个Handler阻塞时，会导致其他所有Handler得不到执行，当然AcceptorHandler(新连接处理器)也被阻塞，导致服务不能接受到新连接，因此单线程反应器模型用的比较少</p>
<h3 id="6-4-多线程的Reactor反应器模式"><a href="#6-4-多线程的Reactor反应器模式" class="headerlink" title="6.4 多线程的Reactor反应器模式"></a>6.4 多线程的Reactor反应器模式</h3><p>多线程池Reactor反应器的演进，分为两个方面：</p>
<ol>
<li>升级Handler处理器。既要使用多线程，又要尽可能高效率，采用线程池</li>
<li>升级Reactor反应器。引入多个Selector选择器(即多个子反应器，每个反应器负责一个选择器)，提升大量通道的能力</li>
</ol>
<p>下面看一下反应器代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiThreadEchoServerReactor</span> </span>&#123; </span><br><span class="line">    ServerSocketChannel serverSocket;</span><br><span class="line">    AtomicInteger next = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//选择器集合，引入多个选择器</span></span><br><span class="line">    Selector[] selectors = <span class="keyword">new</span> Selector[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//引入多个子反应器</span></span><br><span class="line">    SubReactor[] subReactors = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiThreadReactor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//初始化多个选择器</span></span><br><span class="line">        selectors[<span class="number">0</span>] = Selector.open();</span><br><span class="line">        selectors[<span class="number">1</span>] = Selector.open();</span><br><span class="line">        serverSocket = ServerSocketChannel.open();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10003</span>);</span><br><span class="line">        serverSocket.socket().bind(address);</span><br><span class="line">        <span class="comment">//非阻塞</span></span><br><span class="line">        serverSocket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//第一个选择器，负责监控新连接事件</span></span><br><span class="line">        SelectionKey sk = serverSocket.register(selectors[<span class="number">0</span>], SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">//绑定Handler: attach 新连接监控 handler 处理器到 SelectionKey（选择键）</span></span><br><span class="line">        sk.attach(<span class="keyword">new</span> AcceptorHandler());</span><br><span class="line">        <span class="comment">//第一个子反应器，对应一个选择器</span></span><br><span class="line">        SubReactor subReactorl = <span class="keyword">new</span> SubReactor(selectors[<span class="number">0</span>]);</span><br><span class="line">        SubReactor subReactor2 = <span class="keyword">new</span> SubReactor(selectors[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">this</span>.subReactors = <span class="keyword">new</span> SubReactor[]&#123;subReactorl, subReactor2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个子反应器对应一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(subReactors[<span class="number">0</span>]).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(subReactors[<span class="number">1</span>]).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子反应器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubReactor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个子反应器负责一个选择器的查询和选择</span></span><br><span class="line">        <span class="keyword">final</span> Selector selector;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SubReactor</span><span class="params">(Selector selector)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.selector = selector;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    Set&lt;SelectionKey&gt; keySet = selector.selectedKeys();</span><br><span class="line">                    <span class="keyword">for</span> (SelectionKey sk : keySet) &#123;</span><br><span class="line">                        <span class="comment">//反应器负责dispatch收到的事件</span></span><br><span class="line">                        dispatch(sk);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(SelectionKey sk)</span> </span>&#123;</span><br><span class="line">            Runnable handler = (Runnable) sk.attachment();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                handler.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Handler：新连接处理器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptorHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SocketChannel channel = serverSocket.accept();</span><br><span class="line">                <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">new</span> MultiThreadEchoHandler(selectors[next.get()], channel);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next.incrementAndGet() == selectors.length) &#123;<span class="comment">//如果原子整数自增到选择器长度置0</span></span><br><span class="line">                next.set(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        MultiThreadEchoServerReactor server = <span class="keyword">new</span> MultiThreadEchoServerReactor();</span><br><span class="line">        server.startService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行器的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadEchoHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> SocketChannel channel;</span><br><span class="line">    <span class="keyword">final</span> SelectionKey sk;</span><br><span class="line">    <span class="keyword">final</span> ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECEIVING = <span class="number">0</span>, SENDING = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> state = RECEIVING;</span><br><span class="line">    <span class="comment">//引入线程池</span></span><br><span class="line">    <span class="keyword">static</span> ExecutorService pool = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiThreadEchoHandler</span><span class="params">(Selector selector, SocketChannel c)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = c;</span><br><span class="line">        c.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//将通道注册到选择器上</span></span><br><span class="line">        <span class="keyword">this</span>.sk = channel.register(selector, RECEIVING);</span><br><span class="line">        <span class="comment">//将本Handler绑定到选择键上</span></span><br><span class="line">        sk.attach(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//向sk选择键注册Read就绪事件</span></span><br><span class="line">        sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        selector.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//异步任务，在独立的线程池中执行</span></span><br><span class="line">        pool.execute(<span class="keyword">new</span> AsyncTask());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            MultiThreadEchoHandler.<span class="keyword">this</span>.asyncRun();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">asyncRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (state == SENDING) &#123;</span><br><span class="line">                <span class="comment">//写入通道</span></span><br><span class="line">                channel.write(byteBuffer);</span><br><span class="line">                <span class="comment">//写完后，准备开始从通道读，byteBuffer切换成写入模式</span></span><br><span class="line">                byteBuffer.clear();</span><br><span class="line">                <span class="comment">//写完后，切换为接收的状态</span></span><br><span class="line">                state = RECEIVING;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == RECEIVING) &#123;</span><br><span class="line">                <span class="comment">//从通道读</span></span><br><span class="line">                <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((length = channel.read(byteBuffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    log.info(<span class="keyword">new</span> String(byteBuffer.array(), <span class="number">0</span>, length));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//读完后，准备开始写入通道，buteBuffer 切换成读取模式</span></span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                <span class="comment">//注册write就绪事件</span></span><br><span class="line">                sk.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">                <span class="comment">//读完后，进入发送状态</span></span><br><span class="line">                state = SENDING;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理结束后不能关闭selectKey，需要重复使用</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-异步回调模式"><a href="#7-异步回调模式" class="headerlink" title="7. 异步回调模式"></a>7. 异步回调模式</h2><p>Netty中大量使用了异步回调技术，并且基于Java的异步回调，设计了自己的一套异步回调接口和实现</p>
<h3 id="7-1-FutureTask"><a href="#7-1-FutureTask" class="headerlink" title="7.1 FutureTask"></a>7.1 FutureTask</h3><p>要实现异步回调。我们可以使用join异步阻塞方法，但join有一个问题：被合并的线程没有返回值。</p>
<p>所以为了获得异步线程的返回结果，JDK1.5 后提供了 FutureTask 方式。其最重要的是FutureTask类和Callable接口。</p>
<p><strong>Callable</strong></p>
<p>Callable是一个函数式接口，其唯一的抽象方法 call 有返回值</p>
<p>Java中的线程类，只有一个Thread类，如果 Callable 实例需要异步执行，就要转为Thread类，但Thread类构造方法参数类型是Runnable类型。为此，Java 提供了在 Callable 实例和 Thread 的构造参数之间的一个搭桥类——FutureTask类。</p>
<p><strong>FutureTask</strong></p>
<p>FutureTask 构造函数的参数为Callable类型，实际上是对Callable的二次封装，FutureTask间接继承了Runnable接口，从而可以作为Thread的构造参数使用。</p>
<p>在Java语言中，将FutureTask类的一系列操作，抽象出来作为一个重要接口——Future接口。</p>
<blockquote>
<p>Future接口主要提供了以下抽象方法</p>
<p>V get(); 获取并发执行结果，这个方法是阻塞的</p>
<p>boolean isDone(); 判断并发任务是否执行完成</p>
<p>boolean cancel(boolean mayInterruptRunning); 取消并发任务的执行</p>
</blockquote>
<p>而FutureTask实现了Future接口，提供了外部操作异步任务的能力。</p>
<p>FutureTask内部有一个Runnable的run方法，会执行callable的call方法，然后将结果保存到成员变量outcome中，可供FutureTask类的结果获取方法get()获取。</p>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WashJob</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Logger.info(<span class="string">&quot;洗碗&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    Callable&lt;Boolean&gt; job = <span class="keyword">new</span> WashJob();</span><br><span class="line">    FutureTask&lt;Boolean&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(job);<span class="comment">//将Callable函数接口保存为成员变量，在run中执行</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(task);<span class="comment">//因为Callable也实现了Runnable接口</span></span><br><span class="line">    thread.start();</span><br><span class="line">    <span class="keyword">boolean</span> result = task.get();<span class="comment">//阻塞拿到执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但原生的 Java Api 没有提供阻塞以外的方法获取返回结果，被阻塞的线程不能干任何事，所以Guava框架提供了非阻塞获取结果的方式</p>
<h3 id="7-2-Guava的异步回调"><a href="#7-2-Guava的异步回调" class="headerlink" title="7.2 Guava的异步回调"></a>7.2 Guava的异步回调</h3><p>Guava 是谷歌公司提供的 Java 扩展包。为了实现非阻塞的获取异步线程结果，Guava对Java的异步回调，做了以下增强：</p>
<ul>
<li><p>引入了一个新接口 ListenableFuture </p>
<p>继承了Java的 Future 接口，使得Future异步任务，在Guava中能被监控和获取非阻塞执行结果</p>
</li>
<li><p>引入了一个新接口 FutureCallback</p>
<p>这是一个独立的新接口。该接口的目的，是在异步执行完任务后，根据异步结果，完成不同的回调处理，并且可以处理异步结果。</p>
<p>它提供了两个回调方法：onSuccess，参数是任务执行结果；onFailure，参数是发送的异常。</p>
</li>
</ul>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WashJob</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Logger.info(<span class="string">&quot;洗碗&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    Callable&lt;Boolean&gt; job = <span class="keyword">new</span> WashJob();</span><br><span class="line">    <span class="comment">//创建java线程池</span></span><br><span class="line">    ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//包装java线程池，构造Guava线程池</span></span><br><span class="line">    ListeningExecutorService gPool = MoreExecutors.listeningDecorator(pool);</span><br><span class="line">    <span class="comment">//提交任务到Guava线程池，获取异步任务</span></span><br><span class="line">    ListenableFuture&lt;Boolean&gt; future = gPool.submit(job);</span><br><span class="line">    <span class="comment">//绑定异步回调方法</span></span><br><span class="line">    Futures.addCallback(future，<span class="keyword">new</span> FutureCallback&lt;Boolean&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Boolean r)</span></span>&#123;</span><br><span class="line">            <span class="comment">//处理结果r</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span></span>&#123;</span><br><span class="line">            <span class="comment">//处理异常t</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-Netty的异步回调模式"><a href="#7-3-Netty的异步回调模式" class="headerlink" title="7.3 Netty的异步回调模式"></a>7.3 Netty的异步回调模式</h3><p>Netty 和 Guava 一样，实现了自己的异步回调体系：Netty继承和扩展了JDK Future异步回调API，定义了自己的Future 系列接口和类(注意：Netty的扩展Future也叫Future)，实现了异步任务的监控、异步执行结果的获取。</p>
<p>Netty 应用的 Handler 执行器中的业务代码都是异步执行的。</p>
<p>总体，Netty 对 Java Future 异步任务的扩展如下：</p>
<ul>
<li><p>继承 Java 的 Future 接口</p>
<p>得到了一个新的属于 Netty 自己的 Future 异步任务接口，对应 Guava 的 ListenableFuture 接口，但Netty的Future接口一般不会直接使用，而是会使用子接口，如ChannleFuture接口表示通道IO的异步任务</p>
</li>
<li><p>引入了新接口 GenericFutureListener</p>
<p>用于表示异步执行完成的监听器，对应Guava的FutureCallback</p>
</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture future = bootstrap.connect(<span class="keyword">new</span> InetSocketAddress(ip,port));</span><br><span class="line">future.addListener(<span class="keyword">new</span> ChannelFutureListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">opertionComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(channelFuture.isSuccess())&#123;</span><br><span class="line">            <span class="comment">//成功逻辑</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//失败逻辑</span></span><br><span class="line">            channelFuture.cause().printStackTrce();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="8-Netty原理与基础"><a href="#8-Netty原理与基础" class="headerlink" title="8. Netty原理与基础"></a>8. Netty原理与基础</h2><p>Netty 是为了快速开发可维护的高性能、高可拓展、网络服务器和客户端程序而提供的异步事件驱动基础框架和工具。</p>
<h3 id="8-1-一个简单的netty-demo"><a href="#8-1-一个简单的netty-demo" class="headerlink" title="8.1 一个简单的netty demo"></a>8.1 一个简单的netty demo</h3><ol>
<li><p>导入maven依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.6.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一个服务器端类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyDiscardServer</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> serverPort;</span><br><span class="line">    ServerBootstrap b = <span class="keyword">new</span> ServerBootstap();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyDiscardServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverPort = port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建反应器线程组</span></span><br><span class="line">        EventLoopGroup bossLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);<span class="comment">//负责IO事件监听</span></span><br><span class="line">        EventLoopGroup workerLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();<span class="comment">//负责IO事件的处理</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//1.设置反应器线程组</span></span><br><span class="line">            b.group(bossLoopGroup, workerLoopGroup);</span><br><span class="line">            <span class="comment">//2.设置nio类型的通道</span></span><br><span class="line">            b.channel(NioServerSocketChannel.class);</span><br><span class="line">            <span class="comment">//3.设置监听端口</span></span><br><span class="line">            b.localAddress(<span class="keyword">this</span>.serverPort);</span><br><span class="line">            <span class="comment">//4.设置通道的参数</span></span><br><span class="line">            <span class="comment">// 启用TCP心跳机制，只有在连接空闲的时候才会起作用</span></span><br><span class="line">            b.option(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 设置缓冲区的分配方式为池化分配器(Netty4支持)</span></span><br><span class="line">            b.option(ChannelOption.ALLOCATOR,PooledByteBufAllocator.DEFAULT);</span><br><span class="line">            <span class="comment">//5.装配子通道流水线</span></span><br><span class="line">            b.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;()&#123;</span><br><span class="line">                <span class="comment">//有连接到达时会创建一个通道</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">                    <span class="comment">//流水线管理子通道中Handler处理器</span></span><br><span class="line">                    <span class="comment">//向子通道流水线添加一个handler处理器</span></span><br><span class="line">                    ch.pipeline().addList(<span class="keyword">new</span> NettyDiscardHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//6.开始绑定服务器</span></span><br><span class="line">            <span class="comment">// 通过调用 sync 同步方法阻塞知道绑定成功</span></span><br><span class="line">            ChannelFuture channelFuture = b.bind().sync();</span><br><span class="line">            Logger.info(<span class="string">&quot;服务器启动成功，监听端口:%s&quot;</span>,channelFuture.channel().localAddress());</span><br><span class="line">            <span class="comment">//7.等待通道关闭的异步任务结束</span></span><br><span class="line">            <span class="comment">//服务监听通道会一直等待通道关闭的异步任务结束</span></span><br><span class="line">            ChannelFuture closeFuture = channelFuture.channel().closeFuture();</span><br><span class="line">            closeFuture.sync();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//8.关闭EventLoopGroup</span></span><br><span class="line">            <span class="comment">//释放掉所有资源包括创建的线程</span></span><br><span class="line">            workLoopGroup.shutdownGracefully();</span><br><span class="line">            bossLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = NettyDemoConfig.SOCKET_SERVER_PORT;</span><br><span class="line">        <span class="keyword">new</span> NettyDiscardServer(port).runServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Netty是基于反应器模式实现的。之前说到反应器的作用是进行一个IO事件的selelct查询和dispatch分发。</p>
<p>Netty中反应器组件有多种，一般来说，对应于多线程的Java Nio通信的应用场景，是NioEventLoopGroup;</p>
<p>ServerBootstrap 是 Netty 的服务启动类，它的职责是一个组装和集成器，将不同的Netty组件组装在一起。另外，ServerBootstrap能够按照应用场景的需要，为组件设置好对应的参数，最后实现 Netty 服务器的监听和启动。</p>
</li>
<li><p>定义业务处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyDiscardHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx,Object msg)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Logger.info(<span class="string">&quot;收到消息&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(in.isReadable())&#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>) in.readByte());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//在最后一个处理器中需要释放缓冲区，缓冲区有多种释放方式，在后文中有介绍</span></span><br><span class="line">            ReferenceContUtil.relase(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里引入一个新概念：入站和出站。简单来说入站指输入，出站指的是输出。</p>
<p>​        Netty 的 Handler 处理器需要处理多种IO事件，Netty提供了一些基础的方法，这些方法都已经提前封装好，后面直接继承或者实现即可。比如处理入站的IO事件的方法，对应的接口为ChannelInboundHandler入站处理接口，而ChannelInboundHandlerAdapter是Netty提供的入站处理的默认实现。</p>
</li>
</ol>
<h3 id="8-2-Netty的Reactor反应器模式"><a href="#8-2-Netty的Reactor反应器模式" class="headerlink" title="8.2 Netty的Reactor反应器模式"></a>8.2 Netty的Reactor反应器模式</h3><h4 id="8-2-1-Netty中的Channel"><a href="#8-2-1-Netty中的Channel" class="headerlink" title="8.2.1 Netty中的Channel"></a>8.2.1 Netty中的Channel</h4><p>Netty 中 不直接使用 Java NIO 的 Channel 通道组件，对 Channel 进行了自己的封装。在 Netty 中，有一系列的通道组件，支持多种协议</p>
<p>对于不同协议，Netty 中常见的通道类型如下：</p>
<ul>
<li>NioSocketChannel - 异步非阻塞 TCP Socket 传输通道</li>
<li>NioServerSocketChannel - 异步非阻塞 TCP Socket 服务器端监听通道</li>
<li>NioDatagramChannel - 异步非阻塞的UDP传输通道</li>
<li>NioSctpChannel - 异步非阻塞Sctp传输通道</li>
<li>NioSctpServerChannel - 异步非阻塞Sctp服务器端监听端口</li>
<li>OioSocketChannel - 同步阻塞 TCP Socket 传输通道</li>
<li>OioServerSocketChannel - 同步阻塞 TCP Socket 服务器端监听通道</li>
<li>OioDatagramChannel - 同步阻塞的UDP传输通道</li>
<li>OioSctpChannel - 同步阻塞 Sctp传输通道</li>
<li>OioSctpServerChannel - 同步阻塞Sctp服务器端监听端口</li>
</ul>
<p>Channel的主要方法如下</p>
<ul>
<li><p>ChannelFuture connect(SocketAddress address)</p>
<p>用于客户端 传输通道 连接远程服务器。该方法调用后会立刻返回，返回值为负责连接操作的异步任务。</p>
</li>
<li><p>ChannelFuture bind(SocketAddress address)</p>
<p>用于服务器的新连接监听和接收通道 绑定监听端口，开始监听新的客户端连接。</p>
</li>
<li><p>ChannelFuture close()</p>
<p>用于关闭通道连接。如果需要在正式关闭通道后执行一些操作。可以为异步任务设置回调方法或者直接调sync()方法阻塞当前线程一直到通道关闭的异步任务完毕。</p>
</li>
<li><p>Channel read()</p>
<p>读取通道数据，并启动入站处理。具体就是从内部的Java NIO通道读取数据，然后启用内部的流水线。此方法返回通道自身用于链式调用</p>
</li>
<li><p>ChannelFuture write(Object o)</p>
<p>启动出站处理。把处理后的最终数据写到Java NIO通道。此方法的返回值为出站处理的异步处理任务</p>
</li>
<li><p>Channel flush()</p>
<p>可以将缓冲区的数据立刻写出到对端，write操作大部分情况下仅仅是写入到操作系统的缓冲区，操作系统会将根据缓冲区的情况，决定什么时候把数据写到对端。</p>
</li>
</ul>
<h4 id="8-2-2-Netty中的Reactor反应器"><a href="#8-2-2-Netty中的Reactor反应器" class="headerlink" title="8.2.2 Netty中的Reactor反应器"></a>8.2.2 Netty中的Reactor反应器</h4><p>Netty中的反应器有多个实现类，与Channel通道类型关联。比如NioSocketChannl通道，Netty的反应器类为NioEventLoop。</p>
<p>一个NioEnventLoop反应器拥有一个线程，其内部有一个Nio选择器成员执行事件的查询，然后进行对应事件的分发，而分发的目标就是Netty自己的Handler处理器</p>
<h4 id="8-2-3-Netty中的Handler处理器"><a href="#8-2-3-Netty中的Handler处理器" class="headerlink" title="8.2.3 Netty中的Handler处理器"></a>8.2.3 Netty中的Handler处理器</h4><p>Netty的Handler处理器分为两大类，第一类是ChannelInboundHandler 通道入站处理器；第二类是ChannelOutboundHandler通道出站处理器。两者都继承了ChannelHandler处理器接口。</p>
<p>其实整个IO处理操作包括：从通道读取数据包(入站)、数据包解码(入站)、业务处理、目标数据编码(出站)、把数据包写到通道并发送到对端(出站)。只是除了业务处理需要用户程序负责，别的Netty底层已经完成。</p>
<h4 id="8-2-4-Netty的流水线"><a href="#8-2-4-Netty的流水线" class="headerlink" title="8.2.4 Netty的流水线"></a>8.2.4 Netty的流水线</h4><p>先梳理一下Netty反应器模式中，各个组件之间的关系：</p>
<ol>
<li>反应器(或者SubReactor子反应器)和通道之间是一对多的关系：一个反应器可以查询多个通道的IO事件</li>
<li>通道和Handler处理器实例之间，是多对多的关系：一个通道的IO事件可以被多个Handler处理，一个Handler处理器实例也能绑定多个通道</li>
</ol>
<p><strong>通道和Handler处理器的绑定关系，Netty是如何组织的？</strong></p>
<p>Netty设计了一个特殊的组件，叫作ChannelPipeline（通道流水线），它是一个双向链表，它将绑定到一个通道的多个Handler处理器实例串在一起，形成一条流水线，这里用到了责任链设计模式。</p>
<p><strong>IO事件在流水线上的执行顺序是怎么样的？</strong></p>
<p>入站处理器Handler的执行次序，是从前到后(即和添加顺序相同)；出站处理器Handler的执行次序，是从后到前(与添加顺序相反)。</p>
<p>入站IO操作只能从Inbound入站处理器类型的Handler经过；出站IO操作只会从Outbound出站处理器类型的Handler经过</p>
<p><strong>流水线上的处理器能否在运行期间动态变化？</strong></p>
<p>可以的，Netty流水线支持处理器的热插拔。只需调用 ChannelHandlerContext 中对应方法：</p>
<p>addFirst(String name, ChannelHandler handler);//在头部添加一个业务处理器</p>
<p>addLast(String name,ChannelHandler handler);//在尾部添加一个业务处理器</p>
<p>addBefore/addAfter(String baseName, String name, ChannelHandler handler);//在baseName处理器前面/后面加一个业务处理器</p>
<p>remove(ChannelHandler channelHandler);//删除一个业务处理器实例</p>
<h4 id="8-2-5-ByteBuf缓冲区"><a href="#8-2-5-ByteBuf缓冲区" class="headerlink" title="8.2.5 ByteBuf缓冲区"></a>8.2.5 ByteBuf缓冲区</h4><p>Netty 提供了 ByteBuf 来替换Java NIO 的ByteBuffer缓冲区，以操作内存缓冲区。</p>
<p>其和ByteBuffer存在以下区别：</p>
<ul>
<li>Pooling（因为缓冲区被频繁创建释放，Netty4开始支持池化，这点减少了内存复制和 GC，提升了效率）</li>
<li>复合缓冲区类型，支持零复制</li>
<li>不需要调用flip()方法去换换读/写模式</li>
<li>扩展性好，例如StringBuffer</li>
<li>可以自定义缓冲区类型</li>
<li>读取和写入索引分开</li>
<li>方法的链式调用</li>
<li>可以进行引用计数，方便重复使用</li>
</ul>
<p><strong>ByteBuf的逻辑结构</strong></p>
<p>ByteBuf是一个字节容器，内部是一个字节数组。从逻辑上分，可以分为四个部分：</p>
<ul>
<li>废弃 - 已用字节，表示使用完的废弃的无效字节</li>
<li>可读 - 从ByteBuf中读取的数据都来自这一部分</li>
<li>可写 - 写入到ByteBuf的数据都会写到这一部分中</li>
<li>可扩容 - 表示ByteBuf最多还能扩容多少</li>
</ul>
<p>为了让读写之间没有冲突，ByteBuf内部维护了三个属性</p>
<ul>
<li>readerIndex(读指针)：当前读取的位置，每次读取自动加1，直到和写指针相等，表示读完</li>
<li>writerIndex(写指针)：没写一个字节自动加1，如果写入的时候容量不足可以扩容</li>
<li>maxCapacity(最大容量)：容量最大能扩展到的值，超过会报错</li>
</ul>
<p><strong>ByteBuf的内存分配</strong></p>
<ul>
<li><p>ByteBufAllocator.DEFAULT.buffer(9,100); 分配初始容量为9，最大容量为100的缓冲区</p>
</li>
<li><p>ByteBufAllocator.DEFAULT.buffer();分配初始容量为256，最大容量为Integer.MAX_VALUE的缓冲区</p>
</li>
<li><p>UnpooledByteBufAllocator.DEFAULT.heepBuffer();</p>
<p>非池化分配器，分配基于堆结构的堆缓冲区，特点是创建和销毁缓冲区的速度快</p>
</li>
<li><p>PooledByteBufAlloctor.DEFAULT.directBuffer();</p>
<p>池化分配器，分配基于操作系统的直接缓冲区，直接缓冲区的特点是写入传输通道比堆缓冲区快，但创建和销毁因为需要调用操作系统方法，成本高，因此尽量在池化中使用，避免频繁创建和销毁缓冲区</p>
</li>
</ul>
<p><strong>ByteBuf使用示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteReadTest</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWriteRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//分配初始容量为9，最大容量为100的一个缓冲区</span></span><br><span class="line">        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="number">9</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//写入缓冲区  如果写入其他类型数据可以调用对应writeTYPE方法</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">//读字节，不改变指针</span></span><br><span class="line">        getByteBuf(buffer);</span><br><span class="line">        <span class="comment">//取字节，改变指针</span></span><br><span class="line">        readByteBuf(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读字节</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getByteBuf</span><span class="params">(ByteBuf buffer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;buffer.readableBytes();i++)&#123;</span><br><span class="line">            Logger.info(buffer.getByte(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取字节</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readByteBuf</span><span class="params">(ByteBuf buffer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(buffer.isReadable())&#123;</span><br><span class="line">            Logger.info(buffer.readByte());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ByteBuf在Netty中的释放</strong></p>
<p>入站的释放方式：</p>
<ol>
<li><p>TailHandler自动释放</p>
<p>Netty默认会再ChannlePipline通道流水线的最后添加一个TailHandler末尾处理器，在默认情况下，处理器会将最初的ByteBuf数据包一路往下传，那么TailHandler就能释放掉缓冲区了</p>
<p>使用方法为，入站处理器继承自ChannelInboundHandlerAdapter适配器，那么可以调用以下两种方式：</p>
<ul>
<li>手动释放 - byteBuf.release();</li>
<li>将msg向后传- super.channelRead(ctx,msg);</li>
</ul>
</li>
<li><p>SimpleChannelInboundHandler自动释放</p>
<p>如果业务处理器需要截断流水线的处理流程，不将ByteBuf数据包送入后边的TailHandler，在这种场景下，Handler业务处理器有两种选择：</p>
<ul>
<li><p>手动释放ByteBuf实例</p>
</li>
<li><p>继承SimpleChannelInboundHandler，利用它的自动释放功能</p>
<p>重写channelRead0方法，源码中，执行完channelRead0方法后，如果ByteBuf的计数器为0，将彻底被释放</p>
</li>
</ul>
</li>
</ol>
<p>出站的释放方式：</p>
<p>HeadHandler自动释放，因为出站是执行器从后往前执行，所以在TailHandler相反，出站的缓冲区释放操作在HeadHandler中执行。</p>
<p><strong>ByteBuf浅层复制的高级使用方式</strong></p>
<p>浅层复制可以很大程度避免内存赋值。这一点对于大规模通信来说是非常重要的。</p>
<p>ByteBuf的浅层复制分为两种：</p>
<ul>
<li><p>切片(slice)浅层复制</p>
<p>ByteBuf的slice方法可以获取到一个ByteBuf切片。</p>
</li>
<li><p>整体(duplicate)浅层复制</p>
</li>
</ul>
<h3 id="8-3-Bootstrap-启动类"><a href="#8-3-Bootstrap-启动类" class="headerlink" title="8.3 Bootstrap 启动类"></a>8.3 Bootstrap 启动类</h3><p>Netty为了快速将通道、反应器、处理器快速组装起来，提供了启动类Bootstrap。</p>
<p>在Netty中，有两种启动类，分别用在 服务器 和 客户端</p>
<ul>
<li>Bootstrap - client专用</li>
<li>ServerBootstrap - server专用</li>
</ul>
<p>这两种启动器只是使用的地方不同，它们大致的配置和使用方法都是相同的。</p>
<h4 id="8-3-1-父子通道"><a href="#8-3-1-父子通道" class="headerlink" title="8.3.1 父子通道"></a>8.3.1 父子通道</h4><p>在Netty中，将有接收关系的NioServerSocketChannel 和 NioSocketChannel叫做父子通道。其中，父通道负责服务器监听和接收；对应于每一个接收到的子通道是传输类通道。</p>
<h4 id="8-3-2-EventLoopGroup线程组"><a href="#8-3-2-EventLoopGroup线程组" class="headerlink" title="8.3.2 EventLoopGroup线程组"></a>8.3.2 EventLoopGroup线程组</h4><p>在Netty中，一个 EventLoop 相当于一个子反应器。一个NioEvnetLoop子反应器拥有一个线程，为了组织这些反应器有了EventLoopGraoup线程组</p>
<p>构造方法可以定义线程组数量，如果没有定义，默认会使用系统内核数的两倍</p>
<h4 id="8-3-3-ServerBootstrap-的启动流程"><a href="#8-3-3-ServerBootstrap-的启动流程" class="headerlink" title="8.3.3 ServerBootstrap 的启动流程"></a>8.3.3 ServerBootstrap 的启动流程</h4><p>以下为服务器端启动器的流程：</p>
<p>正式使用前，需要先创建一个服务器端的启动器实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br></pre></td></tr></table></figure>
<ol>
<li><p>创建反应器线程池，并赋值给 ServerBootstrap 启动器实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boss线程组</span></span><br><span class="line">EventLoopGroup bossLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// worker线程组</span></span><br><span class="line">EventLoopGroup workerLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="comment">//设置 反应器线程组</span></span><br><span class="line">b.group(bossLoopGroup, workerLoopGroup);</span><br></pre></td></tr></table></figure>
<p>boss线程组负责处理连接监听IO事件，worker线程组负责IO事件和Handler业务处理，group方法也可以只有一个参数，但在父子通道模型下只是用一个线程组会导致监听受业务处理阻塞。</p>
</li>
<li><p>设置通道的IO类型</p>
<p>Netty支持OIO、NIO和不同的传输协议（这里是设置父通道类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.channel(NioServerSocketChannel.class);</span><br></pre></td></tr></table></figure></li>
<li><p>设置监听端口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.loacalAddress(<span class="keyword">new</span> InetSocketAddress(port));</span><br></pre></td></tr></table></figure></li>
<li><p>设置传输通道的配置选项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.option(ChannelOption.SO_KEEPLIVE, <span class="keyword">true</span>);</span><br><span class="line">b.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);</span><br></pre></td></tr></table></figure>
<p>这里是给父通道设置一些选项，如果要给子通道设置可以使用childOption()方法</p>
<p>下面介绍一些常见的选项</p>
<ul>
<li><p>SO_RCVBUF\SO_SNDBUF</p>
<p>这两个参数用来设置内核发送缓冲区/接收缓冲区大小。之所以划分为两个缓冲区是为了支持全双工的工作模式。</p>
</li>
<li><p>TCP_NODELAY</p>
<p>改参数表示是否要立刻发送数据（默认为True），设置为True可以最小化报文传输的时延，设置为False可以最小化发送报文的数量，减少网络交互次数</p>
</li>
<li><p>SO_KEEPALIVE</p>
<p>是否启用TCP心跳机制，默认为false，启用后默认的心跳间隔是2小时</p>
</li>
<li><p>SO_LINGER</p>
<p>表示TCP socket的关闭时延，默认为-1，表示socket.close()方法会立刻返回，但操作系统会异步将发送缓冲区的数据发送到对端。0表示方法立刻返回，并放弃发送发送缓冲区数据，对端将收到复位错误。&gt;0表示close方法将阻塞，直到延迟时间到来，如果没发送完，对端将收到复位错误</p>
</li>
<li><p>SO_BACKLOG</p>
<p>表示TCP 服务端接收连接的队列长度，如果队列已满，客户端的连接将被拒绝。默认值，windows为200，其他是128</p>
</li>
<li><p>SO_BROADCAST</p>
<p>这是TCP参数，表示设置为广播模式</p>
</li>
</ul>
</li>
<li><p>配置子通道的Pipeline流水线</p>
<p>使用childHandler方法，传递一个通道初始化方法。在父通道成功接收到一个连接，并创建一个子通道的时候会调用初始化方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannle&gt;()&#123;<span class="comment">//泛型类型是之前启动类设置的父通道类型对应的子通道类型</span></span><br><span class="line">	<span class="comment">//有连接到达时会创建一个通道的子通道，并初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ch.pipeline().addList(<span class="keyword">new</span> NettyDiscardHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>一般只需要配置子通道的初始化方法，父通道因为内部处理逻辑是固定的：接收新连接，创建子通道，然后初始化子通道，但如果需要完成特殊业务处理，可以使用.handler(ChannelInitialize init);为父通道设置初始化方法。</p>
</li>
<li><p>绑定之前设置的服务器监听端口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture channelFuture = b.bind().sync();</span><br><span class="line">Logger.info(<span class="string">&quot;服务器启动成功，监听端口：%s&quot;</span>, channelFuture.channel().localAddress());</span><br></pre></td></tr></table></figure>
<p>这是是阻塞的方式执行异步任务，在Netty中，所有的IO操作都是异步执行的，这就意味着任何一个IO操作会立刻返回，在返回的时候，异步任务还没有真正执行。</p>
<p>Netty中的IO操作，都会返回异步任务实例(如ChannelFuture实例)，通过自我阻塞一直到ChannelFuture异步任务执行完成。</p>
</li>
<li><p>自我阻塞，直到通道关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture closeFuture = channelFuture.channel().closeFuture();</span><br><span class="line">clseFuture.sync();</span><br></pre></td></tr></table></figure>
<p>如果要阻塞当前线程直到通道关闭，可以使用通道的closeFuture()方法，以获取通道关闭的异步任务。当通道被关闭时，closeFuture实例的sync()方法会返回。</p>
</li>
<li><p>关闭EventLoopGroup</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workerLoopGroup.shutdownGracefully();</span><br><span class="line">bossLoopGroup.shutdownGracefully();</span><br></pre></td></tr></table></figure>
<p>此过程，关闭反应器线程组、子反应器线程、Selector选择器、内部的轮询线程、负责查询的所有子通道、释放掉自层资源</p>
</li>
</ol>
<h2 id="9-Netty版本回显服务器"><a href="#9-Netty版本回显服务器" class="headerlink" title="9. Netty版本回显服务器"></a>9. Netty版本回显服务器</h2><p>功能：从服务器端读取客户端输入的数据，然后将数据直接回显到Console控制台</p>
<h3 id="9-1-服务器端的ServerBootstrap"><a href="#9-1-服务器端的ServerBootstrap" class="headerlink" title="9.1 服务器端的ServerBootstrap"></a>9.1 服务器端的ServerBootstrap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyEchoServer</span></span>&#123;</span><br><span class="line">	ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyEchoServer</span><span class="params">(<span class="keyword">int</span> serverPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverPort = serverPort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b.group(bossLoopGroup, workerLoopGroup);</span><br><span class="line">            b.channel(NioServerSocketChannel.class);</span><br><span class="line">            b.localAddress(<span class="keyword">this</span>.serverPort);</span><br><span class="line">            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">            b.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);</span><br><span class="line">            b.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(NettyEchoServerHandler.INSTANCE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = b.bind().sync();</span><br><span class="line">            log.info(<span class="string">&quot;服务器启动成功，监听口:&#123;&#125;&quot;</span>, channelFuture.channel().localAddress());</span><br><span class="line">            ChannelFuture closeFuture = channelFuture.channel().closeFuture();</span><br><span class="line">            closeFuture.sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerLoopGroup.shutdownGracefully();</span><br><span class="line">            bossLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NettyEchoServer(<span class="number">10001</span>).runServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-2-NettyEchoServerHandler处理器"><a href="#9-2-NettyEchoServerHandler处理器" class="headerlink" title="9.2 NettyEchoServerHandler处理器"></a>9.2 NettyEchoServerHandler处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyEchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> NettyEchoServerHandler INSTANCE = <span class="keyword">new</span> NettyEchoServerHandler();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        <span class="comment">//Netty4.1开始，ByteBuf的默认类型是直接内存缓冲区</span></span><br><span class="line">        log.info(<span class="string">&quot;缓冲区类型:&#123;&#125;&quot;</span>, in.hasArray() ? <span class="string">&quot;堆缓冲区&quot;</span> : <span class="string">&quot;直接缓冲区&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = in.readableBytes();</span><br><span class="line">        <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="comment">//使用get方式数据在msg中还保留</span></span><br><span class="line">        in.getBytes(<span class="number">0</span>, arr);</span><br><span class="line">        log.info(<span class="string">&quot;服务端接收到：&#123;&#125;&quot;</span>, <span class="keyword">new</span> String(arr, StandardCharsets.UTF_8));</span><br><span class="line">        log.info(<span class="string">&quot;写回前，引用计数：&#123;&#125;&quot;</span>, ((ByteBuf) msg).refCnt());</span><br><span class="line">        <span class="comment">//写回数据，异步任务</span></span><br><span class="line">        ChannelFuture f = ctx.writeAndFlush(msg);</span><br><span class="line">        f.addListener((ChannelFuture futureListener) -&gt; log.info(<span class="string">&quot;写回后，引用计数:&#123;&#125;&quot;</span>, ((ByteBuf) msg).refCnt()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了注解@ChannelHandler.Sharable表示这个Handler实例可以被多个通道安全地共享，也就是说多个通道的流水线可以加入同一个Handler业务处理实例。而这种操作，Netty默认是不允许的。</p>
<p>但Handler中经常只有业务操作，不涉及线程安全问题，这时候如果服务器要处理很多通道，就没必要创建这么多处理器了</p>
<h3 id="9-3-客户端Bootstrap"><a href="#9-3-客户端Bootstrap" class="headerlink" title="9.3 客户端Bootstrap"></a>9.3 客户端Bootstrap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyEchoClient</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> serverport;</span><br><span class="line">    <span class="keyword">private</span> String serverIp;</span><br><span class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyEchoClient</span><span class="params">(String ip, <span class="keyword">int</span> serverport)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverIp = ip;</span><br><span class="line">        <span class="keyword">this</span>.serverport = serverport;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventLoopGroup workerLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b.group(workerLoopGroup);</span><br><span class="line">            b.channel(NioSocketChannel.class);</span><br><span class="line">            b.remoteAddress(serverIp, serverport);</span><br><span class="line">            b.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);</span><br><span class="line">            b.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(NettyEchoClientHandler.INSTANCE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture f = b.connect();</span><br><span class="line">            f.addListener((ChannelFuture futureListener) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (futureListener.isSuccess()) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;EchoClient客户端连接成功&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;EchoClient客户端连接失败&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//阻塞，直到连接成功</span></span><br><span class="line">            f.sync();</span><br><span class="line">            Channel channel = f.channel();</span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入内容&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">                String next = scanner.next();</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = (LocalDateTime.now() + <span class="string">&quot;&gt;&gt;&quot;</span> + next).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">                ByteBuf buf = channel.alloc().buffer();</span><br><span class="line">                buf.writeBytes(bytes);</span><br><span class="line">                channel.writeAndFlush(buf);</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入内容&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-4-NettyEchoClientHandler-处理器"><a href="#9-4-NettyEchoClientHandler-处理器" class="headerlink" title="9.4 NettyEchoClientHandler 处理器"></a>9.4 NettyEchoClientHandler 处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyEchoClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> NettyEchoClientHandler INSTANCE = <span class="keyword">new</span> NettyEchoClientHandler();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) msg;</span><br><span class="line">        <span class="keyword">int</span> len = byteBuf.readableBytes();</span><br><span class="line">        <span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        byteBuf.getBytes(<span class="number">0</span>, arr);</span><br><span class="line">        log.info(<span class="string">&quot;client receive:&#123;&#125;&quot;</span>, <span class="keyword">new</span> String(arr, StandardCharsets.UTF_8));</span><br><span class="line">        byteBuf.release();</span><br><span class="line">        <span class="comment">//super.channelRead(ctx.msg);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中都是手动进行ByteBuf二进制数据的解码，和Java POJO 的编码，下面介绍如果使用 Decoder 和 Encoder组件。</p>
<h2 id="10-编码及解码"><a href="#10-编码及解码" class="headerlink" title="10. 编码及解码"></a>10. 编码及解码</h2><p>在入站处理的时候，需要将ByteBuf二进制类，解码成Java POJO对象。这个解码过程，可以通过Netty的Decoder解码器去完成。</p>
<p>在出站处理的时候，需要将业务处理结果（POJO对象）编码为ByteBuf二进制数据，然后通过Java通道发送到对端，可以通过Netty的Encoder解码器去完成。</p>
<h3 id="10-1-Decode-原理与实践"><a href="#10-1-Decode-原理与实践" class="headerlink" title="10.1 Decode 原理与实践"></a>10.1 Decode 原理与实践</h3><ol>
<li>它会处理入站数据</li>
<li>将上一站Inbound处理器传来的数据进行解码或者格式转换</li>
</ol>
<p>Netty内置了这个解码器，叫做ByteToMessageDecoder，位于 Netty 的 io.netty.handler.codec 包中</p>
<p>所有Netty中的解码器，都是Inbound入站处理器类型，都直接或间接实现了 ChannelInboundHandler 接口</p>
<p><strong>ByteToMessageDecoder解码器</strong></p>
<p>ByteToMessageDecoder是一个抽象类解码器，继承自 ChannelInboundHandlerAdapter适配器，具体的解码流程在子类中实现，如果要实现一个自己的解码器，流程如下：</p>
<ol>
<li>继承ByteToMessageDecoder抽象类</li>
<li>实现基类的 decode 方法，将 ByteBuf 二进制数据解码成 Java POJO 对象的逻辑写入此方法</li>
<li>在decode方法中，还需要将解码后的Java POPO对象放入 decode 的List<Object>实参中。</li>
<li>最后父类会将List<Object>中的结果，一个个分开传递给下一站Inbound入站处理器（不需要实现）</li>
</ol>
<h4 id="10-1-1-通过嵌入式通道测试自定义解码器"><a href="#10-1-1-通过嵌入式通道测试自定义解码器" class="headerlink" title="10.1.1 通过嵌入式通道测试自定义解码器"></a>10.1.1 通过嵌入式通道测试自定义解码器</h4><p>在 Netty 的实际开发中，大量的工作是设计和开发 入站处理器，而不是出站处理器。</p>
<p>开发完成后，需要投入单元测试，大致流程为：将Handler业务处理器加入通道的Pipeline流水线，先后启动Netty服务器、客户端，然后互发消息，测试业务处理器的结果。</p>
<p>这样是非常繁琐的，所以Netty提供了专门的嵌入式通道——EmbeddedChannel，不需要进行实际的传输</p>
<p>其主要方法</p>
<ul>
<li>writeInbound - 向通道写入入站数据</li>
<li>readInbound - 从通道中读取入站数据，是经过入站处理器处理后的入站数据</li>
<li>writeOutbound - 向通道写入出站数据</li>
<li>readOutbound - 从通道中读取出站数据，是经过出站处理器处理后的出站数据</li>
</ul>
<p>下面通过EmbededChannel自定义整数解码器：</p>
<p>首先需要定义一个解码器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Byte2IntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx,ByteBuf in,List&lt;Object&gt; out)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(in.readableBytes() &gt;= <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = in.readInt();</span><br><span class="line">            log.info(<span class="string">&quot;解码出一个整数&#123;&#125;&quot;</span>,i);</span><br><span class="line">            out.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个业务处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerProcessHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx,Object msg)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Integer integer = (Integer) msg;</span><br><span class="line">        log.info(<span class="string">&quot;打印出一个整数:&#123;&#125;&quot;</span>,integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用EmbeddedChannnel嵌入式通道测试入站</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Byte2IntegerDecoderTester</span></span>&#123;</span><br><span class="line">    ChannelInitializer i = <span class="keyword">new</span> ChannelInitializer&lt;EmbeddedChannel&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(EmbeddedChannel ch)</span></span>&#123;</span><br><span class="line">            ch.pipeline().addList(<span class="keyword">new</span> Byte2IntegerDecoder());<span class="comment">//先解码</span></span><br><span class="line">            ch.pipeline().addList(<span class="keyword">new</span> IntegerProcessHandler());<span class="comment">//后处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">100</span>;j++)&#123;</span><br><span class="line">        ByteBuf buf = Unpooled.buffer();</span><br><span class="line">        buf.writeInt(j);</span><br><span class="line">        channel.writeInbound(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-1-2-粘包和拆包"><a href="#10-1-2-粘包和拆包" class="headerlink" title="10.1.2 粘包和拆包"></a>10.1.2 粘包和拆包</h4><p>Netty发送和读取数据的场所是ByteBuf缓冲区。每一次发送就是向通道写入一个ByteBuf；每一次读取就是通过Handler业务处理器的入站方法，从通道读到一个ByteBuf。</p>
<p>最为理想的情况是：发送端每发送一个ByteBuf缓冲区，接收端就能接收到一个ByteBuf，并且发送端和接收端的ByteBuf内容一模一样。</p>
<p>我们改造之前的Netty客户端，将手动输入发送数据的方式修改为循环发送1000次数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f.sync();</span><br><span class="line">Channel channel = f.channel();</span><br><span class="line">Stirng content = <span class="string">&quot;需要循环发送的数据&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = content.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">    ByteBuf buffer = channel.alloc().buffer();</span><br><span class="line">    buffer.writeBytes(bytes);</span><br><span class="line">    channel.writeAndFlush(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看程序运行结果，发送存在三种类型的输出：</p>
<ul>
<li>读到一个完整的客户端输入 ByteBuf（全包）</li>
<li>读到多个客户端的 ByteBuf 输入，但是粘在一起（粘包）</li>
<li>读到部分 ByteBuf 内容，并且有乱码（半包）</li>
</ul>
<p>半包和粘包统称为半包现象</p>
<p><strong>半包现象出现的原理</strong></p>
<p>写入数据的大致流程为：在应用进程缓冲区，应用程序以ByteBuf为单位发送数据，复制到内核缓冲区，底层对数据包进行二次拼装，拼装成传输层TCP层的协议报文，再发送。</p>
<p>读取数据的大致流程为：当IO可读时，底层将二进制数据从网卡读取，并按照网络协议规范进行拆包后读到内核缓冲区，Netty读取ByteBuf时，二进制数据从内核缓冲区复制到进程缓冲区。</p>
<p>在Netty程序从内核缓冲区复制到Netty进程缓冲区ByteBuf时，问题来了：</p>
<ul>
<li>每次读取底层缓冲的数据容量是有限制的，当TCP底层缓冲的数据包比较大时，会将一个底层包分成多次ByteBuf进行复制，进而造成进程缓冲区读到的是半包</li>
<li>tcp为提高传输效率，发送方往往要手机到足够多的数据后才发送一包数据，这可能导致粘包</li>
<li>接收方如果应用进程不及时接收数据，内核缓冲区中后一包数据接在前一包数据后，而用户进程依然根据预先设定的缓冲区大小从内核缓冲区读取数据，这可能导致粘包</li>
</ul>
<p>而分包（拆包）就是解决半包现象的手段</p>
<h4 id="10-1-3-分包方案"><a href="#10-1-3-分包方案" class="headerlink" title="10.1.3 分包方案"></a>10.1.3 分包方案</h4><p>使用上面的解码器会面临一个问题：需要对ByteBuf的长度进行判断，这个操作可用交给Netty的RepleyingDecoder类来完成</p>
<p><strong>ReplayingDecoder</strong> 类是 ByteToMessageDecoder 的子类，其作用是：</p>
<ul>
<li>在读取ByteBuf缓冲区数据前，检查缓冲区是否有足够字节</li>
<li>若ByteBuf中有足够的字节，则会正常读取；反之，则停止解码</li>
<li>解决长数据分包，导致接收端的包和发送端发送的包不一致问题</li>
</ul>
<p>在Java OIO传输中，不会出现这样的问题，因为它的策略是：不读到完整的信息，就一直阻塞程序，不向后执行，但由于Java NIO 的非阻塞性，包在传输过程中进行多次的拆分和组装，无法保证一次性读到完整的数据。</p>
<p>除了使用RepleyingDecoder定义自己的进程缓冲区分包器 还可以使用Netty内置的解码器</p>
<p>Netty针对不同数据类型，提供了不同的解决方案，以下是Netty内置的一些解码器：</p>
<ol>
<li><p>固定长度数据包解码器——FixedLengthFrameDecoder</p>
<p>适用于，缓冲区每个接收到的数据包长度是固定的。该解码器加入到流水线后，会将入站ByteBuf缓冲区拆分成一个个固定长度的数据包，然后发往下一个入站处理器</p>
</li>
<li><p>行分割数据包解码器——LineBasedFrameDecoder</p>
<p>适用于，每个ByteBuf数据包，适用换行符作为边界分隔符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">1024</span>));<span class="comment">//参数是最大的行长度，如果超过抛异常</span></span><br></pre></td></tr></table></figure></li>
<li><p>自定义分隔符数据包解码器——DelimiterBasedFrameDecoder</p>
<p>分隔符不受限于换行符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">1024</span>,<span class="keyword">true</span>,Unpooled.copiedBuffer(<span class="string">&quot;\t&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>))));<span class="comment">//第二个参数表示解码后数据包是否去掉分隔符</span></span><br></pre></td></tr></table></figure></li>
<li><p>自定义长度数据包解码器——LengthFieldBasedFrameDecoder</p>
<p>在ByteBuf数据包中，加了一个长度字段，保存了原始数据包的长度。解码的时候，会按照这个长度进行原始包的提取。</p>
<p>普通的基于Header-Content协议的内容传输，尽量使用LengthFieldBasedFrameDecoder解码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyOpenBoxDecoder</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLengthFieldBasedFrameDecoder1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">/**参数按顺序分别是</span></span><br><span class="line"><span class="comment">                发送的数据包最大长度</span></span><br><span class="line"><span class="comment">                长度字段偏移量：长度字段位于数据包的字节数组的下表位置</span></span><br><span class="line"><span class="comment">                长度字段自己占用的字节数：长度字段占用的字节数</span></span><br><span class="line"><span class="comment">                长度字段的偏移量矫正：在传输协议比较复杂的情况下，例如包含了长度字段、协议版本号、魔数等等，那么，解码就需要进行长度矫正：矫正值的计算公式为：内容字段偏移量-长度字段偏移量-长度字段的字节数</span></span><br><span class="line"><span class="comment">                丢弃的起始字节数：一些起辅助作用的字段，最终结果不需要，比如前面的长度字段</span></span><br><span class="line"><span class="comment">                **/</span></span><br><span class="line">            <span class="keyword">final</span> LengthFieldBasedFrameDecoder spliter = <span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">            ChannelInitializer i = <span class="keyword">new</span> ChannelInitializer&lt;EmbeddedChannel&gt;()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(EmbeddedChannel ch)</span> </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(spliter);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> StringHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;= <span class="number">100</span>;j++)&#123;</span><br><span class="line">                ByteBuf buf = Unpooled.buffer();</span><br><span class="line">                String s = j+<span class="string">&quot;次发送&quot;</span>;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = s.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                buf.writeInt(bytes.length);</span><br><span class="line">                buf.writeBytes(bytes);</span><br><span class="line">                channel.writeInbound(buf);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(UnsupportedEncodingException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-Encoder-原理与实践"><a href="#10-2-Encoder-原理与实践" class="headerlink" title="10.2 Encoder 原理与实践"></a>10.2 Encoder 原理与实践</h3></li>
</ol>
<p>编码器首先是一个出站处理器，负责处理出站数据；同时也会处理上一站出站处理器处理结果，将java Pojo对象转为二进制字节流</p>
<p><strong>MessageToByteEncoder编码器</strong></p>
<p>与解码器相反，继承该父类后需要实现encode方法，使用out.writeInt(msg);将javaPOJO类型写入到ByteBuf二进制流中</p>
<h3 id="10-3-编码器与解码器的结合"><a href="#10-3-编码器与解码器的结合" class="headerlink" title="10.3 编码器与解码器的结合"></a>10.3 编码器与解码器的结合</h3><p>在实际开发中，由于数据的入站和出站关系密切，既要定义编码器，又要定义解码器，需要两次加入通道的流水线。Netty提供了具有相互配套逻辑的编码器和解码器——Codec类型</p>
<p><strong>ByteToMessageCodec编解码器</strong></p>
<p>提供了两个抽象方法：encode,decode需要同时实现，也只需要加入一次流水线</p>
<p><strong>CombinedChannelDuplexHandler组合器</strong></p>
<p>为了既能单独使用编码器、解码器，又能结合使用，netty提供解码器来栓绑编码器、解码器，同时和ByteToMessageCodec比，他们又能单独使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerDuplexHandler</span> <span class="keyword">extends</span> <span class="title">CombinedChannelDuplexHandler</span>&lt;<span class="title">Byte2IntegerDecoder</span>,<span class="title">Integer2ByteEncoder</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntegerDuplexHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> Byte2IntegerDecoder(),<span class="keyword">new</span> Integer2ByteEncoder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-JSON和ProtoBuf序列化"><a href="#11-JSON和ProtoBuf序列化" class="headerlink" title="11. JSON和ProtoBuf序列化"></a>11. JSON和ProtoBuf序列化</h2><h3 id="11-1-JSON传输"><a href="#11-1-JSON传输" class="headerlink" title="11.1 JSON传输"></a>11.1 JSON传输</h3><p>目前java主流的json开源框架：阿里的FastJson、谷歌的Gson、开源社区的Jackson。</p>
<p><strong>Jackson</strong></p>
<p>优点：依赖的jar包少、简单、性能不错、社区活跃</p>
<p>缺点：对于复杂POJO类型、负责集合Map、List转换的结果不是标准的JSON格式，甚至会出现一些问题</p>
<p><strong>Gson</strong></p>
<p>优点：开源完成复杂类型的POJO和JSON字符串的相互转换，转换能力强</p>
<p>缺点：性能会差一些</p>
<p><strong>FastJson</strong></p>
<p>优点：高性能</p>
<p>缺点：在复杂类型的POJO转化JSON时，可能会出现一些引用类型而导致出错</p>
<blockquote>
<p>目前主流的策略是POJO序列化为JSON时使用Gson，在JSON字符串反序列化成POJO时，使用FastJson</p>
</blockquote>
<p>JSON通用工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.google.gson.GsonBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtil</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> GsonBuilder gb = <span class="keyword">new</span> GsonBuilder();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        gb.disableHtmlEscaping();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">pojoToJson</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        String json = gb.create().toJson(obj);</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;<span class="function">T <span class="title">jsonToPojo</span><span class="params">(String json,Class&lt;T&gt; tClass)</span></span>&#123;</span><br><span class="line">        T t = JSONObject.parseObject(json, tClass);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>JSON编码器与解码器</strong></p>
<p>以常用的 Head-Content 协议来介绍一下JSON传输</p>
<p>解码的流程如下：</p>
<ol>
<li>先使用LengthFieldBasedFrameDecoder(Netty内置自定义长度数据包解码器)解码出二进制数据的内容部分</li>
<li>使用StringDecoder字符串解码器(Netty内置的解码器)将二进制内容解码成JSON字符串</li>
<li>使用JsonMsgDecoder解码器(自定义解码器)，将Json字符串解码成POJO对象</li>
</ol>
<p>编码流程如下：</p>
<ol>
<li>先使用StringEncoder编码器(内置)将JSON字符串编码成二进制字节数组</li>
<li>使用LengthFieldPrepender编码器(内置)将二进制字节数组编码成Head-Content二进制数据包</li>
</ol>
<p>LengthFieldPrepender编码器能在数据包的前面加上内容的二进制字节数组的长度，和LengthFieldBasedFrameDecoder常常配套使用</p>
<p>以下为使用json协议进行数据传输的netty demo：</p>
<p>服务端代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b.group(bossLoopGroup, workerLoopGroup);</span><br><span class="line">            b.localAddress(<span class="number">10011</span>);</span><br><span class="line">            b.channel(NioServerSocketChannel.class);</span><br><span class="line">            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">            b.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);</span><br><span class="line">            b.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> JsonMsgDecoder());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture f = b.bind().sync();</span><br><span class="line">            f.addListener((ChannelFuture futureListener) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (futureListener.isSuccess()) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;服务成功启动,监听的端口为&#123;&#125;&quot;</span>,futureListener.channel().localAddress());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;服务启动失败&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerLoopGroup.shutdownGracefully();</span><br><span class="line">            bossLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonMsgDecoder</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            String json = (String) msg;</span><br><span class="line">            JsonMsg jsonMsg = JsonMsg.toMsg(json);</span><br><span class="line">            log.info(<span class="string">&quot;收到的POJO：&#123;&#125;&quot;</span>, jsonMsg);</span><br><span class="line">            <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonSendClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventLoopGroup workerLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b.group(workerLoopGroup);</span><br><span class="line">            b.channel(NioSocketChannel.class);</span><br><span class="line">            b.remoteAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10011</span>);</span><br><span class="line">            b.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);</span><br><span class="line">            b.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LengthFieldPrepender(<span class="number">4</span>));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = b.connect();</span><br><span class="line">            channelFuture.addListener((ChannelFuture futureListener) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (futureListener.isSuccess()) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;EchoClient客户端连接成功&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;EchoClient客户端连接失败&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            JsonMsg jsonMsg = JsonMsg.builder()</span><br><span class="line">                    .id(<span class="number">123</span>)</span><br><span class="line">                    .content(<span class="string">&quot;发送的内容&quot;</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            channel.writeAndFlush(jsonMsg.convertToJson());</span><br><span class="line">            log.info(<span class="string">&quot;发送json数据:&#123;&#125;&quot;</span>, jsonMsg);</span><br><span class="line">            ChannelFuture channelFuture1 = channel.closeFuture();</span><br><span class="line">            channelFuture1.sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-2-Protobuf协议通信"><a href="#11-2-Protobuf协议通信" class="headerlink" title="11.2 Protobuf协议通信"></a>11.2 Protobuf协议通信</h3><h4 id="11-2-1-原生Protobuf"><a href="#11-2-1-原生Protobuf" class="headerlink" title="11.2.1 原生Protobuf"></a>11.2.1 原生Protobuf</h4><p>Protobuf既独立于语言、又独立于平台。Protobuf序列化后是二进制格式，相对于文本格式的数据(json、xml)来说，要快的多。由于Protobuf性能优异，常用于分布式应用场景或异构场景的数据交换</p>
<p>Protobuf的编码过程为：使用预先定义的Message数据结构将实际的传输数据进行打包，然后编码成二进制的码流进行传输</p>
<p>Protobuf的解码过程为：将二进制码流解码成Protobuf自己定义的Message结构的POJO实例</p>
<p><strong>.proto文件</strong></p>
<p>Protobuf使用proto文件来预先定义消息格式，解码和编码都是根据文件进行的</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> rmblc.cashInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.chainter.rmblc.invest.bean.proto&quot;</span>;<span class="comment">//生成文件所在包路径</span></span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;CashInfo&quot;</span>;<span class="comment">//生成文件名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所有的消息会作为一个内部类，被打包到一个外部类中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//头寸参数</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SubCashInfoParam</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> portfolioCode = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回数据格式</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">RespData</span> </span>&#123;</span><br><span class="line">    RespCashInfoData data = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头寸数据</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">RespCashInfoData</span> </span>&#123;</span><br><span class="line">    PtPortfolioCash cash = <span class="number">1</span>;<span class="comment">//头寸信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">PtPortfolioCash</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个message相当于生成java中的一个类，一个字段相当于java中的一个类成员，数字表示该字段在序列化和反序列化的时候该字段的具体排序</p>
<p><strong>设计的protobuf文件的时候有什么原则？</strong></p>
<ol>
<li><p>可以定义一个enum枚举类型，包含系统用到的所有消息类型</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HeadType</span></span>&#123;</span><br><span class="line">	LOGIN_REQUEST = <span class="number">0</span>;	<span class="comment">//登录请求</span></span><br><span class="line">	LOGIN_RESPONSE = <span class="number">1</span>; <span class="comment">//登录响应</span></span><br><span class="line">	LOGOUT_REQUEST = <span class="number">2</span>; <span class="comment">//登出请求</span></span><br><span class="line">	MESSAGE_REQUEST = <span class="number">3</span>;<span class="comment">//聊天消息请求</span></span><br><span class="line">	MESSAGE_RESPONSE = <span class="number">4</span>;<span class="comment">//聊天消息响应</span></span><br><span class="line">	MESSAGE_NOTIFICATION = <span class="number">5</span>;<span class="comment">//服务器通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用message定义定义一个具体的消息</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">LoginRequest</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> uid = <span class="number">1</span>;       <span class="comment">//用户唯一ID</span></span><br><span class="line">	<span class="built_in">string</span> deviceId = <span class="number">2</span>;  <span class="comment">//设备ID</span></span><br><span class="line">	<span class="built_in">string</span> token = <span class="number">3</span>;     <span class="comment">//用户token</span></span><br><span class="line">	<span class="built_in">uint32</span> platform = <span class="number">4</span>;  <span class="comment">//客户端平台 windows、mac、ios</span></span><br><span class="line">	<span class="built_in">string</span> appVersion = <span class="number">5</span>;<span class="comment">//应用版本号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>给应答消息加上成功标记和应答序号</p>
<p>成功标记是bool类型，用来标记是否成功；应答序号作用于一个请求有多个响应，最后一个响应消息包含一个结束标记，接收端在处理的时候，根据应答序号和结束标记，可以合并所有的响应消息</p>
</li>
<li><p>编解码从顶层消息开始</p>
<p>定义一个外层的消息，把所有的消息类型封装在一起，在通信的时候，可以从外层消息开始编码或者解码。</p>
</li>
</ol>
<p><strong>如何生成POJO和Builder对象？</strong></p>
<ol>
<li><p>通过控制台命令方式</p>
<p>需要从<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/releases">https://github.com/protocolbuffers/protobuf/releases</a>下载Protobuf的安装包，解压后配置系统环境变量的path变量，添加Protobuf的安装目录，然后运行以下命令生成：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc.exe --java_out=./src/main/java/ ./Msg.proto</span><br></pre></td></tr></table></figure>
<p>表示要生成的原proto文件为：Msg.proto，生成到的路径为./src/main/java</p>
</li>
<li><p>Maven插件protobuf-maven-plugin生成</p>
<p>在maven的pom中添加次plugin的配置项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--proto文件目录--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">protoSourceRoot</span>&gt;</span>$&#123;project.basedir&#125;/protobuf<span class="tag">&lt;/<span class="name">protoSourceRoot</span>&gt;</span></span><br><span class="line">    	  <span class="comment">&lt;!--目标路径--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.sourceDirectory&#125;<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--设置是否在生成Java文件之前清空outputDirectory的文件--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">clearOutputDirectory</span>&gt;</span>false<span class="tag">&lt;/<span class="name">clearOutputDirectory</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--临时目录--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">temporaryProtoFileDirectory</span>&gt;</span></span><br><span class="line">         		$&#123;project.build.directory&#125;/protoc-temp</span><br><span class="line">          <span class="tag">&lt;/<span class="name">temporaryProtoFileDirectory</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--protoc 可执行文件路径--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">protocExecutable</span>&gt;</span></span><br><span class="line">          		$&#123;project.basedir&#125;/protobuf/protoc3.6.1.exe</span><br><span class="line">          <span class="tag">&lt;/<span class="name">protocExecutable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>如何使用生成的Pojo和Builder</strong></p>
<ol>
<li><p>在maven的pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;protobuf.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的版本和.proto文件中配置的版本，以及编译器protoc.exe的版本必须是配套的</p>
</li>
<li><p>使用Builder构造消息对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtobufDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MsgProtos.<span class="function">Msg <span class="title">buildMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MsgProtos.Msg.Builder personBuilder = MsgProtos.Msg.newBuilder();</span><br><span class="line">        personBuilder.setId(<span class="number">1000</span>);</span><br><span class="line">        persionBuilder.setContent(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">        MsgProtos.Msg message = personBuilder.build();</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>序列化&amp;反序列化方式一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serAndDesr1</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    MsgProtos.Msg message = buildMsg();</span><br><span class="line">    <span class="comment">//将Protobuf对象序列化成二进制字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] data = message.toByteArray();</span><br><span class="line">    <span class="comment">//可以用于网络传输，保存到内存或外存</span></span><br><span class="line">    ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    outputStream.write(data);</span><br><span class="line">    data = outputStream.toByteArray();</span><br><span class="line">    <span class="comment">//二进制字节数组反序列化成Protobuf对象</span></span><br><span class="line">    MsgProtos.Msg inMsg = MsgProtos.Msg.parseFrom(data);</span><br><span class="line">    log.info(<span class="string">&quot;id=&gt;&#123;&#125;&quot;</span>,inMsg.getId());</span><br><span class="line">    log.info(<span class="string">&quot;content=&gt;&#123;&#125;&quot;</span>,inMsg.getContent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>序列化&amp;反序列化方式二</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serAndDesr2</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    MsgProtos.Msg message = buildMsg();</span><br><span class="line">    <span class="comment">//序列化为二进制字节数组</span></span><br><span class="line">    ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    message.writeTo(outputStream);</span><br><span class="line">    <span class="comment">//二进制字节数组 反序列化 为protobuf对象</span></span><br><span class="line">    ByteArrayInputStream inputStream = <span class="keyword">new</span> ByteArrayInputStream(outputStream.toByteArray());</span><br><span class="line">    MsgProtos.Msg inMsg = MsgProtos.Msg.parseFrom(inputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在NIO场景下存在粘包/半包问题</p>
</li>
<li><p>序列化&amp;反序列化方式三</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serAndDesr3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    MsgProtos.Msg message = buildMsg();</span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    message.writeDelimitedTo(outputStream);</span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    ByteArrayInputStream inputStream = <span class="keyword">new</span> ByteArrayInputStream(outputStream.toByteArray());</span><br><span class="line">    MsgProtos.Msg inMsg = MsgProtos.Msg.parseDelimitedFrom(inputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在序列化前添加了字节数组的长度，类似于Head-Content协议，只不过长度的类型不是固定长度的Int类型，而是可变长varint32类型</p>
</li>
</ol>
<h4 id="11-2-2-Netty内置的PrtotoBuf用法"><a href="#11-2-2-Netty内置的PrtotoBuf用法" class="headerlink" title="11.2.2 Netty内置的PrtotoBuf用法"></a>11.2.2 Netty内置的PrtotoBuf用法</h4><p>Netty内置的Protobuf专用的基础编码器/解码器为：ProtobufEncoder编码器和ProtobufDecoder解码器</p>
<p><strong>ProtobufEncoder编码器</strong></p>
<p>直接使用了message.toByteArray()将POJO消息转为二进制字节，数据放入Bytebuf数据包中，然后交给了下一站的编码器</p>
<p><strong>ProtobufDecoder解码器</strong></p>
<p>需要指定一个POJO消息的prototype原型POJO，根据原型实例找到对应的Parser解析器，将二进制的字节解析为Protobuf POJO消息对象</p>
<blockquote>
<p>但仅仅使用以上这对编码器解码器会存在粘包/半包问题。Netty也提供了配套的Head-Content类型的Protobuf编码器和解码器，在二进制码流之前加上二进制字节数组的长度：</p>
</blockquote>
<p><strong>ProtobufVarint32LengthFieldPrepender长度编码器</strong></p>
<p>在ProtobufEncoder生成的字节数组之前，前置一个varint32数字，表示序列化的二进制字节数</p>
<p><strong>ProtobufVarint32FrameDecoder长度解码器</strong></p>
<p>根据数据包中varint32中的长度值，解码一个足额的字节数组。然后建个字节数组交给下一站的解码器ProtobufDecoder</p>
<blockquote>
<p>什么是varint32，为什么不用int这种固定类型的长度？</p>
<p>varint32是一种紧凑的表示数字的方法，它不是一种具体的数据类型。它根据值的大小自动进行长度的收缩，所以能更好地减少通信过程中的传输量</p>
</blockquote>
<p>使用方式如下：</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ProtobufVarint32FrameDecoder());<span class="comment">//根据长度从入站数据包解码出二进制Protobuf字节码</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ProtobufDecoder(MsgProtos.Msg.getDefaultInstance()));<span class="comment">//将字节码解码成Protobuf POJO对象</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ProtobufBussinessDecoder());<span class="comment">//处理Protobuf POJO对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtobufBusinessDecoder</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx,Object msg)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        MsgProtos.Msg protoMsg = (MsgProtos.Msg) msg;</span><br><span class="line">        Logger.info(<span class="string">&quot;收到一个数据包&quot;</span>+protoMsg.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ProtobufVarint32LengthFieldPrepender());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ProtobufEncoder());</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">ChannelFuture f = b.connect();</span><br><span class="line">f.sync();</span><br><span class="line">Channel channel = f.channel();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">    MsgProtos.Msg user = build(i,i+<span class="string">&quot;-&gt;&quot;</span>+content);</span><br><span class="line">    channel.writeAndFlush(user);</span><br><span class="line">&#125;</span><br><span class="line">channel.flush();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> MsgProtos.<span class="function">Msg <span class="title">build</span><span class="params">(<span class="keyword">int</span> id,String content)</span></span>&#123;</span><br><span class="line">    MsgProtos.Msg.Builder builder = MsgProtos.Msg.newBuilder();</span><br><span class="line">    builder.setId(id);</span><br><span class="line">    builder.setContent(content);</span><br><span class="line">    ruturn builder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂的传输应用场景下(Head部分加上魔数字段 即对口令进行安全验证，或者需要对Data内容进行加密、解密等)，需要定制属于自己的Protobuf编码器和解码器，自定义ProtoBuf编解码器，解决半包问题，包括以下两个方面：</p>
<ol>
<li>继承netty提供的MessageToByteEncoder编码器，完成Head-Content协议的复杂数据包的编码，将Protobuf POJO编码成Head-Content协议的二进制ByteBuf数据包</li>
<li>继承netty提供的ByteToMessageDecoder解码器，完成Head-Content协议的复杂数据包的解码，将二进制ByteBuf数据包最终解码出Protobuf POJO实例</li>
</ol>
<h2 id="12-基于Netty的单体IM系统的开发"><a href="#12-基于Netty的单体IM系统的开发" class="headerlink" title="12. 基于Netty的单体IM系统的开发"></a>12. 基于Netty的单体IM系统的开发</h2><p>完成一个聊天系统的设计和实现</p>
<h3 id="12-1-自定义-ProtoBuf-编解码器"><a href="#12-1-自定义-ProtoBuf-编解码器" class="headerlink" title="12.1 自定义 ProtoBuf 编解码器"></a>12.1 自定义 ProtoBuf 编解码器</h3><p>编码时，需要记录POJO的字节码长、魔数、版本号、内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtobufEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">ProtoMsg</span>.<span class="title">Message</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Overrider</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx,ProtoMsg.Message msg,ByteBuf out)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = msg.toByteArray();</span><br><span class="line">        <span class="keyword">int</span> length = bytes.length;</span><br><span class="line">        <span class="comment">//  写入消息长度,这里用Short，只用两个字节，最大为32767，如果更长可以用writeInt</span></span><br><span class="line">        out.writeShort(length);</span><br><span class="line">        <span class="comment">//  ...省略魔数、版本号等的写入</span></span><br><span class="line">        <span class="comment">//  写入内容</span></span><br><span class="line">        out.writesBytes(msg.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解码时，按照记录的顺序读取对应长度的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtobufDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span> <span class="params">(ChannelHandlerContext ctx,ByteBuf in,List&lt;Object&gt; out)</span></span>&#123;</span><br><span class="line">        <span class="comment">//  标记当前读指针的位置</span></span><br><span class="line">        in.markReaderIndex();</span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = in.readShort();</span><br><span class="line">        <span class="keyword">if</span>(length &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//非法数据，关闭连接</span></span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(length &gt; in.readableBytes())&#123;</span><br><span class="line">            <span class="comment">//读到的消息体长度如果小于传送过来的消息长度，重置读取位置重读</span></span><br><span class="line">            in.resetReaderIndex();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...省略读取魔数、版本号等其他数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] array;</span><br><span class="line">        <span class="keyword">if</span>(in.hasArray())&#123;</span><br><span class="line">            <span class="comment">//堆缓冲区</span></span><br><span class="line">            ByteBuf slice = in.slice();</span><br><span class="line">            array = slice.array();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//直接缓冲区</span></span><br><span class="line">            array = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">            in.readBytes(array,<span class="number">0</span>,length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//字节转出Protobuf的POJO对象</span></span><br><span class="line">        ProtoMsg.message outmsg = ProtoMsg.Message.parseFrom(array);</span><br><span class="line">        <span class="keyword">if</span>(outmsg != <span class="keyword">null</span>)&#123;</span><br><span class="line">            out.add(outmsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-2-定义消息格式"><a href="#12-2-定义消息格式" class="headerlink" title="12.2 定义消息格式"></a>12.2 定义消息格式</h3><p>一般来说，不管是二进制格式、XML、JSON等字符串格式，答题都可以分为3大消息类型：</p>
<ol>
<li>请求消息</li>
<li>应答消息</li>
<li>命令消息</li>
</ol>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*外层消息*/</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">	HeadType type = <span class="number">1</span>;	  <span class="comment">//消息类型</span></span><br><span class="line">	<span class="built_in">uint64</span> sequence = <span class="number">2</span>;  <span class="comment">//序列号，主要用于请求和响应数据包的配套，使得发送端可以进行请求-响应匹配</span></span><br><span class="line">	<span class="built_in">string</span> sessionId = <span class="number">3</span>; <span class="comment">//会话ID</span></span><br><span class="line">	LoginRequestloginRequest = <span class="number">4</span>;             <span class="comment">//登录请求</span></span><br><span class="line">	LoginResponseloginRequest = <span class="number">5</span>;			  <span class="comment">//登录响应</span></span><br><span class="line">	MessageRequestmessageRequest = <span class="number">6</span>;		  <span class="comment">//聊天请求</span></span><br><span class="line">	MessageResponsemessageResponse = <span class="number">7</span>;		  <span class="comment">//聊天响应</span></span><br><span class="line">	MessageNotification notification = <span class="number">8</span>;	  <span class="comment">//通知消息 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看一份完整的聊天器的.proto协议文件的定义</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> com.zxy.im.common.bean.msg;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ProtoMsg</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">HeadType</span></span>&#123;</span><br><span class="line">		LOGIN_REQUEST = <span class="number">0</span>;				<span class="comment">//登录请求</span></span><br><span class="line">		LOGIN_RESPONSE = <span class="number">1</span>;				<span class="comment">//登录响应</span></span><br><span class="line">		LOGOUT_REQUEST = <span class="number">2</span>;				<span class="comment">//登出请求</span></span><br><span class="line">		LOGOUT_RESPONSE = <span class="number">3</span>;			<span class="comment">//登出响应</span></span><br><span class="line">		KEEPALIVE_REQUEST = <span class="number">4</span>;			<span class="comment">//心跳请求</span></span><br><span class="line">		KEEPALIVE_RESPONSE = <span class="number">5</span>;			<span class="comment">//心跳响应</span></span><br><span class="line">		MESSAGE_REQUEST = <span class="number">6</span>;			<span class="comment">//聊天消息请求</span></span><br><span class="line">		MESSAGE_RESPONSE = <span class="number">7</span>;			<span class="comment">//聊天消息响应</span></span><br><span class="line">		MESSAGE_NOTIFICATION = <span class="number">8</span>;		<span class="comment">//服务器通知</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*登录请求消息*/</span></span><br><span class="line">	<span class="class"><span class="keyword">message</span> <span class="title">LoginRequest</span></span>&#123;</span><br><span class="line">		<span class="built_in">string</span> uid = <span class="number">1</span>;					<span class="comment">//用户唯一ID</span></span><br><span class="line">		<span class="built_in">string</span> deviceId = <span class="number">2</span>;			<span class="comment">//设备ID</span></span><br><span class="line">		<span class="built_in">string</span> token = <span class="number">3</span>;				<span class="comment">//用户token</span></span><br><span class="line">		<span class="built_in">uint32</span> platform = <span class="number">4</span>;			<span class="comment">//客户端平台windows、mac、ios、web</span></span><br><span class="line">		<span class="built_in">string</span> appVersion = <span class="number">5</span>;			<span class="comment">//APP版本号</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*登录响应消息*/</span></span><br><span class="line">	<span class="class"><span class="keyword">message</span> <span class="title">LoginResponse</span></span>&#123;</span><br><span class="line">		<span class="built_in">bool</span> result = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">uint32</span> code = <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">string</span> info = <span class="number">3</span>;</span><br><span class="line">		<span class="built_in">uint32</span> expose = <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*聊天消息请求*/</span></span><br><span class="line">	<span class="class"><span class="keyword">message</span> <span class="title">MessageRequest</span></span>&#123;</span><br><span class="line">		<span class="built_in">uint64</span> msgId = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">string</span> from = <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">string</span> to = <span class="number">3</span>;</span><br><span class="line">		<span class="built_in">uint64</span> time = <span class="number">4</span>;</span><br><span class="line">		<span class="built_in">uint32</span> msgType = <span class="number">5</span>;</span><br><span class="line">		<span class="built_in">string</span> content = <span class="number">6</span>;</span><br><span class="line">		<span class="built_in">string</span> url = <span class="number">8</span>;</span><br><span class="line">		<span class="built_in">string</span> property = <span class="number">8</span>;</span><br><span class="line">		<span class="built_in">string</span> fromNick = <span class="number">10</span>;</span><br><span class="line">		<span class="built_in">string</span> json = <span class="number">11</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*聊天响应*/</span></span><br><span class="line">	<span class="class"><span class="keyword">message</span> <span class="title">MessageResponse</span></span>&#123;</span><br><span class="line">		<span class="built_in">bool</span> result = <span class="number">1</span>;			<span class="comment">//true 表示发送成功，false 表示发送失败</span></span><br><span class="line">		<span class="built_in">uint32</span> code = <span class="number">2</span>;			<span class="comment">//错误码</span></span><br><span class="line">		<span class="built_in">string</span> info = <span class="number">3</span>;			<span class="comment">//错误描述</span></span><br><span class="line">		<span class="built_in">uint32</span> expose = <span class="number">4</span>;			<span class="comment">//错误描述是否提示给用户:1 提示;0 不提示</span></span><br><span class="line">		<span class="built_in">bool</span> lastBolck = <span class="number">5</span>;			<span class="comment">//是否为最后的应答</span></span><br><span class="line">		<span class="built_in">fixed32</span> blockIndex = <span class="number">6</span>;		<span class="comment">//应答的序号</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*服务器通知*/</span></span><br><span class="line">	<span class="class"><span class="keyword">message</span> <span class="title">MessageNotification</span></span>&#123;</span><br><span class="line">		<span class="built_in">uint32</span> msgType = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">bytes</span> sender = <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">string</span> json = <span class="number">3</span>;</span><br><span class="line">		<span class="built_in">string</span> timestamp = <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*外层消息*/</span></span><br><span class="line">	<span class="class"><span class="keyword">message</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">		HeadType type = <span class="number">1</span>;						<span class="comment">//消息类型</span></span><br><span class="line">		<span class="built_in">uint64</span> sequence = <span class="number">2</span>;					<span class="comment">//序列号</span></span><br><span class="line">		<span class="built_in">string</span> sessionId = <span class="number">3</span>;					<span class="comment">//会话ID</span></span><br><span class="line">		LoginRequestloginRequest = <span class="number">4</span>;			<span class="comment">//登录请求</span></span><br><span class="line">		LoginResponseloginResponse = <span class="number">5</span>;			<span class="comment">//登录响应</span></span><br><span class="line">		MessageRequestmessageRequest = <span class="number">6</span>;		<span class="comment">//聊天请求</span></span><br><span class="line">		MessageResponsemessageResponse = <span class="number">7</span>;		<span class="comment">//聊天响应</span></span><br><span class="line">		MessageNotification notification = <span class="number">8</span>;	<span class="comment">//通知消息</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-3-登录流程"><a href="#12-3-登录流程" class="headerlink" title="12.3 登录流程"></a>12.3 登录流程</h3><p>基本流程</p>
<ol>
<li>客户端发送登录数据包</li>
<li>服务端进行用户身份验证</li>
<li>服务器创建Session会话</li>
<li>服务器端返回登录结果给客户端，包括成功标志、SessionId等</li>
</ol>
<p>登录/响应通信流程</p>
<ol>
<li>客户端收集用户 id 和密码，这一步需要使用到 LoginConsoleCommand 控制台命令类</li>
<li>客户端发送 Protobuf 数据包到客户端通道，这一步需要通过 LoginSender 发送器组装 Protobuf 数据包</li>
<li>客户端通道将数据包发送到对端，这一步通过 Netty 底层来完成</li>
<li>服务器子通道收到数据包，这一步通过 Netty 底层来完成</li>
<li>服务器 UserLoginHandler 入站处理器收到登录消息，交给业务处理器 LoginMsgProcesser 处理异步的业务逻辑</li>
<li>服务端 LoginMsgProcesser 处理完异步的业务逻辑，就将处理结果写入用户绑定的子通道</li>
<li>服务器子通道将登录响应的 protobuf 数据帧写入到对端，这一步通过Netty底层完成</li>
<li>客户端通道收到 protobuf 登录响应数据包，这一步需要 Netty 底层来完成</li>
<li>客户端 LoginResponseHandler 业务处理器处理登录响应，例如设置登录的状态，保存会话的Session ID等等</li>
</ol>
<p><strong>客户端具体实现</strong></p>
<p>首先客户端通过 ClientCommandMenu菜单展示类展示出一个命令菜单，供用户选择</p>
<ul>
<li>登录</li>
<li>聊天</li>
<li>退出</li>
<li>查看全部命令</li>
</ul>
<p>每一个菜单选项对应到一个信息的收集类，登录对应的是LoginConsoleCommand，进行用户id和密码收集</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/20/Netty/" data-id="ckk50chbh000iegmz17k99roh" data-title="Netty" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">框架及中间件</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/01/20/SpringCloud%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          SpringCloud、分布式解决方案
        
      </div>
    </a>
  
  
    <a href="/2021/01/20/es/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">es</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80/" rel="tag">java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">框架及中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 16.67px;">java基础</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 10px;">大数据</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 13.33px;">服务器</a> <a href="/tags/%E6%A1%86%E6%9E%B6%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 20px;">框架及中间件</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/20/Arthas/">Arthas</a>
          </li>
        
          <li>
            <a href="/2021/01/20/COLA/">COLA</a>
          </li>
        
          <li>
            <a href="/2021/01/20/HazelCast%E3%80%81Ignite/">HazelCast、Ignite</a>
          </li>
        
          <li>
            <a href="/2021/01/20/Shiro%E3%80%81Spring%20Security/">Shiro、Spring Security</a>
          </li>
        
          <li>
            <a href="/2021/01/20/cucumber/">cucumber</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
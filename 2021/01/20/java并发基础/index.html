<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>java并发基础 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、多线程1. 多线程编程存在的问题1.1 上下文切换问题​        CPU通过给每个线程分配CPU时间片，来实现并发执行，在切换前，保存上一个任务的状态，切换时，加载分配到时间片的任务的状态，此过程就是一次上下文切换。 ​        上下文切换 和 线程创建 可能导致多线程执行比串行执行慢。 如何减少上下文切换？  无锁并发编程。比如根据数据的ID通过HASH取模，不同的线程处理不同段">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发基础">
<meta property="og:url" content="http://example.com/2021/01/20/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、多线程1. 多线程编程存在的问题1.1 上下文切换问题​        CPU通过给每个线程分配CPU时间片，来实现并发执行，在切换前，保存上一个任务的状态，切换时，加载分配到时间片的任务的状态，此过程就是一次上下文切换。 ​        上下文切换 和 线程创建 可能导致多线程执行比串行执行慢。 如何减少上下文切换？  无锁并发编程。比如根据数据的ID通过HASH取模，不同的线程处理不同段">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-01-19T16:00:00.000Z">
<meta property="article:modified_time" content="2021-01-20T06:03:39.501Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java基础">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-java并发基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/20/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T16:00:00.000Z" itemprop="datePublished">2021-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      java并发基础
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、多线程"><a href="#一、多线程" class="headerlink" title="一、多线程"></a>一、多线程</h1><h2 id="1-多线程编程存在的问题"><a href="#1-多线程编程存在的问题" class="headerlink" title="1. 多线程编程存在的问题"></a>1. 多线程编程存在的问题</h2><h3 id="1-1-上下文切换问题"><a href="#1-1-上下文切换问题" class="headerlink" title="1.1 上下文切换问题"></a>1.1 上下文切换问题</h3><p>​        CPU通过给每个线程分配CPU时间片，来实现并发执行，在切换前，保存上一个任务的状态，切换时，加载分配到时间片的任务的状态，此过程就是一次<code>上下文切换</code>。</p>
<p>​        上下文切换 和 线程创建 可能导致多线程执行比串行执行慢。</p>
<p><strong>如何减少上下文切换？</strong></p>
<ol>
<li>无锁并发编程。比如根据数据的ID通过HASH取模，不同的线程处理不同段的数据。</li>
<li>CAS算法。JAVA的Atomic包使用CAS算法来更新数据，不需要加锁。</li>
<li>使用最少线程。避免创建不需要的线程。</li>
<li>协程。在协程里实现多任务的调度，并在协程里维持多个任务间的切换。(因为任务调度执行速度很快，创建过多线程会导致上下文切换带来的性能损耗)</li>
<li>Fork/Join框架。空闲线程会从别的线程的工作列表另一端帮忙执行任务</li>
</ol>
<blockquote>
<p>协程，又称微线程或纤程，是一个比进程和线程更加轻量级的解决方案</p>
<p>进程和线程由操作系统内核负责切换，而协程属于用户空间(进程隔离)，由用户自己去调用，所以执行速度会比进程、线程快</p>
</blockquote>
<h3 id="1-2-死锁"><a href="#1-2-死锁" class="headerlink" title="1.2 死锁"></a>1.2 死锁</h3><p><strong>产生的原因是什么？</strong></p>
<ol>
<li>请求与保持</li>
<li>互斥</li>
<li>循环等待</li>
<li>不可抢占</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<ol>
<li>避免一个线程同时获取多个锁</li>
<li>避免一个线程内同时占有多个资源</li>
<li>尝试使用定时锁</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接内</li>
</ol>
<h3 id="1-3-资源限制"><a href="#1-3-资源限制" class="headerlink" title="1.3 资源限制"></a>1.3 资源限制</h3><p><strong>硬件的限制</strong></p>
<ol>
<li>带宽的上传/下载速度</li>
<li>硬盘读写速度</li>
<li>CPU处理速度</li>
</ol>
<p><em>硬件的限制可以通过建立集群处理</em></p>
<p><strong>软件的限制</strong></p>
<ol>
<li>数据库连接数</li>
<li>socket连接数</li>
</ol>
<p><em>软件的限制可以通过建立连接池来复用连接，socket连接复用来处理</em></p>
<h1 id="二、Java中的锁"><a href="#二、Java中的锁" class="headerlink" title="二、Java中的锁"></a>二、Java中的锁</h1><h2 id="1-volatile"><a href="#1-volatile" class="headerlink" title="1. volatile"></a>1. volatile</h2><p>volatile是轻量级的synchronized,它在多处理器开发中保证了共享变量的“可见性”。</p>
<h3 id="1-1-CPU术语定义"><a href="#1-1-CPU术语定义" class="headerlink" title="1.1 CPU术语定义"></a>1.1 CPU术语定义</h3><table>
<thead>
<tr>
<th>术语</th>
<th>英文单词</th>
<th>术语描述</th>
</tr>
</thead>
<tbody><tr>
<td>内存屏障</td>
<td>memory barriers</td>
<td>是一组处理器指令，用于实现对内存操作的顺序限制</td>
</tr>
<tr>
<td>缓冲行</td>
<td>cache line</td>
<td>CPU高速缓存中可以分配的最小存储单位，处理器填写缓存行时会加载整个缓存行，现代CPU需要执行几百次CPU指令</td>
</tr>
<tr>
<td>原子操作</td>
<td>atomic operations</td>
<td>不可中断的一个或一系列操作</td>
</tr>
<tr>
<td>缓存行填充</td>
<td>cache line fill</td>
<td>当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个高速缓存行到适当的缓存(L1,L2,L3的或所有)</td>
</tr>
<tr>
<td>缓存命中</td>
<td>cache hit</td>
<td>如果进行高速缓存填充操作仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取</td>
</tr>
<tr>
<td>写命中</td>
<td>write hit</td>
<td>当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回内存，这个操作被称为写命中</td>
</tr>
<tr>
<td>写缺失</td>
<td>write misses the cache</td>
<td>一个有效的缓存行被写入到不存在的内存区域</td>
</tr>
</tbody></table>
<h3 id="1-2-volatile实现原则"><a href="#1-2-volatile实现原则" class="headerlink" title="1.2 volatile实现原则"></a>1.2 volatile实现原则</h3><p>有volatile变量修饰的共享变量进行写操作的时候会多出Lock前缀的汇编代码，Lock前缀的指令在多核处理器下会引发两件事情：</p>
<ol>
<li>将当前处理器缓存行的数据写回到系统内存</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ol>
<p>​        为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1,L2或其他)后再进行操作，但操作完不知道何时会写到内存。</p>
<p>​        在多处理器下，为保证各个处理器缓存的值是一致的，就会实现缓存一致性协议，每个处理器通过<strong>嗅探</strong>在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己的缓存值过期时，会将缓存行设置为无效状态，当处理器对这个数据进行修改操作时，会重新从系统内存中把数据读到处理器缓存里。</p>
<p>​       所以volatile的实现原则：</p>
<ol>
<li>Lock前缀指令会引起处理器缓存回写到内存</li>
<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效</li>
<li>volatile会防止指令重排(JVM为了提高的执行效率，会对两个没有依赖关系的语句进行重排，volatile能防止重排带来的一些问题)</li>
</ol>
<h3 id="1-3-双重检查锁的错误用法"><a href="#1-3-双重检查锁的错误用法" class="headerlink" title="1.3 双重检查锁的错误用法"></a>1.3 双重检查锁的错误用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLocking</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(DoubleCheckedLocking.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Instance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题在于new Instance()的时候，该代码可以分解为以下3行伪代码：</p>
<ul>
<li>memory = allocate();     //分配对象的内存空间</li>
<li>ctorInstance(memory); //初始化对象</li>
<li>instance = memory;      //设置变量指向刚分配的内存地址</li>
</ul>
<p>上面的2,3步在某些JIT编译器上，可能会被重排序，这样线程A在执行完指针设置后，还没有初始化对象前，另一个线程B访问到的会是一个没有被初始化的对象。</p>
<p>为了避免这个问题，可以将instance使用violatile修饰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Instance instance;</span><br></pre></td></tr></table></figure>
<h2 id="2-synchronized"><a href="#2-synchronized" class="headerlink" title="2. synchronized"></a>2. synchronized</h2><p>在多线程并发编程中synchronized一直是元老级角色，很多人都会称呼它为重量级锁。但是，随着Java SE 1.6对synchronized进行了各种优化之后，有些情况下它就并不那么重了。</p>
<h3 id="2-1-实现同步的基础"><a href="#2-1-实现同步的基础" class="headerlink" title="2.1 实现同步的基础"></a>2.1 实现同步的基础</h3><p>Java中的每一个对象都可以作为锁，所以synchronized也被称为内置锁。具体表现为以下3种形式</p>
<ol>
<li>对于普通同步方法，锁是当前实例对象</li>
<li>对于静态同步方法，锁是当前类的Class对象</li>
<li>对于同步方法块，锁是括号里配置的对象</li>
</ol>
<p>需要注意的是，</p>
<p><strong>锁到底存在哪里？锁里面存储什么信息？</strong></p>
<p>synchronized用的锁是存在Java<em>对象头</em>里的。如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果对象是非数组类型，则用2字宽存储对象头。</p>
<p>对象头包括3部分信息</p>
<ul>
<li>Mark Word：存储对象的hashCode、分代年龄或锁信息等</li>
<li>Class Metadata Address：存储到对象类型数据的指针</li>
<li>Array length：数据的长度(如果对象是数组)</li>
</ul>
<p>64位虚拟机下，Mark Word是64bit大小，其存储结构如表：</p>
<table class="tg">
  <tr>
    <th class="tg-0pky">占用字节</th>
    <th class="tg-0pky">25bit</th>
    <th class="tg-0pky">31bit</th>
    <th class="tg-0pky">1bit</th>
    <th class="tg-0pky">4bit</th>
    <th class="tg-0lax">1bit</th>
    <th class="tg-0lax">2bit</th>
  </tr>
  <tr>
    <td class="tg-0pky">内容</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky">cms_free</td>
    <td class="tg-0pky">分代年龄</td>
    <td class="tg-0lax">偏向锁</td>
    <td class="tg-0lax">锁标志位</td>
  </tr>
  <tr>
    <td class="tg-0pky">无锁</td>
    <td class="tg-0pky">unused</td>
    <td class="tg-0pky">hashCode</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
    <td class="tg-0lax">0</td>
    <td class="tg-0lax">01</td>
  </tr>
  <tr>
    <td class="tg-0pky">偏向锁</td>
    <td class="tg-0pky" colspan="2">ThreadID(54bit)Epoch(2bit)</td>
    <td class="tg-0pky"></td>
    <td class="tg-0pky"></td>
    <td class="tg-0lax">1</td>
    <td class="tg-0lax">01</td>
  </tr>
</table>

<h3 id="2-2-锁的升级和对比"><a href="#2-2-锁的升级和对比" class="headerlink" title="2.2 锁的升级和对比"></a>2.2 锁的升级和对比</h3><p>Java SE 1.6为了减少获取锁和释放锁带来的性能损耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种形态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级，但不会降级。</p>
<h4 id="2-2-1-偏向锁"><a href="#2-2-1-偏向锁" class="headerlink" title="2.2.1 偏向锁"></a>2.2.1 偏向锁</h4><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步代码块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程进入和退出同步代码块时，不需要进行CAS操作来加锁和解锁，只需要简单测试一下对象头的MarkWword里是否存储着指向当前线程的偏向锁。如果没有，则校验Mark Word中偏向锁的表示是否设置成1(表示当前是偏向锁)。如果不是偏向锁，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<p><strong>那么占有偏向锁的线程什么时候撤销对锁的占用？</strong></p>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁（等待一个全局安全点：在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设为无锁状态，并撤销偏向锁；</p>
<p>如果线程处于活动状态，升级为轻量级锁的状态。</p>
<p><strong>如何配置项目的偏向锁</strong></p>
<p>偏向锁在Java6和Java7中是默认开启的，并在项目启动后3秒开启，这个通过以下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay&#x3D;0</span><br></pre></td></tr></table></figure>
<p>如果确认项目通常情况下处于竞争状态，可用通过JVM参数关闭偏向锁，程序会直接进入轻量级锁状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseBiasedLocking&#x3D;false</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-轻量级锁"><a href="#2-2-2-轻量级锁" class="headerlink" title="2.2.2 轻量级锁"></a>2.2.2 轻量级锁</h4><p>线程在执行同步代码块之前，JVM会先在当前线程的栈中创建用于存储<em>锁记录</em>的空间，并将对象头中的Mark Word赋值到锁记录中，这种行为称为<strong>Displaced Mark Word</strong>。然后线程尝试使用CAS将对象头中的Mark Word替换为指向<em>锁记录</em>的指针。如果成功，当前线程获取锁，如果失败，表示其他线程竞争锁，当前线程尝试使用自旋来获取锁。</p>
<p><strong>轻量级锁如何解锁？</strong></p>
<p>轻量级锁解锁时，会使用CAS操作将Displaced Mark Word替换回对象头，如果成功，表示没有竞争发生。如果失败，表示当前锁存在竞争，抢占锁的所有线程会阻塞，等待锁膨胀为<strong>重量级锁</strong>，然后占有锁的线程再释放锁并唤醒所有抢占锁的线程。</p>
<p><strong>为什么要升级为重量级锁？</strong></p>
<p>因为轻量级锁的自旋消耗CPU，为了避免无用的自旋(比如获取锁的线程被阻塞住了)，一旦锁升级为重量级锁，就不会再恢复为轻量级锁状态。当锁处于重量级锁状态时，其他线程视图获取锁时，就会被阻塞住，直到占有锁的线程释放锁唤醒这些阻塞线程。</p>
<h4 id="2-2-3-锁的对比"><a href="#2-2-3-锁的对比" class="headerlink" title="2.2.3 锁的对比"></a>2.2.3 锁的对比</h4><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外消耗，和执行非同步方法相比仅存在纳秒级别的差距</td>
<td>如果线程间存在锁竞争，就会带来额外的锁撤销消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td>
<td>追求响应时间的同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不适用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量，同步块执行时间较长</td>
</tr>
</tbody></table>
<h2 id="3-原子操作"><a href="#3-原子操作" class="headerlink" title="3. 原子操作"></a>3. 原子操作</h2><table>
<thead>
<tr>
<th>术语名称</th>
<th>英文</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>缓存行</td>
<td>Cache line</td>
<td>缓存的最小操作单位</td>
</tr>
<tr>
<td>比较并交换</td>
<td>Compare and Swap</td>
<td>CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换</td>
</tr>
<tr>
<td>CPU流水线</td>
<td>CPU pipeline</td>
<td>CPU流水线的工作方式就像工业生产上的装配流水线，在CPU中由5<del>6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5</del>6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运算速度</td>
</tr>
<tr>
<td>内存顺序冲突</td>
<td>Memory order violation</td>
<td>内存顺序冲突一般是由假共享引起的，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线</td>
</tr>
</tbody></table>
<h3 id="3-1-如何实现原子操作"><a href="#3-1-如何实现原子操作" class="headerlink" title="3.1 如何实现原子操作"></a>3.1 如何实现原子操作</h3><p><strong>处理器如何实现原子操作？</strong></p>
<ol>
<li><p>使用<em>总线锁</em>保证原子性</p>
<p>如果多个处理器同时对共享变量进行<strong>读改写</strong>操作(i++就是经典的读改写操作)，那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的。处理器如果使用总线锁来解决这个问题，在进行操作前提供一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存</p>
</li>
<li><p>使用<em>缓存锁</em>保证原子性</p>
<p>在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁来进行优化。</p>
<p>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁。“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性。</p>
<p><em>缓存一致性机制</em>会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p>
<p><strong>但是有两种情况下不会使用缓存锁定</strong></p>
<ol>
<li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。</li>
<li>有些处理器不支持缓存锁定。</li>
</ol>
</li>
</ol>
<h3 id="3-2-Java如何实现原子操作"><a href="#3-2-Java如何实现原子操作" class="headerlink" title="3.2 Java如何实现原子操作"></a>3.2 Java如何实现原子操作</h3><p>在Java中通过<strong>锁</strong>和<strong>循环CAS</strong>的方式来实现原子操作</p>
<ol>
<li><p>使用循环CAS实现原子操作</p>
<p>JDK5开始，JDK并发包里提供了一些类来支持原子操作(Atomic*)，自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止，但CAS虽然很高效率地解决了原子操作，但是CAS仍存在以下问题</p>
<ul>
<li>ABA问题。如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，ABA问题的解决思路就是使用版本号，那么A-&gt;B-&gt;A就会变成1A-&gt;2B-&gt;3A，从JDK5开始，Atomic包里提供了一个类AtomicStampedReference来解决ABA问题，这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li>
<li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的开销。如果JVM能支持处理器提供pause指令，那么效率会有一定提升。其作用：1.它可以延迟流水线执行命令，使CPU不会消耗过多的执行资源。2. 它可以避免在退出循环的时候因内存顺序冲突而引起CPU流水线被清空。</li>
<li>只能保证一个共享变量的原子操作。Java1.5开始,JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里进行CAS操作</li>
</ul>
</li>
<li><p>使用锁机制实现原子操作</p>
<p>JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。</p>
</li>
</ol>
<h2 id="4-Lock"><a href="#4-Lock" class="headerlink" title="4. Lock"></a>4. Lock</h2><h2 id="5-ReentrantLock（可重入锁）"><a href="#5-ReentrantLock（可重入锁）" class="headerlink" title="5. ReentrantLock（可重入锁）"></a>5. ReentrantLock（可重入锁）</h2><p>JDK1.5之后支持的<code>显式锁</code>，相比于之前的内置锁<code>synchronized</code>，显式锁使用起来更灵活</p>
<ul>
<li>可定时:<code>RenentrantLock.tryLock(long timeout, TimeUnit unit)</code></li>
<li>可中断:<code>RenentrantLock.lockInterruptibly()</code></li>
<li>条件队列：内置锁只有一个条件队列，而显式锁可以通过<code>RenentrantLock.newCondition()</code>获取多个条件队列，然后通过<code>Condition.signal()</code>来唤醒对应的条件队列，lock只有在所有条件队列都被唤醒的时候才能获取资源</li>
</ul>
<p>BlockingQueue就是基于显式锁的条件谓语实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">// 显式锁对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();<span class="comment">// take()方法的条件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();<span class="comment">// put()方法的条件队列</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)<span class="comment">// 条件谓词“缓存非空”</span></span><br><span class="line">            notEmpty.await();<span class="comment">// 挂起等待，直到缓存非空</span></span><br><span class="line">        E x = (E)items[takeIndex];<span class="comment">// 取出元素</span></span><br><span class="line">        items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">        takeIndex = inc(takeIndex);</span><br><span class="line">        --count;</span><br><span class="line">        notFull.signal();<span class="comment">// 唤醒生产者线程</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-ReentrantReadWriteLock（读写锁）"><a href="#6-ReentrantReadWriteLock（读写锁）" class="headerlink" title="6. ReentrantReadWriteLock（读写锁）"></a>6. ReentrantReadWriteLock（读写锁）</h2><p>和ReentrantLock的区别就是区分了读锁(共享锁)和写锁(排他锁)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">handleRead</span><span class="params">(Lock lock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟读操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;读操作:&quot;</span> + value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(Lock lock, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟写操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;写操作:&quot;</span> + value);</span><br><span class="line">            value = index;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TestReadThread testReadThread = <span class="keyword">new</span> TestReadThread();</span><br><span class="line">        TestWriteThread testWriteThread = <span class="keyword">new</span> TestWriteThread();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(testReadThread).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">18</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(testWriteThread).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Test.handleRead(lock);</span></span><br><span class="line">                Test.handleRead(readLock);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWriteThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Test.handleWrite(lock,new Random().nextInt(100));</span></span><br><span class="line">                Test.handleWrite(writeLock,<span class="keyword">new</span> Random().nextInt(<span class="number">100</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="三、-Java内存模型"><a href="#三、-Java内存模型" class="headerlink" title="三、 Java内存模型"></a>三、 Java内存模型</h1><h2 id="1-并发编程模型的两个关键问题"><a href="#1-并发编程模型的两个关键问题" class="headerlink" title="1. 并发编程模型的两个关键问题"></a>1. 并发编程模型的两个关键问题</h2><p>线程之间如何通信、同步</p>
<p>   <code>共享内存</code>线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。</p>
<p>   <code>消息传递</code>线程之间通过发送消息来显式进行通信。</p>
<h2 id="2-Java内存模型的抽象结构"><a href="#2-Java内存模型的抽象结构" class="headerlink" title="2. Java内存模型的抽象结构"></a>2. Java内存模型的抽象结构</h2><p>在Java中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。而局部变量、方法定义参数和异常处理器参数不会再线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>Java线程之间的通信由Java内存模型(JMM)控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p>
<p>如果线程A和线程B之间要通信的话，必须要经历下面2个步骤。</p>
<ol>
<li>线程A把本地内存A中更新过的共享变量刷新到主内存中去</li>
<li>线程B到主内存中去读取线程A之前已更新过的共享变量</li>
</ol>
<h2 id="3-指令重排"><a href="#3-指令重排" class="headerlink" title="3. 指令重排"></a>3. 指令重排</h2><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序，重排序分3种类型</p>
<ul>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
<p>在Java源代码到实际执行的指令序列，会经历3种重排序：源代码，编译器优化重排序，指令级并行重排序，内存系统重排序，最终执行的指令序列。</p>
<ul>
<li>以上编译器优化重排序属于<em>编译器重排序</em>，JMM的编译器重排序规则会禁止特定类型的编译器重排序。</li>
<li>指令级并行重排序、内存系统重排序属于<em>处理器重排序</em>，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的<strong>内存屏障</strong>指令，通过内存屏障指令来禁止特定类型的处理器重排序</li>
</ul>
<h2 id="4-写缓冲区"><a href="#4-写缓冲区" class="headerlink" title="4. 写缓冲区"></a>4. 写缓冲区</h2><p>现代处理器使用写缓冲区临时保存向内存写入的数据。写缓冲区可以保证指令流水线的持续运行，避免处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。</p>
<p><strong>写缓冲区有什么问题？</strong></p>
<p>每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会使处理器对内存操作的执行顺序不一定与实际发生的读/写操作顺序一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对<strong>写-读</strong>操作进行重排序，而不允许对存在<strong>数据依赖</strong>的操作做重排序。</p>
<h1 id="四、Java并发编程基础"><a href="#四、Java并发编程基础" class="headerlink" title="四、Java并发编程基础"></a>四、Java并发编程基础</h1><p>JDK自带工具jstack <pid>帮助我们查看JAVA线程信息</p>
<p>jps查看所有java进程</p>
<h2 id="1-线程"><a href="#1-线程" class="headerlink" title="1. 线程"></a>1. 线程</h2><p>在一个进程里可以创建多个线程，这些线程拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时进行。</p>
<p>即使只执行一个简单的main方法，也会存在多个线程：</p>
<ul>
<li>Single Dispatcher     //分发处理发送给 JVM 信号的线程</li>
<li>Finalizer                     //调用对象 finalize 方法的线程</li>
<li>Reference Handler   //清除 Reference 的线程</li>
<li>main                            // main 线程，用户程序入口</li>
</ul>
<h3 id="1-1-线程优先级"><a href="#1-1-线程优先级" class="headerlink" title="1.1 线程优先级"></a>1.1 线程优先级</h3><p>在Java线程中，通过一个整形成员变量priority(setPriority(5)设置)来控制优先级，优先级的范围从1~10。默认优先级是5，设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低优先级，确保处理器不会被独占（但许多操作系统忽略线程优先级）。</p>
<h3 id="1-2-线程的状态"><a href="#1-2-线程的状态" class="headerlink" title="1.2 线程的状态"></a>1.2 线程的状态</h3><p>在给定的一个时刻，线程只能处于以下的一种状态   </p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>初始状态，线程被创建，但是还没有调用start方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态，进入该状态表示当前线程需要等待其他线程的一些特定动作</td>
</tr>
<tr>
<td>TIME_TAITING</td>
<td>超时等待状态，它和WAITING的区别是，它可以在指定的时间自动返回</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody></table>
<h3 id="1-3-Daemon线程"><a href="#1-3-Daemon线程" class="headerlink" title="1.3 Daemon线程"></a>1.3 Daemon线程</h3><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持型工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以使用Thread.setDaemon(true)将线程设置为Daemon线程。(Daemon属性需要在线程启动之前设置，不能再启动线程之后设置)</p>
<h3 id="1-4-线程中断"><a href="#1-4-线程中断" class="headerlink" title="1.4 线程中断"></a>1.4 线程中断</h3><p>通过wait可以通过另一个线程调用notify来唤醒，那么如何在另一个线程中 中断 当前线程呢</p>
<p>Thread.interrupt()方法：设置线程的中断标志(但线程仍会继续运行，如果要中断需要在逻辑中通过isInterrupted判断中断状态并逻辑中断)</p>
<p>Thread.interrupted()方法：返回一个boolen(true:**当前线程(而不是调用该方法的对象线程)**设置了中断标志，false:其他)，并清除对象线程的中断标志。</p>
<p>Thread.isInterrupted()方法：测试此线程是否被中断，不清除中断状态。</p>
<h2 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h2><h3 id="2-1-java中线程池的实现原理"><a href="#2-1-java中线程池的实现原理" class="headerlink" title="2.1 java中线程池的实现原理"></a>2.1 java中线程池的实现原理</h3><p>当提交一个新任务到线程池时：</p>
<ol>
<li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下一个流程工作</li>
<li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在工作队列里(工作队列是只针对核心线程池的保存任务的阻塞队列，在核心线程完成任务后会反复从阻塞队列中获取任务来执行)。如果队列满了，则进入下一个流程</li>
<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务</li>
</ol>
<p>需要注意的是不管是第一步在核心线程池中创建线程还是在普通线程池中创建线程都需要获取全局锁，为了避免获取全局锁，几乎所有执行任务的方法都是在步骤2中执行的</p>
<h2 id="3-ThreadLocal"><a href="#3-ThreadLocal" class="headerlink" title="3. ThreadLocal"></a>3. ThreadLocal</h2><p>ThreadLocal为每个线程创建独立的对象实体，避免线程安全问题，每个线程的对象并不维护在ThreadLocal对象中，而是维护在每个线程自身的成员变量中，对应的类型是Map&lt;ThreadLocal,value&gt;，key是ThreadLocal对象，value是线程独有对象。</p>
<p>每次从ThreadLocal中取对象实际是从Thread的map中，根据调用对象ThreadLocal找到对应值。</p>
<p>map的key和ThreadLocal对象之间存在弱应用关系，这也就意味着，如果ThreadLocal对象被回收，那么Thread对象的成员map里永远有一个key为null的元素，这个元素直到Thread对象被释放前将一直占用内存资源，导致内存泄露的问题。</p>
<p>在使用结束时，最好调用ThreadLocal.remove来释放其value的引用，避免在ThreadLocal被回收时value无法被访问却又占用着内存</p>
<h1 id="五、Java中的阻塞队列"><a href="#五、Java中的阻塞队列" class="headerlink" title="五、Java中的阻塞队列"></a>五、Java中的阻塞队列</h1><p>JDK7提供了7个阻塞队列</p>
<ul>
<li>ArrayBlockingQueue - 一个由<strong>数组</strong>结构组成的<strong>有界</strong>阻塞队列</li>
<li>LinkedBlockingQueue - 一个由<strong>链表</strong>结构组成的<strong>有界</strong>阻塞队列</li>
<li>PriorityBlockingQueue - 一个支持<strong>优先级</strong>排序的<strong>无界</strong>阻塞队列</li>
<li>DelayQueue - 一个支持<strong>延时</strong>的<strong>无界</strong>阻塞队列</li>
<li>SynchronousQueue - 一个不存储元素的阻塞队列</li>
<li>LinkedTransferQueue - 一个由<strong>链表</strong>结构组成的<strong>无界</strong>阻塞队列</li>
<li>LinkedBlockingDeque - 一个由<strong>链表</strong>结构组成的<strong>双向</strong>阻塞队列</li>
</ul>
<p>阻塞队列提供四种 队列为空/满 的处理方式</p>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove(e)</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<h2 id="1-ArrayBlockingQueue"><a href="#1-ArrayBlockingQueue" class="headerlink" title="1. ArrayBlockingQueue"></a>1. ArrayBlockingQueue</h2><p>ArrayBlockingQueue 是一个由数组结构组成的有界阻塞队列，默认情况下不保证线程公平的访问队列，但可以配置。</p>
<blockquote>
<p>公平的访问队列 指阻塞的线程可以按照阻塞的先后顺序访问</p>
<p>非公平的访问队列 指当队列可用时，阻塞的线程都可以争夺访问队列的资格</p>
<p>为了保证公平性，通常会降低吞吐量</p>
</blockquote>
<p><strong>使用方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1000</span>,<span class="keyword">true</span>);<span class="comment">//true表示公平</span></span><br></pre></td></tr></table></figure>
<h2 id="2-LinkedBlockingQueue"><a href="#2-LinkedBlockingQueue" class="headerlink" title="2. LinkedBlockingQueue"></a>2. LinkedBlockingQueue</h2><p>LinkedBlockingQueue 是一个用链表实现的有界阻塞队列，此队列的默认和最大长度为Integer.MAX_VALUE</p>
<h2 id="3-PriorityBlockingQueue"><a href="#3-PriorityBlockingQueue" class="headerlink" title="3. PriorityBlockingQueue"></a>3. PriorityBlockingQueue</h2><p>PriorityBlockingQueue 是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现 compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序</p>
<h2 id="4-DelayQueue"><a href="#4-DelayQueue" class="headerlink" title="4. DelayQueue"></a>4. DelayQueue</h2><p>DelayQueue 是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列使用PriorityQueue 来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。</p>
<p>DelayQueue可以应用于以下场景</p>
<ul>
<li>缓存系统设计：可以用 DelayQueue 保存缓存元素的有效期,使用一个线程循环查询DelayQueue全量数据，拿到的数据就是缓存过期的数据</li>
<li>定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，如果能从DelayQueue中获取任务就开始执行，Timer就是使用DelayQueue实现的</li>
</ul>
<p>Timer/TimerTask用法示例：</p>
<ol>
<li>定义一个TimerTask任务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSendTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> exeNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MailSendTimerTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exeNum &lt; <span class="number">12</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(MailUtil.sendMail(name))&#123;</span><br><span class="line">                    <span class="keyword">this</span>.cancel();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                exeNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            MailUtil.logError(name);</span><br><span class="line">            <span class="keyword">this</span>.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个Timer调度器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        TimerTask task1 = <span class="keyword">new</span> MailSendTimerTask(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.schedule(task1,<span class="number">1000</span>);<span class="comment">//将在1秒后调用task1</span></span><br><span class="line">        timer.scheduleAtFixedRate(task1,<span class="number">0</span>, <span class="number">1000</span>);<span class="comment">//每隔1秒执行一次task1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DelayQueue示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Noarg</span>...</span><br><span class="line"><span class="meta">@Allarg</span>...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">Delayed</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PERIOD = <span class="number">1000</span> * <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer retryTimes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastSendTime;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//getDelay必须小于等于0才能从队列里面获取到</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> delay = lastSendTime + PERIOD - System.currentTimeMillis();</span><br><span class="line"><span class="comment">//        System.out.println(TimeUnit.SECONDS.convert(delay,TimeUnit.MILLISECONDS));</span></span><br><span class="line">        <span class="keyword">return</span> unit.convert(delay,TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//比较方法用于产生一个延时队列优先级，取出来的是延迟时间最短的，然后等待一个延迟时间再取出来</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Email))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Email that = (Email)o;</span><br><span class="line">        <span class="keyword">long</span> diff = <span class="keyword">this</span>.lastSendTime - that.lastSendTime;</span><br><span class="line">        <span class="keyword">if</span>(diff == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-SynchronousQueue"><a href="#5-SynchronousQueue" class="headerlink" title="5. SynchronousQueue"></a>5. SynchronousQueue</h2><p>是一个不存储元素的阻塞队列。每一个put操作需要等待一个take操作，否则不能添加元素</p>
<p>SynchronousQueue支持公平和非公平的访问方式。</p>
<p>队列本身不存储任何元素，非常适合传递性场景。SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlcokingQueue</p>
<h2 id="6-LinkedTransferQueue"><a href="#6-LinkedTransferQueue" class="headerlink" title="6. LinkedTransferQueue"></a>6. LinkedTransferQueue</h2><p>LinkedTransferQueue 是一个由链表结构组成的无界阻塞TransferQueue队列。</p>
<p>相对于其他阻塞队列，LinkedTransferQueue多了transfer 和 tryTransfer 方法，transfer方法生产者必须等到消费者消费了才返回，tryTransfer方法无论消费者是否接收，方法立刻放回</p>
<h2 id="7-LinkedBlockingDeque"><a href="#7-LinkedBlockingDeque" class="headerlink" title="7. LinkedBlockingDeque"></a>7. LinkedBlockingDeque</h2><p>由链表结构组成的双向阻塞队列</p>
<h2 id="8-Disruptor-不是java阻塞队列"><a href="#8-Disruptor-不是java阻塞队列" class="headerlink" title="8. Disruptor(不是java阻塞队列)"></a>8. Disruptor(不是java阻塞队列)</h2><p>实现基于没有尾指针的RingBuffer，Disruptor不属于jdk包，需要导入maven</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lmax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>disruptor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>和BlockingQueue的区别</strong></p>
<ul>
<li>同一个 事件 可以有多个消费者，消费者之间既可以并行处理，也可以根据依赖关系形成处理的先后次序</li>
<li>预分配用于存储事件内容的内存空间，cpu无需时不时去主存加载数组中的下一个元素(因为ringBuffer基于数组是数组，另外只要一个元素被加载到缓存行，相邻的几个元素也会被加载进同一个缓存行)</li>
<li>针对极高的性能目标而实现的极度优化和无锁的设计</li>
</ul>
<p><strong>handleEventsWith 和 handleEventsWithWorkerPool 指定消费者</strong></p>
<p>disruptor.handleEventsWith(EventHandler …handlers)</p>
<p>disruptor.handleEventsWithWorkerPool(WorkHandler …handlers)</p>
<p>两者都是将多个消费者封装到一起，供框架消费消息</p>
<p>不同于：</p>
<p>handleEventsWith 对于一条消息，每个消费者都进行消费，而 handleEventsWithWorkerPool 对一条消息只有一个消费者消费</p>
<p><strong>场景</strong></p>
<p>可以有单个或多个生产者及消费者(广播 或 工作队列)，消费者之间可以存在消费的依赖关系。</p>
<p>代码：<a target="_blank" rel="noopener" href="https://github.com/gglaochen/jdk9Learning">https://github.com/gglaochen/jdk9Learning</a></p>
<h1 id="六、Fork-Join框架"><a href="#六、Fork-Join框架" class="headerlink" title="六、Fork/Join框架"></a>六、Fork/Join框架</h1><p>Fork/Join 框架是JDK7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架,每个小任务并不在线程池的工作队列中，而是在线程本地的工作队列。JDK8的stream流就是基于ForkJoinPool实现的，使用的是一个公用ForkJoinPool</p>
<p><strong>不适合的场景</strong><br>线程阻塞的时候，普通线程池会调度线程池队列中的其他线程执行，这是ExecutorService的机制；但是ForkJoinPool中的工作线程机制是顺序执行本地工作队列中的任务</p>
<h2 id="1-工作窃取算法"><a href="#1-工作窃取算法" class="headerlink" title="1. 工作窃取算法"></a>1. 工作窃取算法</h2><p>工作窃取算法是指某个线程从其他队列里窃取任务来执行。</p>
<p>假如我们需要做一个比较大的任务，可以把这个任务分割为互 不干扰的子任务，为了减少线程间的竞争，把这些任务分别放在不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。</p>
<p>先执行完队列中任务的线程会帮助其他线程完成其队列中的任务，为了避免两个线程对同一个队列的竞争，通常会采用双端队列，被窃取任务的线程从队列头取任务，窃取任务的线程从队列尾取任务。</p>
<h2 id="2-框架使用"><a href="#2-框架使用" class="headerlink" title="2. 框架使用"></a>2. 框架使用</h2><p>Fork/Join框架主要用到了两个类</p>
<ul>
<li>ForkJoinTask - 首先要创建一个Fork/Join任务。它提供在任务中执行fork()和join()操作的机制。通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类<ul>
<li>RecursiveAction - 用于没有返回结果的任务</li>
<li>RecursiveTask - 用于有返回结果的任务</li>
</ul>
</li>
<li>ForkJoinPool - ForkJoinTask 需要通过 ForkJoinPool 来执行</li>
</ul>
<p><strong>假如我们要计算 1+2+3+4 的计算结果</strong></p>
<p>我们设定阀值为2，这样子任务就会计算 1+2 和 3+4 然后再join计算结果，由于需要有返回值，所以使用RecursiveTask</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fj;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>;　　<span class="comment">// 阈值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CountTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>.start = start;</span><br><span class="line">             <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    	<span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">boolean</span> canCompute = (end - start) &lt;= THRESHOLD;</span><br><span class="line">               <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">                     <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;                                                      sum += i;</span><br><span class="line">                     &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">                     <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">                     CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);</span><br><span class="line">                     CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, end);</span><br><span class="line">                     <span class="comment">// 执行子任务（又会进入compute方法）</span></span><br><span class="line">                     leftTask.fork();</span><br><span class="line">                     rightTask.fork();</span><br><span class="line">                     <span class="comment">// 等待子任务执行完，并得到其结果</span></span><br><span class="line">                     <span class="keyword">int</span> leftResult=leftTask.join();</span><br><span class="line">                     <span class="keyword">int</span> rightResult=rightTask.join();</span><br><span class="line">                     <span class="comment">// 合并子任务</span></span><br><span class="line">                     sum = leftResult  + rightResult;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">              ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();<span class="comment">//new ForkJoinPool();</span></span><br><span class="line">              <span class="comment">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">              CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">              <span class="comment">// 执行一个任务</span></span><br><span class="line">              Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">              <span class="comment">//如果执行任务异常则打印异常</span></span><br><span class="line">              <span class="keyword">if</span> (task.isCompletedAbnormally())&#123;</span><br><span class="line">                  System.out.println(task.getException());</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">try</span> &#123;                    								                                         System.out.println(result.get());</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="七、Java中的并发工具类"><a href="#七、Java中的并发工具类" class="headerlink" title="七、Java中的并发工具类"></a>七、Java中的并发工具类</h1><h2 id="1-等待多线程完成的CountDownLatch"><a href="#1-等待多线程完成的CountDownLatch" class="headerlink" title="1. 等待多线程完成的CountDownLatch"></a>1. 等待多线程完成的CountDownLatch</h2><p>虽然join方法也可以实现让主线程等待分支线程执行完后接着执行，但CountDownLatch(发令枪)使用起来更灵活</p>
<p>使用时，CountDownLatch a = new CountDownLatch(n); n是想要等待n个点完成，然后通过调用n次c.countDown()来放行c.await();</p>
<p>可以指定一个最长等待时间c.await(long time,TimeUnit unit);</p>
<h2 id="2-同步屏障CyclicBarrier"><a href="#2-同步屏障CyclicBarrier" class="headerlink" title="2. 同步屏障CyclicBarrier"></a>2. 同步屏障CyclicBarrier</h2><p>同步屏障要做的事是让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障，所有被屏障拦截的线程才会打开(每个线程通过调用 await方法告诉CyclicBarrier我已经到达屏障)</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>可以在所有线程达到屏障时优先执行一段逻辑</strong></p>
<p>通过CyclicBarrier(int parties , Runable barrier-Action)构造函数</p>
<p><strong>CyclicBarrier和CountDownLatch的区别</strong></p>
<ul>
<li>CyclicBarrier可以通过reset()方法重置计数器</li>
<li>CyclicBarrier可以通过getNumberWaiting方法获取当前的阻塞线程数</li>
<li>CountDownLatch主要用于阻塞主线程(当然也可以实现阻塞分支线程)，而CyclicBarrier主要用于阻塞分支线程(也可以实现阻塞主线程)</li>
</ul>
<h2 id="3-控制并发线程数的Semaphore"><a href="#3-控制并发线程数的Semaphore" class="headerlink" title="3. 控制并发线程数的Semaphore"></a>3. 控制并发线程数的Semaphore</h2><p>Semaphore(信号量) 是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p>
<p>主要应用场景就是限流，比如要读取excel中的数据到数据库中，因为读取excel中的数据比较频繁，是io密集型作业，需要几十个线程并发的读取，但数据库的连接数只有10个，这时候必须控制只有10个线程同时获取数据库连接保持数据，就可以用Semaphore进行限流。</p>
<p>代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;THREAD_COUNT;i++)&#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runable()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        s.acquire();</span><br><span class="line">                        System.out.println(<span class="string">&quot;save data&quot;</span>);<span class="comment">//只允许十个并发执行</span></span><br><span class="line">                        s.release();</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-线程间交换数据的Exchanger"><a href="#4-线程间交换数据的Exchanger" class="headerlink" title="4. 线程间交换数据的Exchanger"></a>4. 线程间交换数据的Exchanger</h2><p>Exchanger提供一个同步点，在这个同步点，两个线程可以彼此交换数据。</p>
<p>两个线程通过exchange方法交换数据，如果第一个线程先到达exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程到达同步点时，这两个线程可以交换数据。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> Exchanger&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    String a = <span class="string">&quot;银行流水a&quot;</span>;</span><br><span class="line">                    exgr.exchange(a);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    String b = <span class="string">&quot;银行流水b&quot;</span>;</span><br><span class="line">                    String a = exgr.exchange(b);</span><br><span class="line">                    System.out.println(<span class="string">&quot;银行流水a:&quot;</span>+a);</span><br><span class="line">                    System.out.println(<span class="string">&quot;银行流水b:&quot;</span>+b);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="八、Executor框架"><a href="#八、Executor框架" class="headerlink" title="八、Executor框架"></a>八、Executor框架</h1><p>在Java中使用线程来异步执行任务，Java线程创建于销毁需要一定的开销，如果我们为每一个任务创建一个新线程来执行，这种策略可能会使处于高负荷状态的应用最终崩溃。</p>
<p>Java的线程既是工作单元，也是执行机制。从 JDK5 开始，把工作单元与执行机制分离开来。工作单元包括 Runable 和 Callable，而执行机制由 Executor 框架提供。</p>
<h2 id="1-Executor的两级调度模型"><a href="#1-Executor的两级调度模型" class="headerlink" title="1. Executor的两级调度模型"></a>1. Executor的两级调度模型</h2><p>在 HotSpot VM的线程模型中，Java线程被一对一映射为本地操作系统线程。</p>
<p>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器(Executor 框架) 将这些任务映射为固定数量的线程</p>
<p>在底层，操作系统内核将这些线程映射到硬件处理器(CPU)上。</p>
<h2 id="2-Executor-框架的结构"><a href="#2-Executor-框架的结构" class="headerlink" title="2. Executor 框架的结构"></a>2. Executor 框架的结构</h2><p>Executor 框架主要由3大部分组成</p>
<ul>
<li>任务 - 包括被执行任务需要实现的接口：Runable 接口或 Callable 接口</li>
<li>任务的执行 - 包括任务执行机制的核心接口 Executor，以及继承自 Executor 的 ExecutorService 接口。Executor有两个关键类实现了 ExecutorService接口(ThreadPoolExecutor 和ScheduledThreadPoolExecutor)</li>
<li>异步计算的结果 - 包括接口 Future 和实现 Future 接口的 FutureTask 类</li>
</ul>
<p>下面是这些接口和类的简介</p>
<ul>
<li>Executor 接口是Executor框架的基础，它将任务的提交和任务的执行分离开来</li>
<li>ThreadPoolExecutor 是线程池的核心实现类，用来执行被提交的任务</li>
<li>ScheduledThreadPoolExecutor 是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。它比Timer更灵活，更强大</li>
<li>Future 接口和实现 Future 接口的 FutureTask 类，代表异步计算的结果</li>
<li>Runable 接口和 Callable 接口的实现类，都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行</li>
</ul>
<h2 id="3-Executor框架使用流程"><a href="#3-Executor框架使用流程" class="headerlink" title="3. Executor框架使用流程"></a>3. Executor框架使用流程</h2><p>主线程首先要创建实现 Runable 或者Callable 接口的任务对象。工具类Executors可以把一个Runable对象封装为一个Callable对象：Executors.callable(Runnable task) 或 Executors.callable(Runable task,Object result)。</p>
<p>然后可以把Runable对象直接交给ExecutorService<strong>执行</strong>：ExecutorService.execute(Runable command)；或者把Runable或Callable对象<strong>提交</strong>给ExecutorService执行：ExecutorService.submit(Runable task)或ExecutorService.submit(Callable<T> task)。</p>
<p>如果执行ExecutorService.submit(…)，ExecutorService 将返回一个实现Future接口的对象（目前版本的JDK中，返回的是FutureTask对象）</p>
<p>最后主线程执行FutureTask.get()来等待任务完成，或者FutureTask.cancel(boolean a)来取消此任务的执行</p>
<h2 id="4-ThreadPoolExecutor"><a href="#4-ThreadPoolExecutor" class="headerlink" title="4. ThreadPoolExecutor"></a>4. ThreadPoolExecutor</h2><p>Executor 框架最核心的类是 ThreadPoolExecutor，它是线程池的实现类，主要由以下4个组件构成</p>
<ul>
<li>corePool - 核心线程池的大小</li>
<li>maximumPool - 最大线程池的大小</li>
<li>BlockingQueue - 用来暂时保存任务的工作队列</li>
<li>RejectedExecutionHandler - 当ThreadPoolExecutor已经关闭或者饱和时，execute()方法要调用的Handler</li>
<li>Executors - Executor框架的工厂类，可以创建以下3种类型的 ThreadPoolExecutor<ul>
<li>FixedThreadPool</li>
<li>SingleThreadExecutor</li>
<li>CachedThreadPool</li>
</ul>
</li>
</ul>
<h3 id="4-1-FixedThreadPool"><a href="#4-1-FixedThreadPool" class="headerlink" title="4.1 FixedThreadPool"></a>4.1 FixedThreadPool</h3><p>可重用固定线程数的线程池。适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，适用于负载比较重的服务器</p>
<p>特点是只有核心线程池和无界阻塞工作队列，同时只会有核心线程池大小的线程执行，这种结构使得大多数时候不需要创建线程和销毁线程抢占全局锁，所以对于负载重的服务器执行效率非常高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-2-SingleThreadExecutor"><a href="#4-2-SingleThreadExecutor" class="headerlink" title="4.2 SingleThreadExecutor"></a>4.2 SingleThreadExecutor</h3><p>只使用单个线程，适用于需要保证顺序地执行各个任务</p>
<p>和FixedThreadPool一样有无界阻塞工作队列，核心线程数和最大线程数都是1，其主要特点就是顺序执行</p>
<h3 id="4-3-CachedThreadPool"><a href="#4-3-CachedThreadPool" class="headerlink" title="4.3 CachedThreadPool"></a>4.3 CachedThreadPool</h3><p>没有核心线程池，空闲线程等待一分钟即被终止，适用于执行很多短期异步任务，或者负载较轻的服务器</p>
<p>需要注意的是如果主线程提交任务的速度高于线程任务的处理速度，CachedThreadPool会不断创建新线程，可能导致CPU资源枯竭</p>
<h2 id="5-ScheduledThreadPoolExecutor"><a href="#5-ScheduledThreadPoolExecutor" class="headerlink" title="5. ScheduledThreadPoolExecutor"></a>5. ScheduledThreadPoolExecutor</h2><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来给定的延迟后运行任务，或者定期执行任务。</p>
<p>ScheduledThreadPoolExecutor的功能与Timer类似，但存在以下区别</p>
<ul>
<li>Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数</li>
<li>Timer如果一个任务执行失败抛出异常，别的任务也会停止；而ScheduledThreadPoolExecutor不会</li>
<li>Timer如果前一个任务执行时间过长会导致下一个任务的执行时间不是设定的时间</li>
<li>Timer基于系统时间，如果修改系统时间会导致一些问题；ScheduledExecutorService基于时间的延迟</li>
</ul>
<h3 id="5-1-运行机制"><a href="#5-1-运行机制" class="headerlink" title="5.1 运行机制"></a>5.1 运行机制</h3><ol>
<li>当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或者scheduleWithFixedDelay()方法时，会向ScheduledThreadPoolExecutor 的 DelayQueue 添加一个实现了 RunableScheduledFutur接口的ScheduledFutureTask</li>
<li>线程池中的线程从 DelayQueue 中获取 ScheduledFutureTask，然后执行任务</li>
</ol>
<h3 id="5-2-使用"><a href="#5-2-使用" class="headerlink" title="5.2 使用"></a>5.2 使用</h3><p>创建一个核心线程数为corePoolSize的线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建并执行一个给定的初始延迟initialDelay后,每隔period个时间单位unit后再次执行。 如果任务的任一执行遇到异常，就会取消后续执行。 否则，任务将只能通过取消或执行的终止终止。</p>
<p>如果此任务的任何执行时间比其周期长，则后续执行可能起步晚，但不会同时执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                  <span class="keyword">long</span> period,</span><br><span class="line">                                                  TimeUnit unit);</span><br><span class="line"><span class="comment">//返回的是该任务的Future对象，当需要需要该定时任务时可以future.cancel(true);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与之相对的是scheduleWithFixedDelay，该方法不会在上一次任务开始时开始计时，而是在上一个任务结束后开始计时，时间到直接执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                 <span class="keyword">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-ThreadPoolTaskScheduler"><a href="#6-ThreadPoolTaskScheduler" class="headerlink" title="6. ThreadPoolTaskScheduler"></a>6. ThreadPoolTaskScheduler</h2><p>可以很方便的对重复执行的任务进行调度管理，相比于通过java自带的周期性任务线程池ScheduleThreadPoolExecutor，此bean支持cron表达式创建周期性任务。相比于直接使用注解cron的方式创建定时任务，ThreadPoolTaskScheduler可以做到参数可配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolTaskScheduler threadPoolTaskScheduler = <span class="keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line"><span class="comment">//启动定时任务</span></span><br><span class="line">ScheduledFuture&lt;?&gt; future = threadPoolTaskScheduler.schedule(<span class="keyword">new</span> MyRunnable(),<span class="keyword">new</span> Trigger() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Date <span class="title">nextExecutionTime</span><span class="params">(TriggerContext triggerContext)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> CronTrigger(cron).nextExecutionTime(triggerContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//关闭定时任务</span></span><br><span class="line">future.cancel(<span class="keyword">true</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;first DynamicTask，&quot;</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="九、协程"><a href="#九、协程" class="headerlink" title="九、协程"></a>九、协程</h1><p>相比线程的优点</p>
<ol>
<li>占用更少的内存资源</li>
<li>任务调度时更少的切换开销</li>
</ol>
<p>适用于I/O密集型的操作，计算密集型的还是使用线程更合理</p>
<p><strong>使用</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>co.paralleluniverse<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quasar-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>jdk8<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//使用阻塞队列来获取结果。</span></span><br><span class="line">        LinkedBlockingQueue&lt;Fiber&lt;Integer&gt;&gt; fiberQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="comment">//这里的Fiber有点像Callable,可以返回数据</span></span><br><span class="line">            Fiber&lt;Integer&gt; fiber = <span class="keyword">new</span> Fiber&lt;&gt;((SuspendableCallable&lt;Integer&gt;) () -&gt; &#123;</span><br><span class="line">                <span class="comment">//这里用于测试内存占用量</span></span><br><span class="line">                Fiber.sleep(<span class="number">100000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;in-&quot;</span> + finalI + <span class="string">&quot;-&quot;</span> + LocalDateTime.now().format(formatter));</span><br><span class="line">                <span class="keyword">return</span> finalI;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//开始执行</span></span><br><span class="line">            fiber.start();</span><br><span class="line">            <span class="comment">//加入队列</span></span><br><span class="line">            fiberQueue.add(fiber);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//阻塞</span></span><br><span class="line">            Fiber&lt;Integer&gt; fiber = fiberQueue.take();</span><br><span class="line">            System.out.println(<span class="string">&quot;out-&quot;</span> + fiber.get() + <span class="string">&quot;-&quot;</span> + LocalDateTime.now().format(formatter));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>















      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/20/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/" data-id="ckk50chbb000gegmz0hfibupc" data-title="java并发基础" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80/" rel="tag">java基础</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/01/20/flink/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          flink
        
      </div>
    </a>
  
  
    <a href="/2021/01/20/SpringCloud%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">SpringCloud、分布式解决方案</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80/" rel="tag">java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">框架及中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 16.67px;">java基础</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 10px;">大数据</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 13.33px;">服务器</a> <a href="/tags/%E6%A1%86%E6%9E%B6%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 20px;">框架及中间件</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/20/Arthas/">Arthas</a>
          </li>
        
          <li>
            <a href="/2021/01/20/COLA/">COLA</a>
          </li>
        
          <li>
            <a href="/2021/01/20/HazelCast%E3%80%81Ignite/">HazelCast、Ignite</a>
          </li>
        
          <li>
            <a href="/2021/01/20/Shiro%E3%80%81Spring%20Security/">Shiro、Spring Security</a>
          </li>
        
          <li>
            <a href="/2021/01/20/cucumber/">cucumber</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Nginx、Mycat、MongoDB | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Nginx正向代理与反向代理 正向代理 正向代理（forward proxy） ，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。  ​     简单一点：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他">
<meta property="og:type" content="article">
<meta property="og:title" content="Nginx、Mycat、MongoDB">
<meta property="og:url" content="http://example.com/2021/01/20/Nginx%E3%80%81MyCat%E3%80%81MongoDB/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Nginx正向代理与反向代理 正向代理 正向代理（forward proxy） ，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。  ​     简单一点：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1554291864126.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1554357186238.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1554357215537.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1554357460368.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1554357759296.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1554453933519.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1554472726128.png">
<meta property="og:image" content="d:/Typora/resources/app/asserts/icon/1556204774175.png">
<meta property="og:image" content="d:/Typora/resources/app/asserts/icon/7928684-3959f914f4270b82.png">
<meta property="og:image" content="d:/Typora/resources/app/asserts/icon/20180102094016239.png">
<meta property="og:image" content="d:/Typora/resources/app/asserts/icon/111.png">
<meta property="og:image" content="d:/Typora/resources/app/asserts/icon/1554100647660.png">
<meta property="og:image" content="d:/Typora/resources/app/asserts/icon/907596-20170604035137258-762254443.png">
<meta property="og:image" content="d:/Typora/resources/app/asserts/icon/907596-20170604035229055-909393426.png">
<meta property="og:image" content="d:/Typora/resources/app/asserts/icon/845791bd1c2593ec43ed1fd7877decb82fc.jpg">
<meta property="article:published_time" content="2021-01-19T16:00:00.000Z">
<meta property="article:modified_time" content="2021-01-20T06:09:09.411Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="框架及中间件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/Administrator/AppData/Local/Temp/1554291864126.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Nginx、MyCat、MongoDB" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/20/Nginx%E3%80%81MyCat%E3%80%81MongoDB/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T16:00:00.000Z" itemprop="datePublished">2021-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Nginx、Mycat、MongoDB
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h2><ul>
<li><p>正向代理</p>
<p>正向代理（forward proxy） ，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。 </p>
<p>​     简单一点：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色。 </p>
</li>
<li><p>反向代理</p>
<p>反向代理（Reverse Proxy），以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器。 </p>
<p>理解起来有些抽象，可以这么说：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在。</p>
</li>
</ul>
<p>正向代理与反向代理的区别</p>
<ul>
<li><p>位置不同</p>
<p>正向代理，架设在客户机和目标主机之间；<br>反向代理，架设在服务器端；</p>
</li>
<li><p>代理对象不同</p>
<p>正向代理，代理客户端，服务端不知道实际发起请求的客户端；<br>反向代理，代理服务端，客户端不知道实际提供服务的服务端；</p>
</li>
</ul>
<h2 id="常用的WEB服务器"><a href="#常用的WEB服务器" class="headerlink" title="常用的WEB服务器"></a>常用的WEB服务器</h2><ol>
<li><p>IIS</p>
<p>IIS（Internet信息服务）英文InternetInformationServer的缩写。它是微软公司主推的服务器。IIS的特点具有：安全性，强大，灵活。</p>
</li>
<li><p>Tomcat(Servlet容器)</p>
<p>Tomcat是Apache软件基金会（ApacheSoftwareFoundation）的Jakarta项目中的一个核心项目，由Apache、Sun和其他一些公司及个人共同开发而成。Tomcat技术先进、性能稳定，而且免费，因而深受Java爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web应用服务器(下降趋势)</p>
</li>
<li><p>Nginx(上升很快)</p>
<p>Nginx不仅是一个小巧且高效的HTTP服务器，也可以做一个高效的负载均衡反向代理，通过它接受用户的请求并分发到多个Mongrel进程可以极大提高Rails应用的并发能力，同时nginx也可以作为静态资源服务器。</p>
</li>
<li><p>Apache(下降趋势)</p>
<p>Apache是世界使用排名第一的Web服务器软件。它几乎可以运行在所有的计算机平台上。由于Apache是开源免费的，因此有很多人参与到新功能的开发设计，不断对其进行完善。Apache的特点是简单、速度快、性能稳定，并可做代理服务器来使用。</p>
</li>
</ol>
<p>动态资源服务器和静态资源服务器：</p>
<p>静态资源：一般客户端发送请求到web服务器，web服务器从内存在取到相应的文件，返回给客户端，客户端解析并渲染显示出来。</p>
<p>动态资源：一般客户端请求的动态资源，先将请求交于web容器，再交给servlet容器，servlet容器连接数据库，数据库处理数据之后，将内容交给web服务器，web服务器返回给客户端解析渲染处理。</p>
<p>2.静态资源和动态资源的区别</p>
<p>a.静态资源一般都是设计好的html页面，而动态资源依靠设计好的程序来实现按照需求的动态响应；</p>
<p>b.静态资源的交互性差，动态资源可以根据需求自由实现；</p>
<p>c.在服务器的运行状态不同，静态资源不需要与数据库参于程序处理，动态可能需要多个数据库的参与运算。</p>
<h2 id="Nginx的安装及常用命令"><a href="#Nginx的安装及常用命令" class="headerlink" title="Nginx的安装及常用命令"></a>Nginx的安装及常用命令</h2><p><strong>1、下载Nginx</strong></p>
<p>wget <a target="_blank" rel="noopener" href="http://nginx.org/download/nginx-1.14.2.tar.gz">http://nginx.org/download/nginx-1.14.2.tar.gz</a>  （stable）</p>
<p><strong>2、安装Nginx依赖</strong></p>
<p>nginx是C语言开发，建议在linux上运行，本教程使用<strong>Centos7.4</strong>为安装环境。</p>
<p>n gcc</p>
<p>安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：<u>yum install gcc-c++</u></p>
<p>n PCRE</p>
<p>PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。</p>
<p><u>yum install -y pcre pcre-devel</u></p>
<p>注：pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。</p>
<p>n zlib</p>
<p>zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。</p>
<p><u>yum install -y zlib zlib-devel</u></p>
<p>n openssl</p>
<p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。</p>
<p>nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。</p>
<p><u>yum install -y openssl openssl-devel</u></p>
<p>yum install -y gcc-gcc++ pcre pcre-devel zlib zlib-devel openssl openssl-devel</p>
<p><strong>3、安装Nginx</strong></p>
<p>解压</p>
<p><u>tar xf nginx-1.12.2.tar.gz</u></p>
<p>进行configure配置</p>
<p><u>./configure –prefix=/usr/local/nginx</u>  （可以配置很多nginx其他模块，后面配置https的时候讲解）</p>
<p>编译和安装</p>
<p><u>make &amp; make install -j 4</u></p>
<p>如果以上操作没有报错则安装成功</p>
<p>启动nginx:在sbin目录下</p>
<p><u>./nginx -c 指定配置文件位置</u></p>
<p>eg: ./nginx -c /usr/local/nginx/conf/nginx.conf </p>
<p>./nginx 默认使用NGINX_HOME/config/nginx.conf配置文件</p>
<p>停止niginx</p>
<p><u>./nginx -s stop</u>   停止</p>
<p><u>./nginx -s quit</u>    退出</p>
<p><u>./nginx -s reload</u> 重新加载nginx.conf （很常用）</p>
<p>发送信号量 （找不到nginx安装位置，但是想要停止nginx服务器情况下使用）</p>
<p>kill -TERM master进程号</p>
<p>kill -QUIT master进程号</p>
<p>nginx 常用命令</p>
<p>./nginx -v 查看nginx版本</p>
<p>./nginx -V 查看nginx的编译版本及配置的参数</p>
<p>./nginx -t  主要验证nginx.conf配置文件是否有问题，<u>返回ok和successful是正确配置了</u></p>
<p>./nginx -c 选定自定义配置文件的<u>位置</u></p>
<p>./nginx -s  发送对应信号处理master进程(stop,quit,reopen,reload)</p>
<h2 id="Nginx配置文件介绍"><a href="#Nginx配置文件介绍" class="headerlink" title="Nginx配置文件介绍"></a>Nginx配置文件介绍</h2><p><img src="C:\Users\Administrator\AppData\Local\Temp\1554291864126.png" alt="1554291864126"></p>
<p>配置文件在conf这个文件夹下，其中nginx.conf是主配置文件。nginx.conf配置文件主要分成<strong>四个部分</strong>：</p>
<ul>
<li>main (全局设置) </li>
<li>sever (虚拟主机设置)</li>
<li>upstream负载均街服务器设置</li>
<li>location(URL匹配特定位置的设置)</li>
</ul>
<p><strong>关系说明</strong></p>
<p>​     main部分设置的命令将影响其他所有设置。 server 部分的命令主要用于指定主机和端口;。upstream命令主要用于负载均衡，设置一系列的后端服务器。 location 部分用于匹配网页位置。这四者之间的关系是server继承main， location 继承server， upstream 既不会继承其他设置也不会被继承。</p>
<p>​    在这四个部分当中，每个部分都包含若干命令，这些命令主要包含Nginx的主模块命令，事件模块命令，HTTP核心模块命令，同时每个部分还可以使用其他HTTP模块命令（例如HTTP SSL模块，HttpGzip Static模块和Http Addition模块等）。</p>
<p><strong>配置文件详解</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">user  nobody;</span>                                   </span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  以上这块配置代码是对nginx全局属性的配置。</span><br><span class="line">  user :主模块命令， 指定Nginx的worker进程运行用户以及用户组，默认由nobody账号运行（默认nginx）。</span><br><span class="line">  worker processes: 指定Nginx要开启的进程数。</span><br><span class="line">  error log:用来定义全局错设日志文件的路径和日志名称。日志输出级别有debug，info，notice，warn，error，crit 可供选择，其中debug输出日志最为详细，而crit输出日志最少。</span><br><span class="line">  pid: 用来指定进程id的存储文件位置。</span><br><span class="line">  event：设定nginx的工作模式及连接数上限，其中参数use用来指定nginx的工作模式（这里是epoll，epoll是多路复用IO(I/O Multiplexing)中的一种方式）,nginx支持的工作模式有select ,poll,kqueue,epoll,rtsig,/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，对于linux系统，epoll是首选。</span><br><span class="line">  worker_connection：是设置nginx每个进程最大的连接数，默认是1024，所以nginx最大的连接数max_client=worker_processes * worker_connections。进程最大连接数受到系统最大打开文件数的限制，需要设置ulimit。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下面部分是nginx对http服务器相关属性的设置</span></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;               #主模块命令，对配置文件所包含文件的设定，减少主配置文件的复杂度，相当于把部分设置放在别的地方，然后在包含进来，保持主配置文件的简洁</span><br><span class="line">    default_type  application/octet-stream; #默认文件类型，当文件类型未定义时候就使用这类设置的，可以接受任意类型。 </span><br><span class="line"></span><br><span class="line">    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;   指定nginx日志的格式</span><br><span class="line">    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;   开启高效文件传输模式（零拷贝方式），避免内核缓冲区数据和用户缓冲区数据之间的拷贝。</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;   客户端连接超时时间</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;             设置是否开启gzip模块（请求压缩）</span><br><span class="line"></span><br><span class="line">    #server段是虚拟主机的配置    这里可以写在别的文件中     然后在包含进来，比如写在/usr/local/nginx/vhost/xxx.conf 目录某文件中 然后在包含进来，可以包含多个文件 include /usr/local/nginx/vhost/*;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;   虚拟主机的服务端口</span><br><span class="line">        server_name  localhost;   用来指定ip或者域名，多个域名用逗号分开</span><br><span class="line"></span><br><span class="line">        #charset utf-8;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;                       #地址匹配设置，支持正则匹配，也支持条件匹配，这里是默认请求地址，用户可用location命令对nginx进行动态和静态网页过滤处理</span><br><span class="line">            root   html;                   #虚拟主机的网页根目录</span><br><span class="line">            index  index.html index.htm;   #默认访问首页文件</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        location ~ \.php$ &#123;   将以php为后缀的文件转发到 FastCGI处理. 使用FastCGI默认配置。本地8088端口处理</span><br><span class="line">              fastcgi_pass   http://127.0.0.1：8088;</span><br><span class="line"></span><br><span class="line">              fastcgi_index index.php;</span><br><span class="line">              fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">              include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">        #静态文件，nginx自己处理</span><br><span class="line">        location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;</span><br><span class="line">             root /var/www/public/images;       </span><br><span class="line">             expires 30d;  #缓存时间30天，静态文件更新不多，过期时间可以设大一点。</span><br><span class="line">        &#125;</span><br><span class="line">       #配置Nginx状态的地址</span><br><span class="line">        location /NginxStatus &#123;</span><br><span class="line">          stub_status            on;</span><br><span class="line">          access_log              on;</span><br><span class="line">          auth_basic              &quot;NginxStatus&quot;;</span><br><span class="line">          auth_basic_user_file  conf/htpasswd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       #配置nginx负载均衡的服务器列表</span><br><span class="line">       upstream mysvr &#123;</span><br><span class="line">          #weigth参数表示权值，权值越高被分配到的几率越大</span><br><span class="line">          #本机上的Squid开启3128端口</span><br><span class="line">          server 192.168.199.1:88   weight=5;</span><br><span class="line">          server 192.168.199.1:80   weight=1;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;              </span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">        # concurs with nginx&#x27;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Server配置"><a href="#Server配置" class="headerlink" title="Server配置"></a>Server配置</h3><h4 id="基于域名的配置"><a href="#基于域名的配置" class="headerlink" title="基于域名的配置"></a>基于域名的配置</h4><p>a、首先在本地的(系统盘/windows/system32/driver/etc/hosts)文件中配置DNS</p>
<p>格式为: IP 域名</p>
<p>192.168.146.220 <a target="_blank" rel="noopener" href="http://www.chl.com/">www.chl.com</a></p>
<p>b、在nginx的配置中配置虚拟主机</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.chl.com; # 域名区分</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        root html/chl;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name www.rm.com;  # 域名区分</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        root html/rm;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就能通过<a target="_blank" rel="noopener" href="http://www.chl.com来访问nginx/html/chl/index.html%E4%BA%86">www.chl.com来访问nginx/html/chl/index.html了</a></p>
<h4 id="基于端口"><a href="#基于端口" class="headerlink" title="基于端口"></a>基于端口</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80; # 端口区分</span><br><span class="line">    server_name www.gerry.com;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        root html/gerry;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8080; # 端口区分</span><br><span class="line">    server_name www.gerry.com;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        root html/gerry;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于IP地址"><a href="#基于IP地址" class="headerlink" title="基于IP地址"></a>基于IP地址</h4><p>1、添加网卡的IP别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens33:1 192.168.3.202 broadcast 192.168.3.255 netmask 255.255.255.0 up</span><br><span class="line">route add -host 192.168.3.202 dev ens33:1</span><br><span class="line">ifconfig ens33:2 192.168.3.203 broadcast 192.168.3.255 netmask 255.255.255.0 up</span><br><span class="line">route add -host 192.168.3.203 dev ens33:2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 从另外一台服务器Ping 192.168.3.202和192.168.3.203两个IP,如果能够Ping通，则证明配置无误。但是，通过ifconfig和route配置的IP别名在服 务器重启后会消失，不过可以将这两条ifconng和route命令添加到/etc/rc.local文件中，让系统开机时自动运行，以下是相关命令：<strong>vi /etc/rc.local</strong><br>在文件末尾增加以下内容，然后保存即可</p>
<p>ifconfig ens33:1 192.168.3.202 broadcast 192.168.3.255 netmask 255.255.255.0 up<br>route add -host 192.168.3.202 dev ens33:1<br>ifconfig ens33:2 192.168.3.203 broadcast 192.168.3.255 netmask 255.255.255.0 up<br>route add -host 192.168.3.203 dev ens33:2</p>
<p>2、修改配置文件做如下的Server段配置</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">listen</span> <span class="string">80;</span></span><br><span class="line">    <span class="attr">server_name</span> <span class="string">192.168.3.202;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">        <span class="attr">root</span> <span class="string">html/host1;</span></span><br><span class="line">        <span class="attr">index</span> <span class="string">index.html;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">listen</span> <span class="string">80;</span></span><br><span class="line">    <span class="attr">server_name</span> <span class="string">192.168.3.203;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">location</span> <span class="string">/ &#123;</span></span><br><span class="line">        <span class="attr">root</span> <span class="string">html/host2;</span></span><br><span class="line">        <span class="attr">index</span> <span class="string">index.html;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="Nginx中server-name的匹配顺序"><a href="#Nginx中server-name的匹配顺序" class="headerlink" title="Nginx中server_name的匹配顺序"></a>Nginx中server_name的匹配顺序</h3><p><strong>前提：</strong>安装echo-nginx-module</p>
<p>1、下载<a target="_blank" rel="noopener" href="https://github.com/openresty/echo-nginx-module%E5%B9%B6%E8%A7%A3%E5%8E%8B%E5%88%B0/usr/local/nginx_modules%E7%9B%AE%E5%BD%95%E4%B8%8B">https://github.com/openresty/echo-nginx-module并解压到/usr/local/nginx_modules目录下</a></p>
<p>2、进入nginx的安装目录，用下列命令进行配置和安装<br>./configure –prefix=/usr/local/nginx –add-module=/usr/local/nginx_modules/echo-nginx-module-master<br>make -j4 &amp;&amp; make install</p>
<p><strong>修改hosts配置文件</strong></p>
<p>在Hosts文件中做如下配置：</p>
<p>vim /etc/hosts</p>
<p>127.0.0.1 bbb.cn</p>
<p>127.0.0.1 aaa.cn</p>
<h4 id="最高优先级：完全匹配"><a href="#最高优先级：完全匹配" class="headerlink" title="最高优先级：完全匹配"></a>最高优先级：完全匹配</h4><p>首先，在nginx.conf中创建2个server，1个完全匹配，1个通配符匹配</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name *.cn;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        echo &quot;通配符在前&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name aaa.cn;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        echo &quot;完全匹配&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论：完全匹配&gt;前置通配符</p>
<h4 id="第二优先级：前置通配符"><a href="#第二优先级：前置通配符" class="headerlink" title="第二优先级：前置通配符"></a>第二优先级：前置通配符</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name ddd.*;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        echo &quot;通配符在后&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name *.cn;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        echo &quot;通配符在前&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结论：前置通配符&gt;后置通配符</p>
<h4 id="第三优先级：后置通配符"><a href="#第三优先级：后置通配符" class="headerlink" title="第三优先级：后置通配符"></a>第三优先级：后置通配符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name ~^\w+\.cn$;</span><br><span class="line">    </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        default_type text&#x2F;html;</span><br><span class="line">        echo &quot;正则匹配&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name ddd.*;</span><br><span class="line">    </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        default_type text&#x2F;html;</span><br><span class="line">        echo &quot;通配符在后&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结论：后置通配符&gt;正则匹配</p>
<h4 id="listen端口设置default进行端口匹配"><a href="#listen端口设置default进行端口匹配" class="headerlink" title="listen端口设置default进行端口匹配"></a>listen端口设置default进行端口匹配</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name ~^\w+\.cn$;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        echo &quot;正则匹配&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name dddd.xxx;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        echo &quot;不匹配&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80 default; #设置default后在所有server_name都匹配不上的情况下会按照端口进行匹配</span><br><span class="line">    server_name haha.xxx;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        echo &quot;不匹配找Listen Default&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="验证没有匹配成功也没有default的情况"><a href="#验证没有匹配成功也没有default的情况" class="headerlink" title="验证没有匹配成功也没有default的情况"></a>验证没有匹配成功也没有default的情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    listen 80;</span><br><span class="line">    server_name haha.cn;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        echo &quot;不匹配,通配符在前&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name heihei.cn;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        default_type text/html;</span><br><span class="line">        echo &quot;不匹配,通配符在后&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结论： 在请求的server_name 都不匹配也没有default关键字情况下，会根据配置文件的顺序选择配置文件中第一虚拟主机。</p>
<h3 id="日志的配置"><a href="#日志的配置" class="headerlink" title="日志的配置"></a>日志的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line">	# 定义日志的格式</span><br><span class="line">    log_format  main  &#39;$remote_addr - [$time_iso8601] - $msec - $status - $request_time - $body_bytes_sent - &quot;$http_host&quot; - &quot;$request&quot; - &quot;$http_referer&quot; - &quot;$http_user_agent&quot; - &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">　　#设置日志默认存储目录</span><br><span class="line">    access_log  logs&#x2F;access.log  main;</span><br><span class="line">    error_log   logs&#x2F;error.log;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 内置的变量 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">$remote_addr, $http_x_forwarded_for（反向） 记录客户端IP地址</span><br><span class="line">$remote_user 记录客户端用户名称</span><br><span class="line">$request 记录请求的URL和HTTP协议</span><br><span class="line">$status 记录请求状态</span><br><span class="line">$body_bytes_sent 发送给客户端的字节数，不包括响应头的大小； 该变量与Apache模块mod_log_config里的“%B”参数兼容。</span><br><span class="line">$bytes_sent 发送给客户端的总字节数。</span><br><span class="line">$connection 连接的序列号。</span><br><span class="line">$connection_requests 当前通过一个连接获得的请求数量。</span><br><span class="line">$msec 日志写入时间。单位为秒，精度是毫秒。</span><br><span class="line">$pipe 如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”。</span><br><span class="line">$http_referer 记录从哪个页面链接访问过来的</span><br><span class="line">$http_user_agent 记录客户端浏览器相关信息</span><br><span class="line">$request_length 请求的长度（包括请求行，请求头和请求正文）。</span><br><span class="line">$request_time 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。</span><br><span class="line">$time_iso8601 ISO8601标准格式下的本地时间。</span><br><span class="line">$time_local 通用日志格式下的本地时间。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="location配置（html-location重定向）"><a href="#location配置（html-location重定向）" class="headerlink" title="location配置（html location重定向）"></a>location配置（html location重定向）</h3><p>匹配指定的请求uri（请求uri不包含查询字符串，如<a target="_blank" rel="noopener" href="http://localhost:8080/test?id=10%EF%BC%8C%E8%AF%B7%E6%B1%82uri%E6%98%AF/test%EF%BC%89">http://localhost:8080/test?id=10，请求uri是/test）</a></p>
<p><strong>语法形式</strong></p>
<p>location   [ = | ~ | <del>* | ^</del> | @]   /uri/     { configuration }</p>
<p>location   =   /uri         =开头表示精确前缀匹配，只有完全匹配才能生效。</p>
<p>location   ^~   /uri        ^~开头表示普通字符串匹配上以后不再进行正则匹配。</p>
<p>location   ~   pattern     ~开头表示区分大小写的正则匹配。</p>
<p>location   ~*   pattern    ~*开头表示不区分大小写的正则匹配。</p>
<p>location   /uri                  不带任何修饰符，表示前缀匹配。（一般匹配，最长命中匹配）</p>
<p>location /uri/aaa/bbb  最长命中匹配</p>
<p>location   /                       通用匹配，任何未匹配到其他location的请求都会匹配到。</p>
<p>注意：正则匹配会根据匹配顺序，找到第一个匹配的正则表达式后将停止搜索。普通字符串匹配则无视顺序，只会选择最精确的匹配。</p>
<h4 id="location常用匹配"><a href="#location常用匹配" class="headerlink" title="location常用匹配"></a>location常用匹配</h4><ul>
<li><p><strong>=</strong> ：精准匹配</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1554357186238.png" alt="1554357186238"></p>
<p>访问<a target="_blank" rel="noopener" href="http://www.gerry.com/test%EF%BC%8C%E9%A2%84%E6%9C%9F%E7%BB%93%E6%9E%9C%E4%B8%BAusr/local/nginx/gerry/host1/test/index.html">www.gerry.com/test，预期结果为usr/local/nginx/gerry/host1/test/index.html</a></p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1554357215537.png" alt="1554357215537"></p>
<p>实际结果:usr/local/nginx/html/test/index.html，因为/也有匹配的location，导致404报错</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1554357460368.png" alt="1554357460368"></p>
<p>解决方案：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1554357759296.png" alt="1554357759296"></p>
<p>然后使用<a target="_blank" rel="noopener" href="http://www.gerry.com/test/index.html%E8%AE%BF%E9%97%AE">www.gerry.com/test/index.html访问</a></p>
</li>
<li><p><strong>~</strong> ：正则匹配</p>
<ul>
<li><strong>~*</strong> ：正则匹配，不区分大小写</li>
</ul>
</li>
<li><p><strong>^~</strong> : 普通字符匹配， ^~ 的含义是如果命中，则不会再进行任何的正则匹配</p>
</li>
<li><p><strong>前面没有任何修饰</strong>： 普通字符匹配(命中最长匹配)</p>
</li>
</ul>
<h4 id="location匹配顺序"><a href="#location匹配顺序" class="headerlink" title="location匹配顺序"></a>location匹配顺序</h4><ol>
<li>精确匹配</li>
<li>普通匹配</li>
<li>正则匹配 </li>
</ol>
<p>精准匹配</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location =/test/index.html &#123;</span><br><span class="line">	root gerry/host2;</span><br><span class="line">	index index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>普通匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;test &#123;</span><br><span class="line">	root gerry&#x2F;host1;</span><br><span class="line">	index index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 最长命中匹配</span><br><span class="line">location &#x2F;test&#x2F;aaa &#123;</span><br><span class="line">	root gerry&#x2F;host1;</span><br><span class="line">	index index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># root 和 alias 区别</span><br><span class="line">location &#x2F;test &#123;</span><br><span class="line">	root gerry&#x2F;host1;</span><br><span class="line">	index index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location &#x2F;kkk&#x2F; &#123;</span><br><span class="line">	alias &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;gerry&#x2F;host1&#x2F;;</span><br><span class="line">	index index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>正则匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">##正则匹配</span><br><span class="line">location ~ &#x2F;test&#x2F;.+\.html$ &#123;</span><br><span class="line">	root gerry&#x2F;host1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ &#x2F;test&#x2F;.+\.js$ &#123;</span><br><span class="line">	root gerry&#x2F;host1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 关闭正则匹配</span><br><span class="line">location ^~ &#x2F;test &#123;</span><br><span class="line">	root gerry&#x2F;host2;</span><br><span class="line">	index index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 忽略大小写匹配</span><br><span class="line">location ~* &#x2F;.+\.HTML$ &#123;</span><br><span class="line">	root gerry&#x2F;html;</span><br><span class="line">	index index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="常用配置指令alias、root、proxy-pass"><a href="#常用配置指令alias、root、proxy-pass" class="headerlink" title="常用配置指令alias、root、proxy_pass"></a>常用配置指令alias、root、proxy_pass</h3><p>1、alias——别名配置，用于访问文件系统，在匹配到location配置的URL路径后，指向alias配置的路径，如：</p>
<blockquote>
<p>location   /test/  {</p>
<p>​        alias    /usr/local/; ## 文件路径必须为绝对路径</p>
<p>}</p>
</blockquote>
<p>请求/test/1.jpg（省略了协议和域名），将会返回文件/usr/local/1.jpg。</p>
<p>如果alias配置在正则匹配的location内，则正则表达式中必须包含捕获语句（也就是括号**()**），而且alias配置中也要引用这些捕获值。如：</p>
<blockquote>
<p>location   ~*   /img/(.+.(gif|png|jpeg)) {</p>
<p>​    alias     /usr/local/images/$1;</p>
<p>}</p>
</blockquote>
<p>请求中只要能匹配到正则，比如**/img/flower.png**  或者  <strong>/resource/img/flower.png</strong>，都会转换为请求**/usr/local/images/flower.png**。</p>
<p>2、root——根路径配置，用于访问文件系统，在匹配到location配置的URL路径后，指向root配置的路径，并把请求路径附加到其后，如：</p>
<blockquote>
<p>location   /test/  {</p>
<p>​        root    /usr/local/;</p>
<p>}</p>
</blockquote>
<p>请求/test/1.jpg，将会返回文件/usr/local/test/1.jpg。</p>
<p>3、proxy_pass——反向代理配置，用于代理请求，适用于前后端负载分离或多台机器、服务器负载分离的场景，在匹配到location配置的URL路径后，转发请求到proxy_pass配置额URL，是否会附加location配置路径与proxy_pass配置的路径后是否有”/“有关，有”/“则不附加，如：</p>
<blockquote>
<p>location   /test/  {</p>
<p>​        proxy_pass    <a target="_blank" rel="noopener" href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a>;</p>
<p>​    proxy_connect_timeout 600;<br>​    proxy_read_timeout 600;</p>
<p>}</p>
</blockquote>
<h2 id="Nginx的Rewrite的使用"><a href="#Nginx的Rewrite的使用" class="headerlink" title="Nginx的Rewrite的使用"></a>Nginx的Rewrite的使用</h2><h3 id="rewrite的介绍"><a href="#rewrite的介绍" class="headerlink" title="rewrite的介绍"></a>rewrite的介绍</h3><p>1、Rewrite通过ngx_http_rewrite_module模块支持url重写、支持if判断，但不支持else</p>
<p>2、rewrite功能就是，使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向</p>
<p>3、它可以让我们在改变网站结构后，不需要要求客户端用户修改原来的书签，也无需其他网站修改对我们网站的友情链接；它还可以在一定程度上提高网站的安全性 </p>
<p>4、rewrite只能放在server{},location{},if{}中，并且只能对域名后边的除去传递的参数外的字符串起作用</p>
<p><a target="_blank" rel="noopener" href="http://www.gerry.com/test/v1/10">http://www.gerry.com/test/v1/10</a></p>
<p><a target="_blank" rel="noopener" href="http://www.gerry.com/test?version=1&amp;id=10">http://www.gerry.com/test?version=1&amp;id=10</a></p>
<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><p><strong>If</strong> <strong>空格 (条件) {设定条件进行重写}</strong></p>
<p>条件的语法：</p>
<ol>
<li>“=” 来判断相等，用于字符比较</li>
<li>“<del>” 用正则来匹配（表示区分大小写），“</del>*” 不区分大小写</li>
<li>“-f -d -e” 来判断是否为文件、目录、是否存在</li>
</ol>
<p><strong>return</strong> <strong>指令</strong></p>
<p>语法：return code;</p>
<p>停止处理并返回指定状态码给客户端(比如可以防止木马攻击)。</p>
<p>if ($request_uri ~ *.sh ){</p>
<p>  return 403</p>
<p>}</p>
<p><strong>set指令</strong></p>
<p>set variable value; </p>
<p>定义一个变量并赋值，可以是文本、变量或者文本变量混合体</p>
<p><strong>rewrite指令</strong></p>
<p>语法：rewrite regex replacement [flag]{last / break/ redirect 返回临时301/ permanent  返回永久302}</p>
<p>last: 停止处理后续的rewrite指令集、 然后对当前重写的uri在rewrite指令集上重新查找</p>
<p>break: 停止处理后续的rewrite指令集 ,并不会重新查找</p>
<h3 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h3><p>热门搜索</p>
<p>这个规则的目的是为了执行搜索，搜索URL中包含的关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rewrite规则最后加了问号和不加问号区别？</span><br><span class="line">URI：&#x2F;search&#x2F;some-search-keywords&#x2F;zhangsan?name&#x3D;zhangsan</span><br><span class="line"></span><br><span class="line">&#x2F;search.do?p&#x3D;some-search-keywords&amp;name&#x3D;zhangsan&amp;name&#x3D;zhangsan           不加问号。</span><br><span class="line"></span><br><span class="line">&#x2F;search.do?p&#x3D;some-search-keywords&amp;name&#x3D;zhangsan                          加问号,会把参数删除。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>跳转</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;web&#123;</span><br><span class="line">    rewrite ^&#x2F; http:&#x2F;&#x2F;www.baidu.com;</span><br><span class="line">&#125;</span><br><span class="line">访问www.charlie.com&#x2F;web就会跳转www.baidu.com</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>热门搜索</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请求的URL	&#x2F;&#x2F;hqidi.com&#x2F;search&#x2F;some-search-keywords</span><br><span class="line">重写后URL	&#x2F;&#x2F;hqidi.com&#x2F;search.do?p&#x3D;some-search-keywords</span><br><span class="line">重写规则	        rewrite ^&#x2F;search&#x2F;(.*)$ &#x2F;search.do?p&#x3D;$1?;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用户个人资料页面</p>
<p>大多数运行访问者注册的动态网站都提供一个可以查看个人资料的页面，这个页面的URL包含用户的UID和用户名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求的URL	&#x2F;&#x2F;hqidi.com&#x2F;user&#x2F;47&#x2F;dige</span><br><span class="line">重写后URL	&#x2F;&#x2F;hqidi.com&#x2F;user.do?id&#x3D;47&amp;name&#x3D;dige</span><br><span class="line">重写规则	        rewrite ^&#x2F;user&#x2F;([0-9]+)&#x2F;(.+)$ &#x2F;user.do?id&#x3D;$1&amp;name&#x3D;$2?;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>多个参数</p>
<p>有些网站对字符串参数使用不同的语法，例如 通过斜线“/”来分隔非命名参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求的URL	&#x2F;&#x2F;hqidi.com&#x2F;index.php&#x2F;param1&#x2F;param2&#x2F;param3</span><br><span class="line">重写后URL	&#x2F;&#x2F;hqidi.com&#x2F;index.php?p1&#x3D;param1&amp;p2&#x3D;param2&amp;p3&#x3D;param3</span><br><span class="line">重写规则	        rewrite ^&#x2F;index.do&#x2F;(.*)&#x2F;(.*)&#x2F;(.*)$ &#x2F;index.do?p1&#x3D;$1&amp;p2&#x3D;$2&amp;p3&#x3D;$3?;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>类似百科的格式</p>
<p>这种格式特点，一个前缀目录，后跟文章名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求的URL	&#x2F;&#x2F;hqidi.com&#x2F;wiki&#x2F;some-keywords</span><br><span class="line">重写后URL	&#x2F;&#x2F;hqidi.com&#x2F;wiki&#x2F;index.do?title&#x3D;some-keywords</span><br><span class="line">重写规则	        rewrite ^&#x2F;wiki&#x2F;(.*)$ &#x2F;wiki&#x2F;index.do?title&#x3D;$1?;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>论坛</p>
<p>论坛一般用到两个参数，一个话题标识(topic)一个出发点(starting post)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求的URL	&#x2F;&#x2F;hqidi.com&#x2F;topic-1234-50-some-keywords.html</span><br><span class="line">重写后URL	&#x2F;&#x2F;hqidi.com&#x2F;viewtopic.do?topic&#x3D;1234&amp;start&#x3D;50</span><br><span class="line">重写规则        	rewrite ^&#x2F;topic-([0-9]+)-([0-9]+)-(.*)\.html$ viewtopic.do?topic&#x3D;$1&amp;start&#x3D;$2?;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>新网站的文章</p>
<p>这种URL结构的特点，由一个文章标识符，后跟一个斜线，和一个关键字列表组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求的URL	&#x2F;&#x2F;hqidi.com&#x2F;88&#x2F;future</span><br><span class="line">重写后URL	&#x2F;&#x2F;hqidi.com&#x2F;atricle.php?id&#x3D;88</span><br><span class="line">重写规则	        rewrite ^&#x2F;([0-9]+)&#x2F;.*$ &#x2F;aticle.do?id&#x3D;$1?;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后一个问号</p>
<p>若被替换的URI中含有参数(类似/app/test.php?id=5之类的URI)，默认情况下参数会被自动附加到替换串上，可以通过在替换串的末尾加上?标记来解决这一问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^&#x2F;users&#x2F;(.*)$ &#x2F;show?user&#x3D;$1? last;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>比较一个加上？标记和不加？标记的URL跳转区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^&#x2F;test(.*)$ &#x2F;&#x2F;hqidi.com&#x2F;home premanent;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问//hqidi.com/test?id=5 经过301跳转后的URL地址为 //hqidi.com/home?id=5</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^&#x2F;test(.*)$ &#x2F;&#x2F;hqidi.com&#x2F;home? premanent;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问//hqidi.com/test?id=5 经过301跳转后的URL地址为 //hqidi.com/home</p>
<h2 id="浏览器本地缓存配置"><a href="#浏览器本地缓存配置" class="headerlink" title="浏览器本地缓存配置"></a>浏览器本地缓存配置</h2><p>语法：expires 60 s|m|h|d</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">动静分离效果:</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root html;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location ~ \.(png|jpg|js|css|gif)$ &#123;</span><br><span class="line">        root html/images;	#静态资源文件位置</span><br><span class="line">        expires 5m;		#缓存过期时间</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Gzip压缩策略"><a href="#Gzip压缩策略" class="headerlink" title="Gzip压缩策略"></a>Gzip压缩策略</h2><p>浏览器请求 -&gt; 告诉服务端当前浏览器可以支持压缩类型-&gt;服务端会把内容根据浏览器所支持的压缩策略去进行压缩返回</p>
<p>-&gt;浏览器拿到数据以后解码；  常见的压缩方式：gzip、deflate 、sdch</p>
<p>Gzip on|off 是否开启gzip压缩<br>Gzip_buffers 4 16k</p>
<p>设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k代表以16k为单位，安装原始数据大小以16k为单位的4倍申请内存。</p>
<p>Gzip_comp_level[1-9]<br>压缩级别， 级别越高，压缩越小，但是会占用CPU资源<br>Gzip_disable #正则匹配UA 表示什么样的浏览器不进行gzip<br>Gzip_min_length 开始压缩的最小长度（小于多少就不做压缩）</p>
<p>Gzip_http_version<br>1.0|1.1 表示开始压缩的http协议版本<br>Gzip_proxied  （nginx 做前端代理时启用该选项，表示无论后端服务器的headers头返回什么信息，都无条件启用压缩）<br>Gzip_type<br>text/pliain,application/xml  对那些类型的文件做压缩 （conf/mime.conf）<br>Gzip_vary<br>on|off  是否传输gzip压缩标识</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    gzip on;	#打开gzip压缩策略</span><br><span class="line">    gzip_buffers 4 16K;</span><br><span class="line">    gzip_comp_level 7;	#压缩级别为7</span><br><span class="line">    gzip_min_length 500;</span><br><span class="line">    gzip_types text/css text/xml text/javascript;	#需要压缩的类型</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        root html;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location ~ \.(png|jpg|js|css|gif)$ &#123;</span><br><span class="line">        root html/images;</span><br><span class="line">        expires 5m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意点</strong></p>
<ol>
<li>图片、mp3这样的二进制文件，没必要做压缩处理，因为这类文件压缩比很小，压缩过程会耗费CPU资源</li>
<li>太小的文件没必要压缩，因为压缩以后会增加一些头信息，反而导致文件变大</li>
<li>Nginx默认只对text/html进行压缩 ，如果要对html之外的内容进行压缩传输，我们需要手动来配置</li>
</ol>
<h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><p>location {proxy_pass}</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;	#默认就是80端口，如果改成别的，访问需要添加端口号</span><br><span class="line">    server_name www.gerry.com;</span><br><span class="line">    </span><br><span class="line">    location =/web &#123;</span><br><span class="line">        proxy_pass http://www.baidu.com;</span><br><span class="line">    &#125;</span><br><span class="line">    location /demo/getName &#123;</span><br><span class="line">        proxy_pass http://192.168.146.220:8080; #代理会把location的地址映射到代理地址后面，反向代理只代理ip和端口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">include vhost/*.conf;  #为了简洁一般把server放在别的配置文件中</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Proxy_pass 既可以是ip地址，也可以是域名，同时还可以指定端口</p>
<p>Proxy_pass指定的地址携带了URI，看我们前面的配置【/web】，那么这里的URI将会替换请求URI中匹配location参数部分；如上代码将会访问到<a target="_blank" rel="noopener" href="http://www.baidu.com/web">http://www.baidu.com/web</a></p>
<h2 id="Nginx的负载均衡"><a href="#Nginx的负载均衡" class="headerlink" title="Nginx的负载均衡"></a>Nginx的负载均衡</h2><p><em>upstream</em>是Nginx的HTTP Upstream模块，这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡</p>
<h3 id="1、Upstream常用参数介绍"><a href="#1、Upstream常用参数介绍" class="headerlink" title="1、Upstream常用参数介绍"></a>1、Upstream常用参数介绍</h3><p><strong>语法：</strong>server address [parameters]</p>
<p>其中关键字server必选。<br> address也必选，可以是主机名、域名、ip或unix socket，也可以指定端口号。<br> parameters是可选参数，可以是如下参数：</p>
<p>​      <strong>down</strong>：表示当前server已停用</p>
<p>​      <strong>backup</strong>：表示当前server是备用服务器，只有其它非backup后端服务器都挂掉了或者很忙才会分配到请求</p>
<p>​      <strong>weight</strong>：表示当前server负载权重，权重越大被请求几率越大。默认是1</p>
<p><strong>max_fails</strong>和<strong>fail_timeout</strong>一般会关联使用，如果某台server在fail_timeout时间内出现了max_fails次连接失败，那么Nginx会认为其已经挂掉了，从而在fail_timeout时间内不再去请求它，fail_timeout默认是10s，max_fails默认是1，即默认情况是只要发生错误就认为服务器挂掉了，如果将max_fails设置为0，则表示取消这项检查。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcatserver &#123;</span><br><span class="line">    server 192.168.3.220:8080;</span><br><span class="line">    server 192.168.3.222:8080 weigth&#x3D;4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2、Upstream调度算法"><a href="#2、Upstream调度算法" class="headerlink" title="2、Upstream调度算法"></a>2、Upstream调度算法</h3><p>在做负载均衡前，我们首先需要定义一个 Server 组用来表示所有存在的后台服务：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        server backend1.example.com weight=5;</span><br><span class="line">        server backend2.example.com;</span><br><span class="line">        server 192.0.0.1 backup;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，我们需要把流量重定向到上一步定义的 backend 上去, 我们可以通过指定 proxy_pass 的值来完成这一操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    upstream backend &#123;</span><br><span class="line">        server backend1.example.com;</span><br><span class="line">        server backend2.example.com;</span><br><span class="line">        server 192.0.0.1 backup;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里我们将所有的流量重定向到 <a href="https://link.juejin.im/?target=http://backend">http://backend</a> , 这将这个 NGINX 实例上的所有流量重定向到之前定义的 backend 上去。</p>
<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><p>当没有指定任何信息时， NGINX 默认使用了 Round Robin(轮询)算法来重定向流量。其实 NGINX 提供了多种算法来做负载均衡，下面我们来介绍一下：</p>
<h3 id="1、Round-Robin-轮询-默认方式"><a href="#1、Round-Robin-轮询-默认方式" class="headerlink" title="1、Round Robin (轮询)默认方式"></a>1、Round Robin (轮询)默认方式</h3><p>在没有指定 weight(权重) 的情况下，Round Robin 会将所有请求均匀地分发给所有后台服务实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里我们没有指定权重，所以两个后台服务会收到等量的请求。但是，当指定了权重之后，NGINX 就会将权重考虑在内：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com weight&#x3D;5;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 NGINX 中，weight 默认被设置为 1。这里我们用一开始的配置举例， <a href="https://link.juejin.im/?target=http://backend1.example.com">backend1.example.com</a> 的权重被设置为 5，另一个的权重没设置，所以是默认值 1。我们也没有设置轮询算法，所以这时候 NGINX 会以 5：1 的比例转发请求，即 6 个请求中， 5 个被放到了 <a href="https://link.juejin.im/?target=http://backend1.example.com">backend1.example.com</a> 上， 有一个被发到了 <a href="https://link.juejin.im/?target=http://backend2.example.com">backend2.example.com</a> 上。</p>
<h3 id="2、Least-Connections（最少连接算法）"><a href="#2、Least-Connections（最少连接算法）" class="headerlink" title="2、Least Connections（最少连接算法）"></a>2、Least Connections（最少连接算法）</h3><p>在这个模式下，一个请求会被 NGINX 转发到当前<u>活跃请求数量最少</u>的服务实例上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们用 least_conn 来指定最少连接优先算法, NGINX 会优先转发请求到现有连接数少的那一个服务实例上。</p>
<h3 id="3、IP-Hash-IP-哈希"><a href="#3、IP-Hash-IP-哈希" class="headerlink" title="3、IP Hash (IP 哈希)"></a>3、IP Hash (IP 哈希)</h3><p>在 IP Hash 模式下，NGINX 会根据发送请求的 IP 地址的 hash 值来决定将这个请求转发给哪个后端服务实例。被 hash 的 IP 地址要么是 IPv4 地址的前三个 16 进制数或者是整个 IPv6 地址。使用这个模式的负载均衡模式可以保证<u>来自同一个 IP 的请求被转发到同一个服务实例上</u>。当然，这种方法在某一个后端实例发生故障时候会导致一些节点的访问出现问题(不具有hash一致性)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果某一台服务器出现故障或者无法进行服务，我们可以给它标记上 down，这样之前被转发到这台服务器上的请求就会重新进行 hash 计算并转发到新的服务实例上:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">    server backend3.example.com down;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4、Generic-Hash-通用哈希"><a href="#4、Generic-Hash-通用哈希" class="headerlink" title="4、Generic Hash(通用哈希)"></a>4、Generic Hash(通用哈希)</h3><p>这个模式允许管理员自定义 hash 函数的输入，比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    hash $reqeust_uri consistent;</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们以请求中所带的 url 为 hash 的输入。 注意到这里在 hash 那一行的最后加入了 consistent 这个关键词。这个关键词会使用一种新的 hash 算法 <a href="https://link.juejin.im/?target=https://www.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients">ketama</a>, 该算法会让管理员添加或删除某个服务实例的时候，只有一小部分的请求会被转发到与之前不同的服务实例上去，其他请求仍然会被转发到原有的服务实例上去。</p>
<h3 id="5、Random-随机算法"><a href="#5、Random-随机算法" class="headerlink" title="5、Random (随机算法)"></a>5、Random (随机算法)</h3><p>顾名思义，每个请求都被随机发送到某个服务实例上去:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    random;</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">    server backend3.example.com;</span><br><span class="line">    server backend4.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Random 模式还提供了一个参数 two，当这个参数被指定时，NGINX 会先随机地选择两个服务器(考虑 weight)，然后用以下几种方法选择其中的一个服务器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. least_conn: 最少连接数</span><br><span class="line">2. least_time&#x3D;header(NGINX PLUS only): 接收到 response header 的最短平均时间</span><br><span class="line">3. least_time&#x3D;last_byte(NGINX PLUS only): 接收到完整请求的最短平均时间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以参考下面的一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    random two least_time&#x3D;last_byte;</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">    server backend3.example.com;</span><br><span class="line">    server backend4.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当环境中有多个负载均衡服务器在向后端服务转发请求时，我们可以考虑使用 Random 模式，在只有单个负载均衡服务器时，一般不建议使用 Random 模式。</p>
<h3 id="6、Least-Time-NGINX-PLUS-only"><a href="#6、Least-Time-NGINX-PLUS-only" class="headerlink" title="6、Least Time (NGINX PLUS only)"></a>6、Least Time (NGINX PLUS only)</h3><p>这是一个 NGINX PLUS (NGINX 的付费版) 才有的模式，可以将请求优先转发给平均响应时间较短的服务实例，它也有三个模式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. header: 从服务器接收到第一个字节的时间</span><br><span class="line">2. last_byte: 从服务器接收到完整的 response 的时间</span><br><span class="line">3. last_byte inflight: 从服务器接收到完整地 response 的时间（考虑不完整的请求）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例子如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    least_time header;</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server  backend2.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Nginx的HA配置"><a href="#Nginx的HA配置" class="headerlink" title="Nginx的HA配置"></a>Nginx的HA配置</h2><ul>
<li>将Nginx远程拷贝到多个主机上,安装Nginx及其依赖</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp nginx-1.14.2.tar.gz 192.168.146.221:/root/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>KeepAlived的安装和配置</li>
</ul>
<p>1、安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install keepalived</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、/etc/keepalived/keepalived.conf配置文件配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">    notification_mail &#123;</span><br><span class="line">        ## 指定keepalived在发生切换时需要发送的邮箱</span><br><span class="line">    &#125;</span><br><span class="line">    notification_mail_from xxx@xxx.com #发件人</span><br><span class="line">    #smtp_server xxx.smtp.com</span><br><span class="line">    #smtp_connect_timeout 30</span><br><span class="line">    router_id LVS_MAIN #运行keepalived机器的一个标识</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance_VI_1 &#123;</span><br><span class="line">    state MASTER # 标识为主为master，备为backup</span><br><span class="line">    interface ens33 #设置实例绑定的网卡</span><br><span class="line">    virtual_router_id 51 # 同一个实例下的virtual_router_id必须相同</span><br><span class="line">    priority 100 # master的权重必须大于backup</span><br><span class="line">    advert_int 1 # master与backup负载均衡器之间同步检测的时间间隔，单位秒</span><br><span class="line">    authentication &#123; #设置认证</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 123</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    virtual_ipaddress &#123; #设置vip</span><br><span class="line">        192.168.3.111</span><br><span class="line">        192.168.3.112 #可以设置多个虚拟IP</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3、启动 /etc/init.d/keepalived start或者systemctl start keepalived</p>
<p>Session共享问题解决方案:<br>由于请求先通过Nginx代理服务器,再有nginx服务器分配请求到具体的应用服务器中间就会遇到Session共享问题:</p>
<p>1.ip_hash 根据ip分配请求的应用服务器</p>
<p>2.不使用session,换cookie就不会存在此问题,但是网站安全度降低</p>
<p>3.使用cookie和redis缓存(建议此方案,方便扩展,缓存中速度高效)【会在后面项目中讲】</p>
<p> 例如:生成一个uuid作为用户信息的key存放在redis缓存中,再将uuid作为cookie的值写会客户端,cookie的key可以用固定值(常量)</p>
<p>4、jwt</p>
<p>5.放到MySQL数据库中,不推荐(增加数据库的io)</p>
<h2 id="Nginx的HTTPS配置"><a href="#Nginx的HTTPS配置" class="headerlink" title="Nginx的HTTPS配置"></a>Nginx的HTTPS配置</h2><h2 id="一、HTTPS简介"><a href="#一、HTTPS简介" class="headerlink" title="一、HTTPS简介"></a>一、HTTPS简介</h2><blockquote>
<p>1.https简介</p>
<p>HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据</p>
<p>2.https协议原理</p>
<p>首先，客户端与服务器建立连接，各自生成私钥和公钥，是不同的。服务器返给客户端一个公钥，然后客户端拿着这个公钥把要搜索的东西加密，称之为密文，并连并自己的公钥一起返回给服务器，服务器拿着自己的私钥解密密文，然后把响应到的数据用客户端的公钥加密，返回给客户端，客户端拿着自己的私钥解密密文，把数据呈现出来</p>
</blockquote>
<h2 id="二、开启nginx的ssl模块"><a href="#二、开启nginx的ssl模块" class="headerlink" title="二、开启nginx的ssl模块"></a>二、开启nginx的ssl模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.the &quot;ssl&quot; parameter requires ngx_http_ssl_module  in &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:37</span><br><span class="line">原因是nginx缺少http_ssl_module模块，编译安装时带上--with-http_ssl_module配置就可以了</span><br><span class="line">2.如果已经安装过nginx,想要添加模块看下面</span><br><span class="line">1)切换到nginx源码包</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx-1.11.3</span><br><span class="line">2)查看ngixn原有的模块</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -V</span><br><span class="line">3)重新配置</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_stub_status_module --with-http_ssl_module</span><br><span class="line">4)重新编译，不需要make  install安装。否则会覆盖</span><br><span class="line">make -j4</span><br><span class="line">5)备份原有已经安装好的nginx</span><br><span class="line">cp &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx.bak</span><br><span class="line">6)将刚刚编译好的nginx覆盖掉原来的nginx(ngixn必须停止)</span><br><span class="line">cp .&#x2F;objs&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F; </span><br><span class="line">这时，会提示是否覆盖，请输入yes，直接回车默认不覆盖</span><br><span class="line">7)启动nginx，查看nginx模块，发现已经添加</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -V　</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="三、证书和私钥的生成"><a href="#三、证书和私钥的生成" class="headerlink" title="三、证书和私钥的生成"></a>三、证书和私钥的生成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">注意：一般生成的目录,应该放在nginx&#x2F;conf&#x2F;ssl目录下</span><br><span class="line"></span><br><span class="line">1.创建服务器证书密钥文件 server.key：</span><br><span class="line">openssl genrsa -des3 -out server.key 1024</span><br><span class="line"></span><br><span class="line">然后输入密码，确认密码，自己随便定义，但是要记住，后面会用到。</span><br><span class="line"></span><br><span class="line">2.创建服务器证书的申请文件 server.csr</span><br><span class="line"></span><br><span class="line">openssl req -new -key server.key -out server.csr</span><br><span class="line"></span><br><span class="line">输出内容为：</span><br><span class="line">Enter pass phrase for root.key: ← 输入前面创建的密码 </span><br><span class="line">Country Name (2 letter code) [AU]:CN ← 国家代号，中国输入CN </span><br><span class="line">State or Province Name (full name) [Some-State]:BeiJing ← 省的全名，拼音 </span><br><span class="line">Locality Name (eg, city) []:BeiJing ← 市的全名，拼音 </span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:MyCompany Corp. ← 公司英文名 </span><br><span class="line">Organizational Unit Name (eg, section) []: ← 可以不输入 </span><br><span class="line">Common Name (eg, YOUR name) []: ← 此时不输入 </span><br><span class="line">Email Address []:admin@mycompany.com ← 电子邮箱，可随意填</span><br><span class="line">Please enter the following ‘extra’ attributes </span><br><span class="line">to be sent with your certificate request </span><br><span class="line">A challenge password []: ← 可以不输入 </span><br><span class="line">An optional company name []: ← 可以不输入</span><br><span class="line"></span><br><span class="line">4.备份一份服务器密钥文件</span><br><span class="line"></span><br><span class="line">cp server.key server.key.org</span><br><span class="line"></span><br><span class="line">5.去除文件口令</span><br><span class="line">openssl rsa -in server.key.org -out server.key</span><br><span class="line"></span><br><span class="line">6.生成证书文件server.crt</span><br><span class="line">openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="四、配置文件"><a href="#四、配置文件" class="headerlink" title="四、配置文件"></a>四、配置文件</h2><p>proxyPort=443</p>
<p>redirectPort=443</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">       #比起默认的80 使用了443 默认 是ssl方式  多出default之后的ssl</span><br><span class="line">       listen 443 default ssl;</span><br><span class="line">       #default 可省略</span><br><span class="line">	   #开启  如果把ssl on；这行去掉，ssl写在443端口后面。这样http和https的链接都可以用</span><br><span class="line">       ssl on;</span><br><span class="line">	   #证书(公钥.发送到客户端的)</span><br><span class="line">       ssl_certificate ssl&#x2F;server.crt;</span><br><span class="line">	   #私钥,</span><br><span class="line">       ssl_certificate_key ssl&#x2F;server.key;</span><br><span class="line">	   #下面是绑定域名</span><br><span class="line">        server_name www.gerry.com;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">			#禁止跳转</span><br><span class="line">        	proxy_redirect off;</span><br><span class="line">			#代理</span><br><span class="line">			proxy_pass https:&#x2F;&#x2F;www.gerry.com;  </span><br><span class="line">        &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重启Nginx</p>
<h2 id="Nginx状态监控"><a href="#Nginx状态监控" class="headerlink" title="Nginx状态监控"></a>Nginx状态监控</h2><p>配置server</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1554453933519.png" alt="1554453933519"></p>
<p>然后通过<a target="_blank" rel="noopener" href="http://www.gerry.com:8888/myStatus%E8%AE%BF%E9%97%AE">www.gerry.com:8888/myStatus访问</a></p>
<h2 id="Nginx进程模型"><a href="#Nginx进程模型" class="headerlink" title="Nginx进程模型"></a>Nginx进程模型</h2><h2 id="一、进程模型"><a href="#一、进程模型" class="headerlink" title="一、进程模型"></a>一、进程模型</h2><p>​       Nginx是经典的多进程模型。Nginx启动后以daemon的方式在后台运行，后台进程包含一个master进程和多个worker进程，具体如下图：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1554472726128.png" alt="1554472726128"></p>
<p>图1 Nginx多进程模型</p>
<p>​        master进程主要用来管理worker进程，具体包括如下4个主要功能：<br>​        （1）接收来自外界的信号。<br>​        （2）向各worker进程发送信号。<br>​        （3）监控woker进程的运行状态。<br>​        （4）当woker进程退出后（异常情况下），会自动重新启动新的woker进程。<br>​        woker进程主要用来处理网络事件，各个woker进程之间是对等且相互独立的，它们同等竞争来自客户端的请求，一个请求只可能在一个woker进程中处理，woker进程个数一般设置为机器CPU核数。</p>
<h2 id="二、进程控制"><a href="#二、进程控制" class="headerlink" title="二、进程控制"></a>二、进程控制</h2><p>​        对Nginx进程的控制主要是通过master进程来做到的，主要有两种方式：<br>​        （1）手动发送信号<br>​        从图1可以看出，master接收信号以管理众woker进程，那么，可以通过kill向master进程发送信号，比如kill -HUP pid用以通知Nginx从容重启。所谓从容重启就是不中断服务：master进程在接收到信号后，会先重新加载配置，然后再启动新进程开始接收新请求，并向所有老进程发送信号告知不再接收新请求并在处理完所有未处理完的请求后自动退出。<br>​        （2）自动发送信号<br>​        可以通过带命令行参数启动新进程来发送信号给master进程，比如./nginx -s reload用以启动一个新的Nginx进程，而新进程在解析到reload参数后会向master进程发送信号（新进程会帮我们把手动发送信号中的动作自动完成）。当然也可以这样./nginx -s stop来停止Nginx。</p>
<p><strong>三、网络事件</strong><br>​         Nginx采用异步非阻塞的方式来处理网络事件</p>
<p>master进程先建好需要listen的socket后，然后再fork出多个woker进程，这样每个work进程都可以去accept这个socket。当一个client连接到来时，所有accept的work进程都会受到通知，但只有一个进程可以accept成功，其它的则会accept失败。Nginx提供了一把共享锁accept_mutex来保证同一时刻只有一个work进程在accept连接，从而解决惊群问题。当一个worker进程accept这个连接后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完成的请求就结束了。</p>
<h2 id="Nginx配置udp-tcp代理"><a href="#Nginx配置udp-tcp代理" class="headerlink" title="Nginx配置udp/tcp代理"></a>Nginx配置udp/tcp代理</h2><p>1、安装模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx  --with-stream  --with-http_stub_status_module</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#nginx.conf部分配置</span><br><span class="line"># upd&#x2F;tcp</span><br><span class="line">stream &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        server 192.168.3.173:3306;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8686;</span><br><span class="line">        proxy_connect_timeout 8s;</span><br><span class="line">        proxy_timeout 24h;   #代理超时</span><br><span class="line">        proxy_pass backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h2 id="一、为什么要分库分表"><a href="#一、为什么要分库分表" class="headerlink" title="一、为什么要分库分表"></a>一、为什么要分库分表</h2><ol>
<li>数据库是有IO瓶颈的<ul>
<li>热点数据量大时，数据库缓存放不下，每次查询产生大量<u>磁盘IO</u>，降低查询效率-&gt;分库和垂直分表</li>
<li>请求的数据过多，带宽不够，<u>网络IO</u>拥堵-&gt;分库</li>
</ul>
</li>
<li>CPU有限制<ul>
<li>sql语句中包含的函数【jion、group by、count…】或非索引字段作查询条件-&gt;SQL优化</li>
<li>单表数据量大，SQL执行效率低下-&gt;水平分表</li>
</ul>
</li>
</ol>
<h2 id="二、怎么做数据切分"><a href="#二、怎么做数据切分" class="headerlink" title="二、怎么做数据切分"></a>二、怎么做数据切分</h2><h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><ul>
<li>让某个<strong>字段</strong>按照一定的策略(hash,range,ting)，将一个<strong>库</strong>中的数据拆分到多个库中</li>
<li>每个数据库的结构都一样，数据都不一样</li>
<li>所有数据库中的数据并集就是全量</li>
</ul>
<p>场景：单表数据量过多，表扫描慢，单机遇到瓶颈</p>
<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><ul>
<li>让<strong>表</strong>按照不同的业务划分，拆分到不同的数据库中，实现服务化</li>
<li>每个数据库的结构不一样，数据也不一样</li>
</ul>
<p>场景：实现服务化，解决数据库中表过多的问题</p>
<h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><ul>
<li>让某个<strong>字段</strong>按照一定的策略(hash,range,ting)，将一个<strong>表</strong>中的数据拆分到多个表中</li>
<li>每个表的结构都一样，数据都不一样</li>
<li>所有表中的数据并集就是全量</li>
</ul>
<p>场景：单表数据量过多，表扫描慢</p>
<h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><ul>
<li>以<strong>字段</strong>为依据，按照字段的活跃性(热字段冷字段)或字段大小(text可单独拆)，将<strong>表</strong>中字段拆分到不同的表中</li>
<li>每个表的结构不一样，数据也不一样</li>
<li>字段至少有一列交集，用于关联数据</li>
</ul>
<p>场景：单条记录字段多，并且热点数据和非热点数据混合的情况</p>
<h2 id="三、分库分表带来的问题"><a href="#三、分库分表带来的问题" class="headerlink" title="三、分库分表带来的问题"></a>三、分库分表带来的问题</h2><h3 id="1、事务一致性问题"><a href="#1、事务一致性问题" class="headerlink" title="1、事务一致性问题"></a>1、事务一致性问题</h3><ol>
<li><p><strong>分布式事务</strong></p>
<p>当更新内容同时分布在不同库中，不可避免会带来跨库事务问题。跨分片事务也是分布式事务，没有简单的方案，一般可使用“XA协议”和“两阶段提交”处理。</p>
<p>分布式事务能最大限度保证数据库操作的原子性。但在提交事务时需要协调多个节点，推后了提交事务的时间点，延长了事务的执行时间，导致事务在访问共享资源时发生冲突或死锁的概率增高。</p>
<p>随着数据库节点的增多，这种趋势会越来越严重，从而成为系统在数据库层面上水平扩展的枷锁。</p>
</li>
<li><p><strong>最终一致性</strong>（MQ(消息表)，RocketMQ【half message，回查机制】）</p>
<p>对于那些性能要求很高，但对一致性要求不高的系统，往往不苛求系统的实时一致性，只要在允许的时间段内达到最终一致性即可，可采用事务补偿的方式。</p>
<p>与事务在执行中发生错误后立即回滚的方式不同，事务补偿是一种事后检查补救的措施，一些常见的实现方法有：对数据进行对账检查；基于日志进行对比；定期同标准数据来源进行同步等。事务补偿还要结合业务系统来考虑。</p>
</li>
</ol>
<h3 id="2、-跨节点关联查询-join-问题"><a href="#2、-跨节点关联查询-join-问题" class="headerlink" title="2、 跨节点关联查询 join 问题"></a>2、 跨节点关联查询 join 问题</h3><p>切分之前，系统中很多列表和详情页所需的数据可以通过sql join来完成。而切分之后，数据可能分布在不同的节点上，此时join带来的问题就比较麻烦了，考虑到性能，尽量避免使用join查询。</p>
<p>解决这个问题的一些方法：</p>
<ol>
<li><strong>全局表</strong></li>
</ol>
<p>全局表，也可看做是“数据字典表”，就是系统中所有模块都可能依赖的一些表，为了避免跨库join查询，可以将这类表在每个数据库中都保存一份。这些数据通常很少会进行修改，所以也不担心一致性的问题。</p>
<ol>
<li><strong>字段冗余</strong></li>
</ol>
<p>一种典型的反范式设计，利用空间换时间，为了性能而避免join查询。例如：订单表保存userId时候，也将userName冗余保存一份，这样查询订单详情时就不需要再去查询“买家user表”了。</p>
<p>但这种方法适用场景也有限，比较适用于依赖字段比较少的情况。而冗余字段的数据一致性也较难保证，就像上面订单表的例子，买家修改了userName后，是否需要在历史订单中同步更新呢？这也要结合实际业务场景进行考虑。</p>
<ol>
<li><strong>数据组装</strong></li>
</ol>
<p>在系统层面，分两次查询，第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据，跨库可以使用dubbo或ribbon等进行通信。最后将获得到的数据进行字段拼装。</p>
<ol>
<li><strong>ER分片</strong></li>
</ol>
<p>关系型数据库中，如果可以先确定表之间的关联关系，并将那些存在关联关系的表记录存放在同一个分片上，那么就能较好的避免跨分片join问题。一般在1:1或1:n的情况下</p>
<h3 id="3-跨节点分页、排序、函数问题"><a href="#3-跨节点分页、排序、函数问题" class="headerlink" title="3.跨节点分页、排序、函数问题"></a>3.跨节点分页、排序、函数问题</h3><p>跨节点多库进行查询时，会出现limit分页、order by排序等问题。</p>
<p>分页需要按照指定字段进行排序，当排序字段就是分片字段时，通过分片规则就比较容易定位到指定的分片；当排序字段非分片字段时，就变得比较复杂了，需要先在不同的分片节点中将数据进行排序并返回(前10条)，然后将不同分片返回的结果集进行汇总和再次排序(整合后前10条)，最终返回给用户。</p>
<p>只是取第一页的数据，对性能影响还不是很大。但是如果取得页数很大，情况则变得复杂很多。因为各分片节点中的数据可能是随机的，为了排序的准确性，需要将所有节点的前N页数据都排序好做合并，最后再进行整体的排序，这样的操作时很耗费CPU和内存资源的，所以页数越大，系统的性能也会越差。</p>
<p>在使用Max、Min、Sum、Count之类的函数进行计算的时候，也需要先在每个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终将结果返回。</p>
<h3 id="4-全局主键避重问题"><a href="#4-全局主键避重问题" class="headerlink" title="4.全局主键避重问题"></a>4.全局主键避重问题</h3><p>在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库自生成的ID无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题。有一些常见的主键生成策略：</p>
<p><strong>1）UUID</strong><br>UUID标准形式包含32个16进制数字，分为5段，形式为8-4-4-4-12的36个字符，例如：550e8400-e29b-41d4-a716-446655440000。</p>
<p>UUID是主键是最简单的方案，本地生成、性能高、没有网络耗时。但缺点也很明显：由于UUID非常长，会占用大量的存储空间；另外，作为主键建立索引和基于索引进行查询时都会存在性能问题，在InnoDB下，UUID的无序性会引起数据位置频繁变动，导致分页。</p>
<p><strong>2）Snowflake分布式自增ID算法</strong><br>Twitter的snowflake算法解决了分布式系统生成全局ID的需求，生成64位的Long型数字，组成部分：</p>
<ul>
<li>第一位未使用</li>
<li>接下来41位是毫秒级时间，41位的长度可以表示69年的时间</li>
<li>5位datacenterId，5位workerId。10位的长度最多支持部署1024个节点</li>
<li>最后12位是毫秒内的计数，12位的计数顺序号支持每个节点每毫秒产生4096个ID序列</li>
</ul>
<p><img src="D:\Typora\resources\app\asserts\icon\1556204774175.png" alt="1556204774175"></p>
<p>这样的好处是：毫秒数在高位，生成的ID整体上按时间趋势递增；不依赖第三方系统，稳定性和效率较高，理论上QPS约为409.6w/s（1000*2^12），并且整个分布式系统内不会产生ID碰撞；可根据自身业务灵活分配bit位。</p>
<p>不足就在于：强依赖机器时钟，如果时钟回拨，则可能导致生成ID重复。</p>
<p><strong>3）表添加表号字段</strong></p>
<p><strong>4）通过redis或数据库自增一个值作为id</strong></p>
<h3 id="5-数据迁移、扩容问题（项目后期）"><a href="#5-数据迁移、扩容问题（项目后期）" class="headerlink" title="5 .数据迁移、扩容问题（项目后期）"></a>5 .数据迁移、扩容问题（项目后期）</h3><p>当业务高速发展，面临性能和存储的瓶颈时，才会考虑分片设计，此时就不可避免的需要考虑历史数据迁移的问题。一般做法是先读出历史数据，然后按指定的分片规则再将数据写入到各个分片节点中。（非常麻烦）</p>
<p>此外，还需要根据当前的数据量和QPS，以及业务发展的速度，进行容量规划，推算出大概需要多少分片（一般建议单个分片上的单表数据量不超过1000W【经验】）。</p>
<p>如果采用数值范围分片，只需要添加节点就可以进行扩容了，不需要对分片数据迁移。如果采用的是数值取模分片，则考虑后期的扩容问题就相对比较麻烦。</p>
<h2 id="四、什么时候考虑切分"><a href="#四、什么时候考虑切分" class="headerlink" title="四、什么时候考虑切分"></a>四、什么时候考虑切分</h2><p>下面讲述一下什么时候需要考虑做数据切分。</p>
<h3 id="1、-能不切分尽量不要切分"><a href="#1、-能不切分尽量不要切分" class="headerlink" title="1、 能不切分尽量不要切分"></a>1、 能不切分尽量不要切分</h3><p>并不是所有表都需要进行切分，主要还是看数据的增长速度。切分后会在某种程度上提升业务的复杂度，数据库除了承载数据的存储和查询外，协助业务更好的实现需求也是其重要工作之一。</p>
<p>不到万不得已不用轻易使用分库分表这个大招，避免”过度设计”和”过早优化”。分库分表之前，不要为分而分，先尽力去做力所能及的事情，例如：升级硬件、升级网络、读写分离、索引优化等等。当数据量达到单表的瓶颈时候，再考虑分库分表。</p>
<h3 id="2、-数据量过大，正常运维影响业务访问"><a href="#2、-数据量过大，正常运维影响业务访问" class="headerlink" title="2、 数据量过大，正常运维影响业务访问"></a>2、 数据量过大，正常运维影响业务访问</h3><p>这里说的运维，指：</p>
<ul>
<li>对数据库备份，如果单表太大，备份时需要大量的磁盘IO和网络IO。例如1T的数据，网络传输占50MB时候，需要20000秒才能传输完毕，整个过程的风险都是比较高的；</li>
<li>对一个很大的表进行DDL修改时，MySQL会锁住全表，这个时间会很长，这段时间业务不能访问此表，影响很大。如果使用pt-online-schema-change，使用过程中会创建触发器和影子表，也需要很长的时间。在此操作过程中，都算为风险时间。将数据表拆分，总量减少，有助于降低这个风险。</li>
<li>大表会经常访问与更新，就更有可能出现锁等待。将数据切分，用空间换时间，变相降低访问压力。</li>
</ul>
<h3 id="3、-随业务发展需对某些字段垂直拆分"><a href="#3、-随业务发展需对某些字段垂直拆分" class="headerlink" title="3、 随业务发展需对某些字段垂直拆分"></a>3、 随业务发展需对某些字段垂直拆分</h3><p>举个例子，假如项目一开始设计的用户表如下：</p>
<p>id bigint #用户的ID<br>name varchar #用户的名字<br>last_login_time datetime #最近登录时间<br>personal_info text #私人信息<br>…… #其他信息字段</p>
<p>在项目初始阶段，这种设计是满足简单的业务需求的，也方便快速迭代开发。而当业务快速发展时，用户量从10w激增到10亿，用户非常的活跃，每次登录会更新 last_login_time 字段，使得 user 表被不断update，压力很大。</p>
<p>而其他字段：id, name, personal_info 是不变的或很少更新的，此时在业务角度，就要将 last_login_time 拆分出去，新建一个 user_time 表。</p>
<p>personal_info 属性是更新和查询频率较低的，并且text字段占据了太多的空间。这时候，就要对此垂直拆分出 user_ext 表了。</p>
<h3 id="4-、数据量快速增长"><a href="#4-、数据量快速增长" class="headerlink" title="4 、数据量快速增长"></a>4 、数据量快速增长</h3><p>随着业务的快速发展，单表中的数据量会持续增长，当性能接近瓶颈时，就需要考虑水平切分，做分库分表了。此时一定要选择合适的切分规则，提前预估好数据容量。</p>
<h3 id="5、-安全性和可用性"><a href="#5、-安全性和可用性" class="headerlink" title="5、 安全性和可用性"></a>5、 安全性和可用性</h3><p>鸡蛋不要放在一个篮子里。</p>
<p>在业务层面上垂直切分，将不相关的业务的数据库分隔，因为每个业务的数据量、访问量都不同，不能因为一个业务把数据库搞挂而牵连到其他业务。</p>
<p>利用水平切分，当一个数据库出现问题时，不会影响到100%的用户，每个库只承担业务的一部分数据，这样整体的可用性就能提高。</p>
<h1 id="MySQL主从配置"><a href="#MySQL主从配置" class="headerlink" title="MySQL主从配置"></a>MySQL主从配置</h1><h2 id="一、MySQL主从原理"><a href="#一、MySQL主从原理" class="headerlink" title="一、MySQL主从原理"></a>一、MySQL主从原理</h2><p><img src="D:\Typora\resources\app\asserts\icon\7928684-3959f914f4270b82.png" alt="7928684-3959f914f4270b82"></p>
<p><strong>大概执行流程：</strong></p>
<p>Master执行完增删改操作后都会记录binlog日志,当需要同步的时候会主动通知slave节点,slave收到通知后使用<code>IO Thread</code>主动去master读取<code>binlog日志</code>,然后异步写入<code>relay</code>日志(中转日志),然后使 <code>SQL Thread</code>完成对<code>relay日志  </code>的解析然后入库操作,完成同步</p>
<h2 id="二-配置MySQL主从具体实现（MYSQL5-7）"><a href="#二-配置MySQL主从具体实现（MYSQL5-7）" class="headerlink" title="二. 配置MySQL主从具体实现（MYSQL5.7）"></a>二. 配置MySQL主从具体实现（MYSQL5.7）</h2><h3 id="1-在服务器上面安装2个MySQL数据库"><a href="#1-在服务器上面安装2个MySQL数据库" class="headerlink" title="1. 在服务器上面安装2个MySQL数据库"></a>1. 在服务器上面安装2个MySQL数据库</h3><ul>
<li><p>通过命令下载rpm文件</p>
<p>wget <a target="_blank" rel="noopener" href="https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm">https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</a></p>
</li>
<li><p>安装mysql</p>
<p>rpm -ivh mysql57-community-release-el7-11.noarch.rpm</p>
</li>
<li><p>安装数据库</p>
<p>yum install mysql-community-server</p>
<p>可以通过cat /etc/my.cnf查看mysql数据文件、日志文件和mysqld文件的默认位置</p>
</li>
<li><p>查看mysql 初始化密码</p>
<p>先启动mysql服务:service mysqld start或systemctl start mysqld</p>
<p>cat /var/log/mysqld.log |grep password （查看初始密码）</p>
</li>
<li><p>使用初始密码登录mysql，设置密码策略</p>
<p>set global validate_password_length=1;</p>
<p>set global validate_password_policy=0;</p>
</li>
<li><p>更新密码</p>
<p>update mysql.user set authentication_string=password(‘123’) where user=’root’;</p>
</li>
<li><p>授权远程登录</p>
<p>GRANT ALL PRIVILEGES ON <code>*.*</code> TO ‘root’@’%’ IDENTIFIED BY ‘123’ WITH GRANT OPTION;  </p>
<p>FLUSH PRIVILEGES; 刷新权限</p>
</li>
</ul>
<h3 id="2-Master机器配置"><a href="#2-Master机器配置" class="headerlink" title="2. Master机器配置"></a>2. Master机器配置</h3><p>修改 /etc/my.cnf添加log_bin日志</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开log-bin日志添加以下信息</span></span><br><span class="line">server_id=1</span><br><span class="line">log_bin=master-bin # 打开二进制日志</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置完成保存后，重启mysql服务器，再次登录MySQL服务器</p>
<blockquote>
<p>systemctl restart mysqld</p>
<p>登录mysql执行 show master status;     ## 查看主服务器log-bin日志</p>
<p>记录下File的名称和Position的位置：</p>
<p>File = master-bin.000001</p>
<p>Position = 154</p>
</blockquote>
<h3 id="3-Slave机器配置"><a href="#3-Slave机器配置" class="headerlink" title="3. Slave机器配置"></a>3. Slave机器配置</h3><p>修改 /etc/my.cnf添加relay_log日志</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 打开relay-log日志</span></span></span><br><span class="line">server_id=2</span><br><span class="line">relay-log=slave-relay-bin</span><br><span class="line">relay-log-index=slave-relay-bin.index</span><br><span class="line">read_only=1 # 只读</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置完成保存后，重启mysql服务器，再次登录MySQL服务器</p>
<blockquote>
<p>systemctl restart mysqld</p>
<p>解决Connection xxxx. reties 18 异常：</p>
<p>在master端创建同步的账号（u_replication）和密码（123）</p>
<p>create user u_replication identified by ‘123’;</p>
<p>grant replication slave on *.* to ‘u_replication’@’%’;</p>
<p>flush privileges;</p>
<p>在从服务器登录mysql并执行如下的SQL:</p>
<p>change master to master_host=’192.168.146.220’,master_port=3306,master_user=’u_replication’,master_password=’123’,master_log_file=’master-bin.000001’,master_log_pos=154;</p>
<p>NOTE:这两个参数master_log_file=master-bin.000001,master_log_pos=154必须和主库一致</p>
</blockquote>
<h3 id="4-启动主从配置（在从服务上执行）"><a href="#4-启动主从配置（在从服务上执行）" class="headerlink" title="4. 启动主从配置（在从服务上执行）"></a>4. 启动主从配置（在从服务上执行）</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> <span class="string">start slave</span></span><br><span class="line"><span class="comment">## 检测是否配置成功</span></span><br><span class="line"><span class="meta">mysql&gt;</span> <span class="string">show slave status \G </span></span><br><span class="line"><span class="comment">### 解决这个异常</span></span><br><span class="line"><span class="attr">原因：虚拟机复制的UUIDS可能相同</span></span><br><span class="line"><span class="attr">Fatal</span> <span class="string">error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.</span></span><br><span class="line"><span class="comment">#解决方式: </span></span><br><span class="line"><span class="comment">#1、查看server_id是否相同 </span></span><br><span class="line"><span class="attr">show</span> <span class="string">variables like &#x27;server_id&#x27;;</span></span><br><span class="line"><span class="comment">#2、查看auto.cnf文件</span></span><br><span class="line"><span class="attr">show</span> <span class="string">variables like &#x27;server_uuid&#x27;; ##发现一样</span></span><br><span class="line"><span class="attr">cat</span> <span class="string">/var/lib/mysql/auto.cnf </span></span><br><span class="line"><span class="comment">### 下面操作在从服务上执行 （位置可能不同可以使用命令: find / -name &quot;auto.cnf&quot;查找文件 ）</span></span><br><span class="line"><span class="attr">mv</span> <span class="string">/var/lib/mysql/auto.cnf  /var/lib/mysql/auto.cnf.bk  ###重命名该文件</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">restart mysql</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>开启远程访问:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建用户、密码及权限范围 第一个 roo t为用户名 @后为适用的主机，‘%’表示所有电脑都可以访问连接，第二个 root 为密码</span></span><br><span class="line">mysql<span class="operator">&gt;</span><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 立即生效</span></span><br><span class="line">mysql<span class="operator">&gt;</span> flush privileges;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查询binlog</p>
<p>show binlog events in ‘mysql-bin-000001’</p>
<p>show variables like ‘%log%’;</p>
<p>mysqlbinlog –base64-output=decode-rows -v ‘mysql-bin-000001’</p>
<p>模式：</p>
<p>statement 基于SQL语句模式</p>
<p>row 基于行模式，记录修改以后每一条记录变化的值</p>
<p>mixed  混合模式，由mysql自动判断处理</p>
<p>设置</p>
<p>set global binlog_format=’row/mixed/statement’</p>
<h1 id="MyCat数据库中间件"><a href="#MyCat数据库中间件" class="headerlink" title="MyCat数据库中间件"></a>MyCat数据库中间件</h1><h2 id="一、MyCat的介绍"><a href="#一、MyCat的介绍" class="headerlink" title="一、MyCat的介绍"></a>一、MyCat的介绍</h2><h3 id="1、什么是MYCAT"><a href="#1、什么是MYCAT" class="headerlink" title="1、什么是MYCAT"></a>1、什么是MYCAT</h3><ul>
<li>一个彻底开源的，面向企业应用开发的大数据库集群</li>
<li>支持事务、ACID、可以替代MySQL的加强版数据库</li>
<li>一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群</li>
<li>一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server</li>
<li>结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品</li>
<li>一个新颖的数据库中间件产品</li>
</ul>
<h3 id="2、Mycat的关键特性"><a href="#2、Mycat的关键特性" class="headerlink" title="2、Mycat的关键特性"></a>2、Mycat的关键特性</h3><ul>
<li>支持SQL92标准</li>
<li>支持MySQL、Oracle、DB2、SQL Server、PostgreSQL等DB的常见SQL语法</li>
<li>遵守Mysql原生协议，跨语言，跨平台，跨数据库的通用中间件代理。</li>
<li>基于心跳的自动故障切换，支持读写分离，支持MySQL主从，以及galera cluster集群。</li>
<li>支持Galera for MySQL集群，Percona Cluster或者MariaDB cluster</li>
<li>基于Nio实现，有效管理线程，解决高并发问题。</li>
<li>支持数据的多片自动路由与聚合，支持sum,count,max等常用的聚合函数,支持跨库分页。</li>
<li>支持单库内部任意join，支持跨库2表join，甚至基于caltlet的多表join。</li>
<li>支持通过全局表，ER关系的分片策略，实现了高效的多表join查询。</li>
<li>支持分布式事务（弱xa）。</li>
<li>支持XA分布式事务（1.6.5）。</li>
<li>支持全局序列号，解决分布式下的主键生成问题。</li>
<li>支持zookeeper协调主从切换、zk序列、配置zk化（1.6）</li>
<li>支持库内分表（1.6）</li>
<li>集群基于ZooKeeper管理，在线升级，扩容，智能优化，大数据处理（2.0开发版）。</li>
</ul>
<h3 id="3、MyCat的架构"><a href="#3、MyCat的架构" class="headerlink" title="3、MyCat的架构"></a>3、MyCat的架构</h3><p><img src="D:\Typora\resources\app\asserts\icon\20180102094016239.png" alt="20180102094016239"></p>
<h2 id="二、Mycat的安装和配置"><a href="#二、Mycat的安装和配置" class="headerlink" title="二、Mycat的安装和配置"></a>二、Mycat的安装和配置</h2><p><strong>前提：安装了JDK</strong></p>
<h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><p>1、在mycat官网[<a target="_blank" rel="noopener" href="http://www.mycat.io/]">http://www.mycat.io/]</a> 下载mycat</p>
<p>wget <a target="_blank" rel="noopener" href="http://dl.mycat.io/1.6.6.1/Mycat-server-1.6.6.1-release-20181031195535-linux.tar.gz">http://dl.mycat.io/1.6.6.1/Mycat-server-1.6.6.1-release-20181031195535-linux.tar.gz</a></p>
<p>2、解压mycat到/usr/local目录下</p>
<p>tar xf Mycat-server-1.6.6.1-release-20181031195535-linux.tar.gz -C /usr/local</p>
<p>3、修改MyCat的配置</p>
<p>vi conf/wrapper.conf</p>
<p>修改wrapper.java.additional.10=-Xmx512M</p>
<p>修改wrapper.java.additional.11=-Xms256m</p>
<p>4、进入bin目录启动mycat</p>
<blockquote>
<p>cd /usr/local/mycat/bin</p>
<p>./mycat start</p>
<p>Usage: ./mycat { console | start | stop | restart | status | dump }</p>
</blockquote>
<p>5、检查mycat是正常工作</p>
<p>A、出现 Starting Mycat-server… 日志</p>
<p>B、ps -ef |grep mycat 查看是否存在mycat进程</p>
<p>C、netstat -lnutp | grep mycat进程号 &lt;Mycat提供外部访问的端口默认为8066,添加防火墙&gt;</p>
<h3 id="2、分片相关的概念"><a href="#2、分片相关的概念" class="headerlink" title="2、分片相关的概念"></a>2、分片相关的概念</h3><p><img src="D:\Typora\resources\app\asserts\icon\111.png" alt="111"></p>
<p><strong>逻辑库(schema)</strong> <strong>：</strong></p>
<p>前面一节讲了数据库中间件，通常对实际应用来说，并不需要知道中间件的存在，业务开发人员只需要知道数据库的概念，所以数据库中间件可以被看做是一个或多个数据库集群构成的逻辑库。</p>
<p><strong>逻辑表（table）：</strong></p>
<p>既然有逻辑库，那么就会有逻辑表，分布式数据库中，对应用来说，读写数据的表就是逻辑表。逻辑表，可以是数据切分后，分布在一个或多个分片库中，也可以不做数据切分，不分片，只有一个表构成。</p>
<p>分片表：是指那些原有的很大数据的表，需要切分到多个数据库的表，这样，每个分片都有一部分数据，所有分片构成了完整的数据。 总而言之就是需要进行分片的表。</p>
<p>非分片表：一个数据库中并不是所有的表都很大，某些表是可以不用进行切分的，非分片是相对分片表来说的，就是那些不需要进行数据切分的表。 </p>
<p><strong>分片节点(dataNode)</strong></p>
<p>数据切分后，一个大表被分到不同的分片数据库上面，每个表分片所在的数据库就是分片节点（dataNode）。</p>
<p><strong>节点主机(dataHost)</strong> </p>
<p>数据切分后，每个分片节点（dataNode）不一定都会独占一台机器，同一机器上面可以有多个分片数据库，这样一个或多个分片节点（dataNode）所在的机器就是节点主机（dataHost）,为了规避单节点主机并发数限制，尽量将读写压力高的分片节点（dataNode）均衡的放在不同的节点主机（dataHost）。</p>
<p><strong>分片规则(rule)</strong> </p>
<p>前面讲了数据切分，一个大表被分成若干个分片表，就需要一定的规则，这样按照某种业务规则把数据分到某个分片的规则就是分片规则，数据切分选择合适的分片规则非常重要，将极大的避免后续数据处理的难度。</p>
<ul>
<li>范围</li>
<li>hash</li>
</ul>
<h3 id="3、Mycat的配置"><a href="#3、Mycat的配置" class="headerlink" title="3、Mycat的配置"></a>3、Mycat的配置</h3><p>配置文件夹位置：/etc/local/mycat/conf</p>
<h4 id="schema-xml"><a href="#schema-xml" class="headerlink" title="schema.xml"></a>schema.xml</h4><p>逻辑库、逻辑表及对应分片节点、分片节点及对应物理数据库和逻辑主机、逻辑主机对应的物理主机</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置表的存储方式.schema name=&quot;TESTDB&quot; 与 server.xml中的 TESTDB 设置一致  --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span> 	<span class="comment">&lt;!--定义逻辑库--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--逻辑表 分片节点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;users&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>  <span class="attr">dataNode</span>=<span class="string">&quot;node_db01&quot;</span> /&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--水平分库 分片逻辑表 分片节点--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;item&quot;</span>  <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>  <span class="attr">dataNode</span>=<span class="string">&quot;node_db02,node_db03&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;rule1&quot;</span> /&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--水平分表 分片逻辑表 分片节点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user&quot;</span>  <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span>  <span class="attr">dataNode</span>=<span class="string">&quot;node_db01&quot;</span> <span class="attr">subTables</span>=<span class="string">&quot;user$1-3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;rule1&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span>  													    </span><br><span class="line"><span class="comment">&lt;!-- 设置 分片节点 对应的 物理数据库(database),及 物理数据 连接的逻辑主机(dataHost) --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;node_db01&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dataHost01&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;node_db02&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dataHost01&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db02&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;node_db03&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dataHost01&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db03&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- mycat 逻辑主机(dataHost)对应的物理主机.其中也设置对应的mysql登陆信息 --&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--maxCon指定每个读写实例连接池的最大连接数，minCon最小连接数和初始化连接数,balance负载均衡类型,writeType辅材均衡类型,dbType数据库类型,dbDriver数据库驱动--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--balance:0-不开启读写分离，所有读操作都发送到当前可用的writeType，1-主备从主机都参与查负载均衡，</span></span><br><span class="line"><span class="comment">2-所有读请求随机在writeHost和readHost上分发，3-所有读请求只随机的分发到writeHost对应的readHost上--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--writeType:0-所有写请求发送到配置的第一个writeHost，第一个挂了切到存活的第二个writeHost</span></span><br><span class="line"><span class="comment">1-所有写请求都随机的发送到配置的writeHost，1.5之后废弃不推荐--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--switchType:-1不自动切换1自动切换(默认)2根据主从状态决定是否切换，心跳语句:show slave status</span></span><br><span class="line"><span class="comment">3基于集群的切换机制，心跳语句:show status like &#x27;wsrep%&#x27;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注意：MyCat的读写分离基于MySql的主从结构，需要先建立主从--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dataHost01&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.146.220:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.146.221:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mycat</span>:schema <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;GDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tb_user&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db1&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db2&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db3&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">			  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.3.220:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">				   <span class="attr">password</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="service-xml"><a href="#service-xml" class="headerlink" title="service.xml"></a>service.xml</h4><p>主要配置mycat服务的参数，比如端口号，myact用户名和密码及可以使用的逻辑数据库等</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;charset&quot;</span>&gt;</span>utf8<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultSqlParser&quot;</span>&gt;</span>druidparser<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mutiNodeLimitType&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个端口将在项目中使用--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serverPort&quot;</span>&gt;</span>8066<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 这个端口是mycat自带的监控系统端口，和下面的账号是一起的 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;managerPort&quot;</span>&gt;</span>9066<span class="tag">&lt;/<span class="name">property</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">system</span>&gt;</span>  </span><br><span class="line">       </span><br><span class="line"><span class="comment">&lt;!-- 任意设置登陆 mycat 的用户名,密码,数据库 ，这个账号不是你本地数据库的账号，是mycat自带的监控系统 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span>  <span class="comment">&lt;!--对应schema.xml里配置的 逻辑库名--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="rule-xml"><a href="#rule-xml" class="headerlink" title="rule.xml"></a>rule.xml</h4><p>主要配置路由策略，主要有分片的片键，拆分的策略（取模\按区间划分\Hash等）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建分表路由 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;rule1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span>	<span class="comment">&lt;!--根据的字段名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span>		<span class="comment">&lt;!--根据的字段规则--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;auto-sharding-long&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 创建分表路由策略 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里使用取模的方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据你有多少个数据库节点进行取模--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里使用范围约定的方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.AutoPartitionByLong&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据你有多少个数据库节点进行取模--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>autopartition-long.txt:( 范围自动分片定义 范围 )</p>
<blockquote>
<p># K=1000, M=10000</p>
<p>0-500M=0</p>
<p>500M-1000M=1</p>
<p>1000M-1500M=2</p>
</blockquote>
<h3 id="4、验证结果"><a href="#4、验证结果" class="headerlink" title="4、验证结果"></a>4、验证结果</h3><p>在命令行访问mycat逻辑数据库</p>
<p>命令: mysql -utest -ptest -h192.168.146.220 -P8066 -DTESTDB</p>
<p>说明: 第一个test是你自己数据库的账号  第二个test是你自己数据库的密码  -P8066是mycat逻辑库的端口，TESTDB是逻辑库，在schema.xml定义过</p>
<p>也可以通过navcat等工具连接，连接后不能在mycat连接中使用图形化工具建表，需要使用DDL数据库定义语言</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user(</span><br><span class="line">	id <span class="type">integer</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> <span class="keyword">key</span>,</span><br><span class="line">	u_name <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>操作时，只需像单表操作一样操作mycat的表即可</p>
<h3 id="5、全局表"><a href="#5、全局表" class="headerlink" title="5、全局表"></a>5、全局表</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tbl_user&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;global&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dataNode1,dataNode2,dataNode3&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>全局表的作用就是避免跨库多表连接，如下面sql，当订单表关联用户表，因用户表已经在该分片上了，可以直接left join，如果此分片上没有tbl_user表，那我们只能先查tbl_order表，然后再查tbl_user表，然后使用Java代码组装数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># DB层面 全局表直接<span class="keyword">join</span> </span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">	o.order_code,</span><br><span class="line">	o.amount,</span><br><span class="line">	u.username</span><br><span class="line"><span class="keyword">from</span> tbl_order o</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tbl_user u <span class="keyword">on</span> o.user_id <span class="operator">=</span> u.id</span><br><span class="line"># 页面层面 跨库连接通过代码组装数据</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 先查询tbl_order, 再查询tbl_user, 最后组装数据</span><br><span class="line">List<span class="operator">&lt;</span><span class="keyword">Order</span><span class="operator">&gt;</span> orderList <span class="operator">=</span> &quot;select * from tbl_order&quot;;</span><br><span class="line">List<span class="operator">&lt;</span><span class="keyword">User</span><span class="operator">&gt;</span> userList <span class="operator">=</span> &quot;select * from tbl_user&quot;;</span><br><span class="line">orderList.forEach(order -&gt; &#123;</span><br><span class="line">	Long userId <span class="operator">=</span> order.getUserId;</span><br><span class="line">	List resultList <span class="operator">=</span> userList.stream().<span class="keyword">filter</span>(<span class="keyword">user</span> <span class="operator">-</span><span class="operator">&gt;</span> userId.equals(user.getId())).<span class="keyword">collect</span>(Collectors.toList());</span><br><span class="line">	<span class="keyword">User</span> <span class="keyword">user</span> <span class="operator">=</span> resultList.get(<span class="number">0</span>);</span><br><span class="line">	order.setUser(<span class="keyword">user</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6、ER分片表（解决跨库JOIN问题）"><a href="#6、ER分片表（解决跨库JOIN问题）" class="headerlink" title="6、ER分片表（解决跨库JOIN问题）"></a>6、ER分片表（解决跨库JOIN问题）</h3><p>业务中有些表是有父子关系的或者一对多的关系，如订单表tbl_order和订单项表tbl_order_item，我们可以通过合适的分片规则对父表进行分片(如根据订单id), 然后指定一下父表有哪些子表，这样当父表的一条数据被分片到某个节点，那么对应于父表的那条数据下的所有子表数据也会分配到和父表相同的节点上。当父表和子表都分配同一个分片上，就避免了跨库连接。这样的表被称为ER分片表，ER分片表也是为了避免跨库连接, ER分片表可以通过childTable来配置分片表。子表可以有多个，子表也可以嵌套子表</p>
<p>schema.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- joinKey用于指定子表关联的字段；parentKey用于指定父表关联的字段；注意只有父表定义了分片规则rule子表是不定义的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;tbl_order&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dataNode1,dataNode2,dataNode3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;mod-long&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">&quot;tbl_order_item&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">joinKey</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">parentKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span>、</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果某条订单被分配到节点1上(假如根据订单id使用取模的分配规则)</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_order(id, order_code, user_id, amount)<span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;20181027160000000001&#x27;</span>, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 那么子表也会使用joinKey对应的值(即order_id)使用取模的分配规则，</span></span><br><span class="line"><span class="comment">-- 因tbl_order_item.order_id和tbl_order.id值是完全一样的，对同一个值使用同样的分配规则，</span></span><br><span class="line"><span class="comment">-- 那么这个订单的订单项也会分片到节点1上，即子表和父表被分到相同的片上</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_order_item(id, order_id, goods_id, amount)<span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_order_item(id, order_id, goods_id, amount)<span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_order_item(id, order_id, goods_id, amount)<span class="keyword">VALUES</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 因子表和父表被分到相同的片上，所以可以直接关联join，不用再使用Java组装数据了</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">	o.order_code,</span><br><span class="line">	oi.goods_id,</span><br><span class="line">	oi.amount</span><br><span class="line"><span class="keyword">from</span> tbl_order o</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tbl_order_item oi <span class="keyword">on</span> o.id <span class="operator">=</span> oi.order_id</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h2 id="一、-MongoDB简介"><a href="#一、-MongoDB简介" class="headerlink" title="一、 MongoDB简介"></a>一、 MongoDB简介</h2><h3 id="1、-什么是MongoDB"><a href="#1、-什么是MongoDB" class="headerlink" title="1、 什么是MongoDB"></a>1、 什么是MongoDB</h3><p>MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热门的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似JSON  的 BSON 格式，因此可以存储比较复杂的数据类型。</p>
<p>MongoDB 的官方网站地址是：<a target="_blank" rel="noopener" href="http://www.mongodb.org/">http://www.mongodb.org/</a></p>
<h3 id="2、-MongoDB特点"><a href="#2、-MongoDB特点" class="headerlink" title="2、 MongoDB特点"></a>2、 MongoDB特点</h3><p>MongoDB 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。它是一个面向集合的,模式自由的文档型数据库。</p>
<p>具体特点总结如下：</p>
<p>（1）面向集合存储，易于存储对象类型的数据</p>
<p>（2）模式自由</p>
<p>（3）支持动态查询</p>
<p>（4）支持完全索引，包含内部对象</p>
<p>（5）支持复制和故障恢复</p>
<p>（6）使用高效的二进制数据存储，包括大型对象（如视频等）</p>
<p>（7）自动处理碎片，以支持云计算层次的扩展性(MapReduce)</p>
<p>（8）支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++语言的驱动程序，社区中也提供了对 Erlang 及.NET 等平台的驱动程序</p>
<p>（9）文件存储格式为BSON（一种 JSON 的扩展）</p>
<p>（10）会将热点数据存储在内存中，使热点数据读写迅速</p>
<p>（11）不支持事务（最主要缺点）</p>
<h3 id="3、-MongoDB体系结构"><a href="#3、-MongoDB体系结构" class="headerlink" title="3、 MongoDB体系结构"></a>3、 MongoDB体系结构</h3><p>MongoDB 的逻辑结构是一种层次结构。主要由：</p>
<p>文档(document)、集合(collection)、数据库(database)这三部分组成的。逻辑结构是面向用户</p>
<p>的，用户使用 MongoDB 开发应用程序使用的就是逻辑结构。</p>
<p>（1）MongoDB 的文档（document），相当于关系数据库中的一行记录。</p>
<p>（2）多个文档组成一个集合（collection），相当于关系数据库的表。</p>
<p>（3）多个集合（collection），逻辑上组织在一起，就是数据库（database）。</p>
<p>（4）一个 MongoDB 实例支持多个数据库（database）。</p>
<p>文档(document)、集合(collection)、数据库(database)的层次结构如下图</p>
<p><img src="D:\Typora\resources\app\asserts\icon\1554100647660.png" alt="1554100647660"></p>
<p>下表是MongoDB与MySQL数据库逻辑结构概念的对比</p>
<table>
<thead>
<tr>
<th>MongoDb</th>
<th>关系型数据库Mysql</th>
</tr>
</thead>
<tbody><tr>
<td>数据库(databases)</td>
<td>数据库(databases)</td>
</tr>
<tr>
<td>集合(collections)</td>
<td>表(table)</td>
</tr>
<tr>
<td>文档(document)</td>
<td>行(row)</td>
</tr>
</tbody></table>
<h3 id="4、MongoDB的使用场景"><a href="#4、MongoDB的使用场景" class="headerlink" title="4、MongoDB的使用场景"></a>4、MongoDB的使用场景</h3><p>常见应用场景：</p>
<ol>
<li>就是存log，因为mongodb本身存的就是json，可以很方便的接入各种存储日志的地方。然后可以做成相关监控报表。</li>
<li>不同的行业有不同的用法，比如说信息的展示等等</li>
<li>在网游界，MongoDB也非常流行，比如说最近大火的阴阳师，数据库用的就是MongoDB</li>
<li>自带sharding，快速得水平扩展，为存储海量数据带来便捷</li>
<li>官方提供驱动，可以直接对接hadoop或者spark</li>
</ol>
<h2 id="二-安装与启动"><a href="#二-安装与启动" class="headerlink" title="二.安装与启动"></a>二.安装与启动</h2><h3 id="1、-安装设置"><a href="#1、-安装设置" class="headerlink" title="1、 安装设置"></a>1、 安装设置</h3><p><strong>windows:</strong></p>
<p>下载在官网TryFree-&gt;Server中的“mongodb-win64-bit x64.msi” </p>
<p>按照提示步骤安装即可。安装完成后，软件会安装在C:\Program Files\MongoDB 目录中。</p>
<p>我们要启动的服务程序就是</p>
<p>C:\Program Files\MongoDB\Server\4.0.8\bin</p>
<p>目录下的mongo.exe，为了方便我们每次启动，我将</p>
<p>C:\Program Files\MongoDB\Server\4.0.8\bin 设置到<strong>环境变量</strong>path中。</p>
<p>其中还有mongod是数据库，mongos用于集群路由配置</p>
<p><strong>linux:</strong></p>
<p>下载在官网TryFree-&gt;Server中的“mongodb-linux86_64-4.0.8.tgz”上传或直接wget </p>
<p>解压压缩包</p>
<blockquote>
<p>tar xf mongodb-linux-x86_63-4.0.8.tgz</p>
<p>mv mongodb-linux-x86_63-4.0.8 /usr/local/mongodb408</p>
</blockquote>
<p>新建数据文件和日志文件</p>
<blockquote>
<p>mkdir -p data/db         ##-p表示递归创建</p>
</blockquote>
<p><strong>docker：</strong></p>
<blockquote>
<p>docker run –name mongol -v /usr/local/mongodb/data:/data/db -v /usr/local/mongodb/backup:/data/backup -v /usr/local/mongodb/conf:/data/configdb -p 27017:27017 –network tms –network-alias mongodb -d mongo mongod -f /data/configdb/mongodb.conf</p>
</blockquote>
<p>use admin<br>db.createUser(<br>{<br>user: “admin”,<br>pwd: “password”,<br>roles: [ { role: “root”, db: “admin” } ]<br>}<br>);</p>
<p>db.createUser(<br>{<br>user: “test”,<br>pwd: “123”,<br>roles: [<br>{ role: “readWrite”, db: “Book” }<br>]<br>}<br>);</p>
<p>db.grantRolesToUser(<br>    “test”,<br>    [<br>      { role: “dbOwner”, db: “Book” }<br>    ]<br>)</p>
<h3 id="2、-启动服务"><a href="#2、-启动服务" class="headerlink" title="2、 启动服务"></a>2、 启动服务</h3><p><strong>windows:</strong></p>
<p>（1）首先打开cmd，创建一个用于存放数据的目录和日志的目录，修改mongod.cfg中文件位置</p>
<blockquote>
<p>md data\db</p>
<p>md data\log</p>
</blockquote>
<p>（2）启动服务</p>
<blockquote>
<p>mongod –dbpath-d:\data\db</p>
</blockquote>
<p>dbpath参数用于指定数据存储目录</p>
<p>我们在启动信息中可以看到，mongoDB的默认端口是27017</p>
<p>如果我们不想按照默认端口启动，可以通过–port 命令来修改端口</p>
<blockquote>
<p>mongod –port 12306 –dbpath-d:\data\db</p>
</blockquote>
<p>(3)客户端工具连接服务</p>
<blockquote>
<p>./mongo.exe</p>
</blockquote>
<p>或使用图形化工具</p>
<p>NOSQL Manager for MongoDB</p>
<p><strong>linux:</strong></p>
<p>在bin目录下启动mongoDB服务</p>
<blockquote>
<p>./mongod –dbpath=../data/db</p>
</blockquote>
<h3 id="3、-登录系统"><a href="#3、-登录系统" class="headerlink" title="3、 登录系统"></a>3、 登录系统</h3><p>我们另外打开命令提示符窗口，如果mongoDB是按默认的端口启动的，并且是部署在本机的。输入命令 mongo 即可登陆系统 </p>
<blockquote>
<p>./mongo        #进入数据库</p>
</blockquote>
<p>或使用图形化工具</p>
<p>NOSQL Manager for MongoDB或MongoDB Compass Community</p>
<p>从界面输出的信息我们可以得知，它默认连接的是test数据库</p>
<p>如果是要连接远程的mongoDB服务器 ，就输入命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongo 远程IP地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果远程的mongoDB服务端口不是默认的，需要输入命令  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongo 远程IP地址:端口</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入exit命令可退回到命令提示符</p>
<h3 id="4、实现远程连接"><a href="#4、实现远程连接" class="headerlink" title="4、实现远程连接"></a>4、实现远程连接</h3><ol>
<li>添加管理员账户（<a target="_blank" rel="noopener" href="https://docs.mongodb.com/guides/server/auth/%EF%BC%89">https://docs.mongodb.com/guides/server/auth/）</a></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use admin;		#操作admin数据库</span><br><span class="line"></span><br><span class="line">db.createUser(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">user</span>: &quot;charlie&quot;,</span><br><span class="line">    pwd: &quot;charlie&quot;,</span><br><span class="line">    roles: [ &#123; role: &quot;dbAdmin&quot;, db: &quot;admin&quot; &#125; ]</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> users;		#查看所有用户及权限</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>创建并配置mongodb.conf</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bind_ip=0.0.0.0</span><br><span class="line">port=27017</span><br><span class="line">dbpath=/usr/local/mongodb409/data/db</span><br><span class="line">logpath=/usr/local/mongodb409/data/log/mongo.log</span><br><span class="line"><span class="meta">#</span><span class="bash">auth=<span class="literal">true</span> <span class="comment">#开启权限认证</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --fork <span class="comment">#后台启动 此时必须指定日志文件</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>重启mongodb</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 关闭mongodb</span></span></span><br><span class="line">./mongod -shutdown --dbpath=/usr/local/mongodb/data </span><br><span class="line"></span><br><span class="line">./mongod -f mongodb.conf --fork</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>防火墙开放27017端口</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-port=27017/tcp --permanent</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="三、-数据库的CURD操作"><a href="#三、-数据库的CURD操作" class="headerlink" title="三、 数据库的CURD操作"></a>三、 数据库的CURD操作</h2><p>可以使用shell指令也可以直接图形化工具操作，以下为shell指令</p>
<h3 id="1、-数据库操作"><a href="#1、-数据库操作" class="headerlink" title="1、 数据库操作"></a>1、 数据库操作</h3><p>使用use 数据库名称即可选择数据库，如果该数据库不存在会自动创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use testdb;	#有该数据库则切换，没有则创建</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> dbs;	#展示所有数据库</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2、-集合操作"><a href="#2、-集合操作" class="headerlink" title="2、 集合操作"></a>2、 集合操作</h3><p>集合根据文档的集合名自动创建</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.save(&#123;_id:1,name:&quot;红孩儿&quot;,sex:&quot;男&quot;,age:15,address:&quot;火云洞&quot;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3、文档操作"><a href="#3、文档操作" class="headerlink" title="3、文档操作"></a>3、文档操作</h3><ul>
<li>查询文档</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.find();		#查询集合下的所有文档</span><br><span class="line">db.testCollection.find(&#123;sex:&quot;男&quot;&#125;);		#查询集合下sex字段为男的文档</span><br><span class="line">db.testCollection.find(&#123;_id:ObjectId(&quot;123adsfa124&quot;)&#125;);		#根据id查询文档</span><br><span class="line">db.testCollection.find(&#123;_id:ObjectId(&quot;123adsfa124&quot;)&#125;,&#123;name:0&#125;)	#查询结果不显示name字段，1为显示</span><br><span class="line">db.testCollection.find(&#123;sex:&quot;男&quot;&#125;).sort(&#123;age:-1&#125;).skip(1);	#按照年龄降序，并跳过第一条记录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了避免游标可能带来的开销，MongoDB还提供了一个叫findOne()的方法，用来返回结果集的第一条记录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.findOne(&#123;sex:&quot;男&quot;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当我们需要返回查询结果的前几条记录时，可以使用limit方法，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.find().limit(2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>插入文档</li>
</ul>
<p>首先我们定义一个文档变量，格式为变量名称={}; 例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">student1=&#123;</span><br><span class="line"> 	_id:1,</span><br><span class="line">    name:&quot;唐僧&quot;,</span><br><span class="line">    sex:&quot;男&quot;,</span><br><span class="line">    age:14,</span><br><span class="line">    address:&quot;东土大唐&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将这个变量存入MongoDB </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.save(变量);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，你也可以不用定义变量，直接把变量值放入save方法中也是可以地。</p>
<p>这里的集合就相当于关系数据库中的表。如果这个testCollection集合不存在，就会自动创建。</p>
<ul>
<li>修改文档 .</li>
</ul>
<p>例如：我向将姓名为孙悟空的学员文档中的age字段值改为31，执行下列语句，看会发生什么？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.update(&#123;name:&quot;孙悟空&quot;&#125;,&#123;age:31&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们在执行查询会发现只剩下id和age字段有数据了</p>
<p>我们需要使用MongoDB提供的修改器$set 来实现，请看下列代码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.update(&#123;name:&quot;孙悟空&quot;&#125;,&#123;$set:&#123;age:31&#125;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再次查询，会发现更新age字段也成功了,会保留原始数据。</p>
<ul>
<li>删除文档</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.集合名称.remove(条件);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请慎用remove({}), 它会一条不剩地把你的集合所有文档删的干干净净。</p>
<p>删除name为“唐僧”的记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.remove(&#123;name:&quot;唐僧&quot;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="四、高级查询"><a href="#四、高级查询" class="headerlink" title="四、高级查询"></a>四、高级查询</h2><h3 id="1、-模糊查询"><a href="#1、-模糊查询" class="headerlink" title="1、 模糊查询"></a>1、 模糊查询</h3><p>MongoDB的模糊查询是通过正则表达式的方式实现的。格式为：</p>
<p>  /模糊查询字符串/</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.find(&#123;address:/洞/&#125;);   #包含洞字的记录</span><br><span class="line">db.testCollection.find(&#123;name:/^唐/&#125;);     #查询姓唐的记录</span><br><span class="line">db.testCollection.find(&#123;address:/区$/&#125;);  #查询以区结尾的地址</span><br><span class="line">db.testCollection.find(&#123;name:/mm/i&#125;);     #包含mm字符的忽略大小写匹配</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2、-Null值查询"><a href="#2、-Null值查询" class="headerlink" title="2、 Null值查询"></a>2、 Null值查询</h3><p>如果我们想找出集合中某字段值为空的文档，如何查询呢？其实和我们之前的条件查询是一样的，条件值写为null就可以了。</p>
<p>将“沙和尚”的address改为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.update(&#123;name:&quot;沙和尚&quot;&#125;,&#123;$set:&#123;address:null&#125;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在执行条件查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.find(&#123;address:null&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>会发现不仅会显示为null的文档，之前因为修改导致address字段丢失的那条记录也出现了。也就是说，这种查询会查询出该字段为null的以及不存在该字段的文档记录。</p>
<h3 id="3、-大于小于"><a href="#3、-大于小于" class="headerlink" title="3、 大于小于"></a>3、 大于小于</h3><p>&lt;, &lt;=, &gt;, &gt;= 这个操作符也是很常用的，格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.find(&#123; &quot;field&quot; : &#123; $gt: value &#125; &#125; ); &#x2F;&#x2F; 大于: field &gt; value</span><br><span class="line">db.testCollection.find(&#123; &quot;field&quot; : &#123; $lt: value &#125; &#125; ); &#x2F;&#x2F; 小于: field &lt; value</span><br><span class="line">db.testCollection.find(&#123; &quot;field&quot; : &#123; $gte: value &#125; &#125; ); &#x2F;&#x2F; 大于等于: field &gt;&#x3D; value</span><br><span class="line">db.testCollection.find(&#123; &quot;field&quot; : &#123; $lte: value &#125; &#125; ); &#x2F;&#x2F; 小于等于: field &lt;&#x3D; value</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例：查询年龄大于等于20岁的学员记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.find(&#123;age:&#123;$gte:20&#125;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4、-不等于"><a href="#4、-不等于" class="headerlink" title="4、 不等于"></a>4、 不等于</h3><p>不等于使用$ne操作符。</p>
<p>示例：查询sex字段不为“男”的文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.find(&#123;sex:&#123;$ne:&quot;男&quot;&#125;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5、-判断字段是否存在"><a href="#5、-判断字段是否存在" class="headerlink" title="5、 判断字段是否存在"></a>5、 判断字段是否存在</h3><p>判断字段是否存在使用$exists操作符。</p>
<p>示例：查询所有含有address字段的文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.find(&#123;address:&#123;$exists:true&#125;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例：查询所有不含有address1字段的文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.find(&#123;address1:&#123;$exists:false&#125;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6、-包含与不包含"><a href="#6、-包含与不包含" class="headerlink" title="6、 包含与不包含"></a>6、 包含与不包含</h3><p>包含使用$in操作符。</p>
<p>示例：查询testCollection集合中age字段包含20,25,30的文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.find(&#123;age:&#123;$in:[20,25,30]&#125;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例：查询testCollection集合中age字段不包含20,25,30的文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.find(&#123;age:&#123;$nin:[20,25,30]&#125;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7、-统计记录条数"><a href="#7、-统计记录条数" class="headerlink" title="7、 统计记录条数"></a>7、 统计记录条数</h3><p>统计记录条件使用count()方法。</p>
<p>示例：查询testCollection集合的文档条数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.count();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例：查询testCollection集合中age字段小于等于20的文档条数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.count(&#123;age:&#123;$lte:20&#125;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8、-条件连接–并且"><a href="#8、-条件连接–并且" class="headerlink" title="8、 条件连接–并且"></a>8、 条件连接–并且</h3><p>我们如果需要查询同时满足两个以上条件，需要使用$and操作符将条件进行关联。（相当于SQL的and）</p>
<p>格式为：$and:[ {  },{  },{   } ]</p>
<p>示例：查询testCollection集合中age大于等于20 并且age小于30的文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.find(&#123;$and:[&#123;age:&#123;$gte:20&#125;&#125;,&#123;age:&#123;$lt:30&#125;&#125;]);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="9、-条件连接–或者"><a href="#9、-条件连接–或者" class="headerlink" title="9、 条件连接–或者"></a>9、 条件连接–或者</h3><p>如果两个以上条件之间是或者的关系，我们使用$or操作符进行关联，与前面$and的使用方式相同</p>
<p>格式为：$or:[ {  },{  },{   } ]</p>
<p>示例：查询testCollection集合中sex为女，或者年龄小于20的文档记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.testCollection.find(&#123;$or:[&#123;sex:女&#125;,&#123;age:&#123;$lt:30&#125;&#125;]);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="五、Java连接MongoDB"><a href="#五、Java连接MongoDB" class="headerlink" title="五、Java连接MongoDB"></a>五、Java连接MongoDB</h2><h3 id="1、-查询文档"><a href="#1、-查询文档" class="headerlink" title="1、 查询文档"></a>1、 查询文档</h3><h4 id="1-1-查询全部"><a href="#1-1-查询全部" class="headerlink" title="1.1 查询全部"></a>1.1 查询全部</h4><p>（1）创建maven工程mongoDBDemo ，引入依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mongodb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mongodb-driver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（2）编写代码，遍历testCollection集合所有数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MongoClient client=<span class="keyword">new</span> MongoClient();<span class="comment">//创建连接对象</span></span><br><span class="line">MongoDatabase database = client.getDatabase(<span class="string">&quot;testdb&quot;</span>);<span class="comment">//获取数据库		</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(<span class="string">&quot;testCollection&quot;</span>);<span class="comment">//获取集合</span></span><br><span class="line">		</span><br><span class="line">FindIterable&lt;Document&gt; list = collection.find();<span class="comment">//获取文档集合</span></span><br><span class="line"><span class="keyword">for</span>( Document doc: list)&#123;<span class="comment">//遍历集合中的文档输出数据</span></span><br><span class="line">	System.out.println(<span class="string">&quot;name:&quot;</span>+ doc.getString(<span class="string">&quot;name&quot;</span>) );</span><br><span class="line">	System.out.println(<span class="string">&quot;sex:&quot;</span>+ doc.getString(<span class="string">&quot;sex&quot;</span>) );</span><br><span class="line">	System.out.println(<span class="string">&quot;age:&quot;</span>+ doc.getDouble(<span class="string">&quot;age&quot;</span>) );<span class="comment">//默认为浮点型</span></span><br><span class="line">	System.out.println(<span class="string">&quot;address:&quot;</span>+ doc.getString(<span class="string">&quot;address&quot;</span>) );</span><br><span class="line">	System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>MongoDB的数字类型默认使用64位浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用NumberInt（4字节符号整数），{“x”:NumberInt(“3”)}  或NumberLong（8字节符号整数）{“x”:NumberLong(“3”)}</p>
<h4 id="1-2-匹配查询"><a href="#1-2-匹配查询" class="headerlink" title="1.2 匹配查询"></a>1.2 匹配查询</h4><p>MongoDB使用BasicDBObject类型封装查询条件，构造方法的参数为key 和value .</p>
<p>示例：查询testCollection集合中name为猪八戒的文档</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建查询条件</span></span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;猪八戒&quot;</span>);		</span><br><span class="line">FindIterable&lt;Document&gt; list = collection.find(bson);<span class="comment">//获取文档集合</span></span><br><span class="line"><span class="comment">//....遍历集合</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-3-模糊查询"><a href="#1-3-模糊查询" class="headerlink" title="1.3 模糊查询"></a>1.3 模糊查询</h4><p>构建模糊查询条件是通过正则表达式的方式来实现的</p>
<p>（1）完全匹配Pattern pattern = Pattern.compile(“^name$”);</p>
<p>（2）右匹配Pattern pattern = Pattern.compile(“^.*name$”);</p>
<p>（3）左匹配Pattern pattern = Pattern.compile(“^name.*$”);</p>
<p>（4）模糊匹配Pattern pattern = Pattern.compile(“^.<em>name.</em>$”);</p>
<p>示例：模糊查询testCollection集合中address 中含有洞的文档记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模糊查询：like %洞%</span></span><br><span class="line">Pattern queryPattern = Pattern.compile(<span class="string">&quot;^.*洞.*$&quot;</span>);</span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">&quot;address&quot;</span>, queryPattern);	</span><br><span class="line">FindIterable&lt;Document&gt; list = collection.find(bson);<span class="comment">//获取文档集合</span></span><br><span class="line"><span class="comment">//....遍历集合</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-4-大于小于"><a href="#1-4-大于小于" class="headerlink" title="1.4 大于小于"></a>1.4 大于小于</h4><p>在MongoDB提示符下条件json字符串为{ age: { $lt :20 } } ，对应的java代码也是BasicDBObject 的嵌套。</p>
<p>示例：查询testCollection集合中age小于20的文档记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询年龄小于20的		</span></span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">&quot;age&quot;</span>, <span class="keyword">new</span> BasicDBObject(<span class="string">&quot;$lt&quot;</span>,<span class="number">20</span>));</span><br><span class="line">FindIterable&lt;Document&gt; list = collection.find(bson);<span class="comment">//获取文档集</span></span><br><span class="line"><span class="comment">//....遍历集合</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-5-条件连接–并且"><a href="#1-5-条件连接–并且" class="headerlink" title="1.5 条件连接–并且"></a>1.5 条件连接–并且</h4><p>示例：查询年龄大于等于20并且小于30的文档记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询年龄大于等于20的			</span></span><br><span class="line">BasicDBObject bson1=<span class="keyword">new</span> BasicDBObject(<span class="string">&quot;age&quot;</span>, <span class="keyword">new</span> BasicDBObject(<span class="string">&quot;$gte&quot;</span>,<span class="number">20</span>));</span><br><span class="line"><span class="comment">//查询年龄小于30的</span></span><br><span class="line">BasicDBObject bson2=<span class="keyword">new</span> BasicDBObject(<span class="string">&quot;age&quot;</span>, <span class="keyword">new</span> BasicDBObject(<span class="string">&quot;$lt&quot;</span>,<span class="number">30</span>));</span><br><span class="line"><span class="comment">//构建查询条件and</span></span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span>  BasicDBObject(<span class="string">&quot;$and&quot;</span>, Arrays.asList(bson1,bson2)  );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-6-条件连接-或者"><a href="#1-6-条件连接-或者" class="headerlink" title="1.6 条件连接-或者"></a>1.6 条件连接-或者</h4><p>示例：查询年龄小于等于20或者性别为女的文档记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BasicDBObject bson1=<span class="keyword">new</span> BasicDBObject(<span class="string">&quot;age&quot;</span>, <span class="keyword">new</span> BasicDBObject(<span class="string">&quot;$lte&quot;</span>,<span class="number">20</span>));		</span><br><span class="line">BasicDBObject bson2=<span class="keyword">new</span> BasicDBObject(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line"><span class="comment">//构建查询条件or</span></span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">&quot;$or&quot;</span>, Arrays.asList( bson1, bson2 ) );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2、-增加文档"><a href="#2、-增加文档" class="headerlink" title="2、 增加文档"></a>2、 增加文档</h3><p>我们使用insertOne方法来插入文档。</p>
<p>示例：添加文档记录–名称：铁扇公主  性别:女 年龄：28   地址：芭蕉洞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">MongoClient client=<span class="keyword">new</span> MongoClient();</span><br><span class="line"><span class="comment">//得到数据库</span></span><br><span class="line">MongoDatabase database = client.getDatabase(<span class="string">&quot;testdb&quot;</span>);</span><br><span class="line"><span class="comment">//得到集合封装对象</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(<span class="string">&quot;testCollection&quot;</span>);</span><br><span class="line">Map&lt;String, Object&gt; map=<span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;铁扇公主&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;age&quot;</span>, <span class="number">35.0</span>);</span><br><span class="line">map.put(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;芭蕉洞&quot;</span>);		</span><br><span class="line">Document doc=<span class="keyword">new</span> Document(map);		</span><br><span class="line">collection.insertOne(doc);<span class="comment">//插入一条记录</span></span><br><span class="line"><span class="comment">//collection.insertMany(documents);//一次性插入多条文档</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3、-删除文档"><a href="#3、-删除文档" class="headerlink" title="3、 删除文档"></a>3、 删除文档</h3><p>示例：将名称为铁扇公主的文档删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">MongoClient client=<span class="keyword">new</span> MongoClient();</span><br><span class="line"><span class="comment">//得到数据库</span></span><br><span class="line">MongoDatabase database = client.getDatabase(<span class="string">&quot;testdb&quot;</span>);</span><br><span class="line"><span class="comment">//得到集合封装对象</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(<span class="string">&quot;testCollection&quot;</span>);</span><br><span class="line">BasicDBObject bson=<span class="keyword">new</span> BasicDBObject(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;铁扇公主&quot;</span>);</span><br><span class="line">collection.deleteOne(bson);<span class="comment">//删除记录（符合条件的第一条记录）</span></span><br><span class="line"><span class="comment">//collection.deleteMany(bson);//删除符合条件的全部记录</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4、-修改文档"><a href="#4、-修改文档" class="headerlink" title="4、 修改文档"></a>4、 修改文档</h3><p>示例：将红孩儿的地址修改为“南海”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">MongoClient client=<span class="keyword">new</span> MongoClient();</span><br><span class="line"><span class="comment">//得到数据库</span></span><br><span class="line">MongoDatabase database = client.getDatabase(<span class="string">&quot;testdb&quot;</span>);</span><br><span class="line"><span class="comment">//得到集合封装对象</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = database.getCollection(<span class="string">&quot;testCollection&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改的条件</span></span><br><span class="line">BasicDBObject bson= <span class="keyword">new</span> BasicDBObject(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;红孩儿&quot;</span>);</span><br><span class="line"><span class="comment">//修改后的值</span></span><br><span class="line">BasicDBObject bson2 = <span class="keyword">new</span> BasicDBObject(<span class="string">&quot;$set&quot;</span>,<span class="keyword">new</span> BasicDBObject(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;南海&quot;</span>));</span><br><span class="line"><span class="comment">//参数1：修改条件  参数2：修改后的值</span></span><br><span class="line">collection.updateOne(bson, bson2);</span><br><span class="line"><span class="comment">//collection.updateMany(filter, update);//修改符合条件的所有记录</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>updateMany方法用于修改符合条件的所有记录</p>
<p>updateOne方法用于修改符合条件的第一条记录</p>
<h2 id="六、-MongoDB连接池"><a href="#六、-MongoDB连接池" class="headerlink" title="六、 MongoDB连接池"></a>六、 MongoDB连接池</h2><h3 id="1、-代码实现"><a href="#1、-代码实现" class="headerlink" title="1、 代码实现"></a>1、 代码实现</h3><p>MongoClient 被设计为线程安全的类，也就是我们在使用该类时不需要考虑并发的情况，这样我们可以考虑把MongoClient 做成一个静态变量，为所有线程公用，不必每次都销毁。这样可以极大提高执行效率。实际上，这是MongoDB提供的内置的连接池来实现的。</p>
<p>首先我们先创建一个“管理类”，相当于我们原来BaseDao</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> MongoClient mongoClient=<span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对mongoClient初始化</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;		</span><br><span class="line">		mongoClient=<span class="keyword">new</span> MongoClient();	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MongoDatabase <span class="title">getDatabase</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(mongoClient==<span class="keyword">null</span>)&#123;</span><br><span class="line">			init();</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="keyword">return</span> mongoClient.getDatabase(<span class="string">&quot;testdb&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 然后我们创建一个TestDao</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String name,String sex,<span class="keyword">double</span> age,String address)</span></span>&#123;</span><br><span class="line">		MongoDatabase database = MongoManager.getDatabase();</span><br><span class="line">		MongoCollection&lt;Document&gt; collection = database.getCollection(<span class="string">&quot;testCollection&quot;</span>);</span><br><span class="line">		Document docment=<span class="keyword">new</span> Document();</span><br><span class="line">		docment.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">		docment.put(<span class="string">&quot;sex&quot;</span>, sex);		</span><br><span class="line">		docment.put(<span class="string">&quot;age&quot;</span>, age);</span><br><span class="line">		docment.put(<span class="string">&quot;address&quot;</span>, address);</span><br><span class="line">		collection.insertOne(docment);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在做个测试，循环插入5万条数据，看看执行时间是多长时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = <span class="keyword">new</span> Date().getTime();<span class="comment">//开始时间</span></span><br><span class="line"></span><br><span class="line">    TestDao testDao=<span class="keyword">new</span> TestDao();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20000</span>;i++)&#123;</span><br><span class="line">        testDao.save(<span class="string">&quot;测试&quot;</span>+i, <span class="string">&quot;女&quot;</span>, <span class="number">25.0</span>, <span class="string">&quot;测试地址&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> endTime = <span class="keyword">new</span> Date().getTime();<span class="comment">//完成时间</span></span><br><span class="line">    System.out.println(<span class="string">&quot;完成时间：&quot;</span>+(endTime-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2、-参数设置"><a href="#2、-参数设置" class="headerlink" title="2、 参数设置"></a>2、 参数设置</h3><p>在刚才的代码基础上进行连接池参数的设置</p>
<p>修改MongoManager的init方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对mongoClient初始化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//连接池选项</span></span><br><span class="line">		Builder builder = <span class="keyword">new</span> MongoClientOptions.Builder();<span class="comment">//选项构建者	</span></span><br><span class="line">		builder.connectTimeout(<span class="number">5000</span>);<span class="comment">//设置连接超时时间</span></span><br><span class="line">		builder.socketTimeout(<span class="number">5000</span>);<span class="comment">//读取数据的超时时间</span></span><br><span class="line">		builder.connectionsPerHost(<span class="number">30</span>);<span class="comment">//每个地址最大请求数		</span></span><br><span class="line">		builder.writeConcern(WriteConcern.NORMAL);<span class="comment">//写入策略，仅抛出网络异常</span></span><br><span class="line">		MongoClientOptions options = builder.build();</span><br><span class="line">		mongoClient=<span class="keyword">new</span> MongoClient(<span class="string">&quot;127.0.0.1&quot;</span>,options);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>写入方式有如下策略。</p>
<p>WriteConcern.NONE:没有异常抛出</p>
<p>WriteConcern.NORMAL:仅抛出网络错误异常，没有服务器错误异常</p>
<p>WriteConcern.SAFE:抛出网络错误异常、服务器错误异常；并等待服务器完成写操作。</p>
<p>WriteConcern.MAJORITY: 抛出网络错误异常、服务器错误异常；并等待一个主服务器完成写操作。</p>
<p>WriteConcern.FSYNC_SAFE: 抛出网络错误异常、服务器错误异常；写操作等待服务器将数据刷新到磁盘。</p>
<p>WriteConcern.JOURNAL_SAFE:抛出网络错误异常、服务器错误异常；写操作等待服务器提交到磁盘的日志文件。</p>
<p>WriteConcern.REPLICAS_SAFE:抛出网络错误异常、服务器错误异常；等待至少2台服务器完成写操作。</p>
<h2 id="七、Morphia框架的使用（ORM）"><a href="#七、Morphia框架的使用（ORM）" class="headerlink" title="七、Morphia框架的使用（ORM）"></a>七、Morphia框架的使用（ORM）</h2><h3 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mongodb.morphia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>morphia<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2、常用注解"><a href="#2、常用注解" class="headerlink" title="2、常用注解"></a>2、常用注解</h3><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">常用的注解</span><br><span class="line">@Entity value属性为DBConllection设置名称。必须有一个无参的默认构造函数，可以是public、protected、private等</span><br><span class="line"><span class="code">        noClassnameStored属性默认为存储类名。如果只存储单一的实体对象并且关心数据库大小，不存储类名是安全的。</span></span><br><span class="line"><span class="code">@Id 将值注解为MongoDB的唯一ID字段，MongoDB必须有一个唯一索引，mongo会自动生成id。如果使用其他类型，需要自己设置。</span></span><br><span class="line"><span class="code">    注意: @Id 并且需要自动生成ID的属性类型必须为ObjectId</span></span><br><span class="line"><span class="code">@Property 配置映射类中属性名称映射的列名 eg: userName =&gt; @Property(&quot;user_name&quot;)</span></span><br><span class="line"><span class="code">@Embedded 创建一个类被嵌套在实体类中的情况下使用，例如，在Hotel类中 可能会有一个Address。Address是Hotel不可分割的一部分，没有ID, 并且不会被存储在分开的collection中。</span></span><br><span class="line"><span class="code">事实上被@Embedded注释的类不允许有@Id</span></span><br><span class="line"><span class="code">@Indexed(value=IndexDirection.ASC, name=&quot;upc&quot;, unique=true, dropDups=true)</span></span><br><span class="line"><span class="code">value：索引方向，默认是IndexDirection.ASC，还可以是IndexDirection.DESC和IndexDirection.BOTH</span></span><br><span class="line"><span class="code">name：索引名，默认是mongoDB自动生成</span></span><br><span class="line"><span class="code">unique：是否唯一索引，默认为flase</span></span><br><span class="line"><span class="code">dropDups：通知唯一索引静默删除已有的重复元素，只保留第一个，默认为false</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">@Reference 引用注解，标记某一个字段存在另一个collection中。DBRef</span></span><br><span class="line"><span class="code">该注解有三种属性：</span></span><br><span class="line"><span class="code">lazy：懒汉模式，被调用时才从数据库获取此字段</span></span><br><span class="line"><span class="code">ignoreMissing：读取引用失败时不产生异常</span></span><br><span class="line"><span class="code">concreteClass：产生的实例的类类型</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">@Indexes&amp;@Index复合indexes可以指定多个字段，该注解是class级别。例如下面代码指定user为默认升序同时date为降序（-表示DESC）</span></span><br><span class="line"><span class="code">@Indexes(&#123;</span></span><br><span class="line"><span class="code">   @Index(&quot;user, -cs&quot;),</span></span><br><span class="line"><span class="code">   @Index(&quot;changedRecord, -cs&quot;)&#125;)</span></span><br><span class="line"><span class="code">@Transient 不将该字段保存到mongoDB@Property(&quot;feild_name&quot;) 指定该对象的属性映射到mongoDB的字段名称，默认为该对象的属性名。</span></span><br><span class="line"><span class="code">@Serialized 字段被转换成二进制，并且被存储</span></span><br><span class="line"><span class="code">@NotSaved 字段不会被保存，但是能被加载，良好的数据迁移</span></span><br><span class="line"><span class="code">@AlsoLoad 该字段所以提供的名字都能被加载，良好的数据迁移</span></span><br><span class="line"><span class="code">@Version 为Entity提供一个乐观锁，动态加载，不需要设置值</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>
<h3 id="3、映射类编写"><a href="#3、映射类编写" class="headerlink" title="3、映射类编写"></a>3、映射类编写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity(value = &quot;t_user&quot;,noClassnameStored = true)</span>	<span class="comment">//noClassnameStored表示插入时不存储类路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> ObjectId id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Property(&quot;real_name&quot;)</span></span><br><span class="line">    <span class="meta">@Indexed</span></span><br><span class="line">    <span class="keyword">private</span> String realName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Embedded</span>	<span class="comment">//表示这是个内置对象，address作为一个Bson在User集合下</span></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span>	<span class="comment">//表示引用另一个集合中的文档,跟根据_id引用</span></span><br><span class="line">    <span class="keyword">private</span> Role role;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgment</span></span><br><span class="line"><span class="meta">@AllArgment</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity(value = &quot;t_role&quot;, noClassnameStored = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> ObjectId id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Property(&quot;role_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4、增，删，改，查，分页操作"><a href="#4、增，删，改，查，分页操作" class="headerlink" title="4、增，删，改，查，分页操作"></a>4、增，删，改，查，分页操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">MongoClient mongoClient = <span class="keyword">new</span> MongoClient(<span class="string">&quot;192.168.146.220&quot;</span>,<span class="number">27017</span>);</span><br><span class="line">Morphia morphia = <span class="keyword">new</span> Morphia();</span><br><span class="line"><span class="comment">//使用morphia连接testdb数据库</span></span><br><span class="line">Datastore datastore = morphia.createDatastore(mongoClient,<span class="string">&quot;testdb&quot;</span>);</span><br><span class="line"></span><br><span class="line">## 增加 save</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setName(<span class="string">&quot;陈翰林&quot;</span>);</span><br><span class="line">user.setRealName(<span class="string">&quot;陈翰林&quot;</span>)；</span><br><span class="line">user.setAddress(<span class="keyword">new</span> Address(<span class="string">&quot;光明街&quot;</span>,<span class="string">&quot;嘉兴&quot;</span>,<span class="string">&quot;中国&quot;</span>));</span><br><span class="line">Role role = <span class="keyword">new</span> Role();</span><br><span class="line">role.setRoleName(<span class="string">&quot;学生&quot;</span>);</span><br><span class="line">datastore.save(role);</span><br><span class="line">Key&lt;User&gt; userKey = datastore.save(user);</span><br><span class="line">sout(userKey.getId());	#获取插入后生成的id</span><br><span class="line"></span><br><span class="line">## 查询 query</span><br><span class="line">Query&lt;User&gt; userQuery = datastore.createQuery(User.class).order(<span class="string">&quot;-real_name&quot;</span>);<span class="comment">//-降序+升序</span></span><br><span class="line"><span class="comment">//Query&lt;User&gt; userQuery = datastore.createQuery(User.class).filter(&quot;real_name = &quot;,&quot;zhangsan&quot;);</span></span><br><span class="line"><span class="comment">//Query&lt;User&gt; userQuery = datastore.createQuery(User.class).field(&quot;real_name&quot;).contains(&quot;g&quot;);</span></span><br><span class="line">List&lt;User&gt; user = userQuery.asList();</span><br><span class="line"><span class="comment">//List&lt;User&gt; user = userQuery.asList(new FindOptions().limit(2).skip((pageNum-1)*pageSize));</span></span><br><span class="line"><span class="keyword">for</span>(User user: users)&#123;</span><br><span class="line">	System.out.println(user.getAddress().getCountry()+<span class="string">&quot;,&quot;</span>+user.getRole().getRoleName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 修改 update</span><br><span class="line">UpdateOperations&lt;User&gt; updateOperations = datastore.createUpdateOperations(User.class).set(<span class="string">&quot;real_name&quot;</span>,<span class="string">&quot;唐僧2&quot;</span>).set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;唐僧2&quot;</span>);</span><br><span class="line">datastore.update(userQuery,updateOperations);	<span class="comment">//修改query对象条件的文档updateOperations内容</span></span><br><span class="line"></span><br><span class="line">## 删除 delete</span><br><span class="line">datastore.delete(userQuery);	<span class="comment">//根据查询条件进行删除</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="八、MongoDB高可用HA配置"><a href="#八、MongoDB高可用HA配置" class="headerlink" title="八、MongoDB高可用HA配置"></a>八、MongoDB高可用HA配置</h2><h3 id="1、主从Master-slave（3-2版本之前）"><a href="#1、主从Master-slave（3-2版本之前）" class="headerlink" title="1、主从Master-slave（3.2版本之前）"></a>1、主从Master-slave（3.2版本之前）</h3><p>主负责写和复制 ，从负责读</p>
<p>主数据库配置（master.conf ）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">port&#x3D;27017</span><br><span class="line">bind_ip &#x3D; 182.48.115.238</span><br><span class="line">dbpath&#x3D;&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;data</span><br><span class="line">logpath&#x3D;&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;log&#x2F;mongo.log</span><br><span class="line">logappend&#x3D;true</span><br><span class="line">journal &#x3D; true</span><br><span class="line">fork &#x3D; true</span><br><span class="line">master &#x3D; true        &#x2F;&#x2F;确定自己是主服务器</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从数据库配置（slave1.conf） </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">port&#x3D;27017</span><br><span class="line">dbpath&#x3D;&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;data</span><br><span class="line">logpath&#x3D;&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;log&#x2F;mongo.log</span><br><span class="line">logappend&#x3D;true</span><br><span class="line">journal &#x3D; true</span><br><span class="line">fork &#x3D; true</span><br><span class="line">bind_ip &#x3D; 182.48.115.236            &#x2F;&#x2F;确定主数据库端口</span><br><span class="line">source &#x3D; 182.48.115.238:27017      &#x2F;&#x2F;确定主数据库端口</span><br><span class="line">slave &#x3D; true               &#x2F;&#x2F;确定自己是从服务器</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;bin&#x2F;mongod --config &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;master.conf</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;bin&#x2F;mongod --config &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;slave1.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2、副本集replica-set-主备切换"><a href="#2、副本集replica-set-主备切换" class="headerlink" title="2、副本集replica set(主备切换)"></a>2、副本集replica set(主备切换)</h3><h4 id="2-1节点类型"><a href="#2-1节点类型" class="headerlink" title="2.1节点类型"></a>2.1节点类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）主节点负责处理客户端请求,读、写数据, 记录在其上所有操作的 oplog;</span><br><span class="line">2）从节点定期轮询主节点获取这些操作,然后对自己的数据副本执行这些操作,从而保证从节点的数据与主节点一致。默认情况下,从节点不支持客户端读取,但可以设置;副本集的机制在于主节点出现故障的时候,余下的节点会选举出一个新的主节点,从而保证系统可以正常运行。</span><br><span class="line">3）仲裁节点不复制数据,仅参与投票。由于它没有访问的压力,比较空闲,因此不容易出故障。由于副本集出现故障的时候,存活的节点必须大于副本集节点总数的一半,否则无法选举主节点,或者主节点会自动降级为从节点,整个副本集变为只读。因此,增加一个不容易出故障的仲裁节点,可以增加有效选票,降低整个副本集不可用的风险。仲裁节点可多于一个。也就是说只参与投票，不接收复制的数据，也不能成为活跃节点。</span><br><span class="line"></span><br><span class="line">官方推荐MongoDB副本节点最少为3台， 建议副本集成员为奇数，最多12个副本节点,最多7个节点参与选举。限制副本节点的数量,主要是因为一个集群中过多的副本节点,增加了复制的成本,反而拖累了集群</span><br><span class="line">的整体性能。 太多的副本节点参与选举,也会增加选举的时间。而官方建议奇数的节点,是为了避免脑裂 的发生。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-2工作流程"><a href="#2-2工作流程" class="headerlink" title="2.2工作流程"></a>2.2工作流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">在 MongoDB 副本集中,主节点负责处理客户端的读写请求,备份节点则负责映射主节点的 数据。备份节点的工作原理过程可以大致描述为,备份节点定期轮询主节点上的数据操作,</span><br><span class="line">然后对 自己的数据副本进行这些操作,从而保证跟主节点的数据同步。至于主节点上的所有 数据库状态改变 的操作,都会存放在一张特定的系统表中。备份节点则是根据这些数据进</span><br><span class="line">行自己的数据更新。</span><br><span class="line"> </span><br><span class="line">oplog （mongodb容易丢数据）</span><br><span class="line">上面提到的数据库状态改变的操作,称为 oplog(operation log,主节点操作记录)。oplog 存储在 local 数据库的&quot;oplog.rs&quot;表中。副本集中备份节点异步的从主节点同步 oplog,然后重新 执行它记录的操作,以此达到了数据同步的作用。</span><br><span class="line">关于 oplog 有几个注意的地方:</span><br><span class="line">1）oplog 只记录改变数据库状态的操作（写操作）</span><br><span class="line">2）存储在 oplog 中的操作并不是和主节点执行的操作完全一样,例如&quot;$inc&quot;操作就会转化为&quot;$set&quot;操作</span><br><span class="line">3）oplog 存储在固定集合中(capped collection),当 oplog 的数量超过 oplogSize,新的操作就会覆盖旧的操作</span><br><span class="line"> </span><br><span class="line">数据同步</span><br><span class="line">在副本集中,有两种数据同步方式:</span><br><span class="line">1）initial sync(初始化):这个过程发生在当副本集中创建一个新的数据库或其中某个节点刚从宕机中恢复,或者向副本集中添加新的成员的时候,默认的,副本集中的节点会从离 它最近</span><br><span class="line">   的节点复制 oplog 来同步数据,这个最近的节点可以是 primary 也可以是拥有最新 oplog 副本的 secondary 节点。该操作一般会重新初始化备份节点,开销较大。(全量复制)</span><br><span class="line">2）replication(复制):在初始化后这个操作会一直持续的进行着,以保持各个 secondary 节点之间的数据同步。（增量复制）</span><br><span class="line"> </span><br><span class="line">initial sync</span><br><span class="line">当遇到无法同步的问题时,只能使用以下两种方式进行 initial sync 了</span><br><span class="line">1）第一种方式就是停止该节点,然后删除目录中的文件,重新启动该节点。这样,这个节 点就会执行 initial sync</span><br><span class="line">   注意:通过这种方式,sync 的时间是根据数据量大小的,如果数据量过大,sync 时间就 会很长</span><br><span class="line">   同时会有很多网络传输,可能会影响其他节点的工作</span><br><span class="line">2）第二种方式,停止该节点,然后删除目录中的文件,找一个比较新的节点,然后把该节点目 录中的文件拷贝到要 sync 的节点目录中</span><br><span class="line">通过上面两种方式中的一种,都可以重新恢复&quot;port&#x3D;33333&quot;的节点。不在进行截图了。</span><br><span class="line"> </span><br><span class="line">副本集管理</span><br><span class="line">1）查看oplog的信息 通过&quot;db.printReplicationInfo()&quot;命令可以查看 oplog 的信息</span><br><span class="line">   字段说明:</span><br><span class="line">   configured oplog size: oplog 文件大小</span><br><span class="line">   log length start to end:     oplog 日志的启用时间段</span><br><span class="line">   oplog first event time:      第一个事务日志的产生时间</span><br><span class="line">   oplog last event time:       最后一个事务日志的产生时间</span><br><span class="line">   now:                         现在的时间</span><br><span class="line"> </span><br><span class="line">2）查看 slave 状态 通过&quot;db.printSlaveReplicationInfo()&quot;可以查看 slave 的同步状态</span><br><span class="line">  当插入一条新的数据,然后重新检查 slave 状态时,就会发现 sync 时间更新了</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-3副本集选举的过程和注意点"><a href="#2-3副本集选举的过程和注意点" class="headerlink" title="2.3副本集选举的过程和注意点"></a>2.3副本集选举的过程和注意点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Mongodb副本集选举采用的是Bully算法，这是一种协调者(主节点)竞选算法,主要思想是集群的每个成员都可以声明它是主节点并通知其他节点</span><br><span class="line">别的节点可以选择接受这个声称或是拒绝并进入主节点竞争，被其他所有节点接受的节点才能成为主节点。</span><br><span class="line">节点按照一些属性来判断谁应该胜出，这个属性可以是一个静态 ID,也可以是更新的度量像最近一次事务ID(最新的节点会胜出)</span><br><span class="line"> </span><br><span class="line">副本集的选举过程大致如下:</span><br><span class="line">1）得到每个服务器节点的最后操作时间戳。每个 mongodb 都有 oplog 机制会记录本机的操作,方便和主服 务器进行对比数据是否同步还可以用于错误恢复。</span><br><span class="line">2）如果集群中大部分服务器 down 机了,保留活着的节点都为 secondary 状态并停止,不选举了。</span><br><span class="line">3）如果集群中选举出来的主节点或者所有从节点最后一次同步时间看起来很旧了,停止选举等待人来操作。</span><br><span class="line">4）如果上面都没有问题就选择最后操作时间戳最新(保证数据是最新的)的服务器节点作为主节点。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">副本集选举的特点：</span><br><span class="line">选举还有个前提条件,参与选举的节点数量必须大于副本集总节点数量的一半（建议副本集成员为奇数。最多12个副本节点,最多7个节点参与选举）</span><br><span class="line">如果已经小于一半了所有节点保持只读状态。集合中的成员一定要有大部分成员(即超过一半数量)是保持正常在线状态,3个成员的副本集,需要至少2个从属节点是正常状态。</span><br><span class="line">如果一个从属节点挂掉,那么当主节点down掉 产生故障切换时,由于副本集中只有一个节点是正常的,少于一半,则选举失败。</span><br><span class="line">4个成员的副本集,则需要3个成员是正常状态(先关闭一个从属节点,然后再关闭主节点,产生故障切换,此时副本集中只有2个节点正常,则无法成功选举出新主节点)。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-4副本集数据同步过程"><a href="#2-4副本集数据同步过程" class="headerlink" title="2.4副本集数据同步过程"></a>2.4副本集数据同步过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Primary节点写入数据，Secondary通过读取Primary的oplog得到复制信息，开始复制数据并且将复制信息写入到自己的oplog。如果某个操作失败，则备份节点</span><br><span class="line">停止从当前数据源复制数据。如果某个备份节点由于某些原因挂掉了，当重新启动后，就会自动从oplog的最后一个操作开始同步，同步完成后，将信息写入自己的</span><br><span class="line">oplog，由于复制操作是先复制数据，复制完成后再写入oplog，有可能相同的操作会同步两份，不过MongoDB在设计之初就考虑到这个问题，将oplog的同一个操作</span><br><span class="line">执行多次，与执行一次的效果是一样的。简单的说就是：</span><br><span class="line"> </span><br><span class="line">当Primary节点完成数据操作后，Secondary会做出一系列的动作保证数据的同步：</span><br><span class="line">1）检查自己local库的oplog.rs集合找出最近的时间戳。</span><br><span class="line">2）检查Primary节点local库oplog.rs集合，找出大于此时间戳的记录。</span><br><span class="line">3）将找到的记录插入到自己的oplog.rs集合中，并执行这些操作。</span><br><span class="line"> </span><br><span class="line">副本集的同步和主从同步一样，都是异步同步的过程，不同的是副本集有个自动故障转移的功能。其原理是：slave端从primary端获取日志，然后在自己身上完全顺序</span><br><span class="line">的执行日志所记录的各种操作（该日志是不记录查询操作的），这个日志就是local数据 库中的oplog.rs表，默认在64位机器上这个表是比较大的，占磁盘大小的5%，</span><br><span class="line">oplog.rs的大小可以在启动参数中设 定：--oplogSize 1000,单位是M。</span><br><span class="line"> </span><br><span class="line">注意：在副本集的环境中，要是所有的Secondary都宕机了，只剩下Primary。最后Primary会变成Secondary，不能提供服务。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-5同步延迟问题"><a href="#2-5同步延迟问题" class="headerlink" title="2.5同步延迟问题"></a>2.5同步延迟问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">当你的用户抱怨修改过的信息不改变,删除掉的数据还在显示,你掐指一算,估计是数据库主从不同步。与其他提供数据同步的数据库一样,MongoDB 也会遇到同步延迟的问题,</span><br><span class="line">在MongoDB的Replica Sets模式中,同步延迟也经常是困扰使用者的一个大问题。</span><br><span class="line"> </span><br><span class="line">什么是同步延迟?</span><br><span class="line">首先,要出现同步延迟,必然是在有数据同步的场合,在 MongoDB 中,有两种数据冗余方式,一种是Master-Slave 模式,一种是Replica Sets模式。这两个模式本质上都是</span><br><span class="line">在一个节点上执行写操作, 另外的节点将主节点上的写操作同步到自己这边再进行执行。在MongoDB中,所有写操作都会产生 oplog,oplog 是每修改一条数据都会生成一条,如果你采用一个批量 update 命令更新了 N 多条数据, 那么抱歉,oplog 会有很多条,而不是一条。所以同步延迟就是写操作在主节点上执行完后,从节点还没有把 oplog 拿过来再执行一次。而这个写操作的量越大,主节点与从节点的差别也就越大,同步延迟也就越大了。</span><br><span class="line"> </span><br><span class="line">同步延迟带来的问题</span><br><span class="line">首先,同步操作通常有两个效果,一是读写分离,将读操作放到从节点上来执行,从而减少主节点的 压力。对于大多数场景来说,读多写少是基本特性,所以这一点是很有用的。</span><br><span class="line">另一个作用是数据备份, 同一个写操作除了在主节点执行之外,在从节点上也同样执行,这样我们就有多份同样的数据,一旦 主节点的数据因为各种天灾人祸无法恢复的时候,我们至少还有从节点可以依赖。但是主从延迟问题 可能会对上面两个效果都产生不好的影响。</span><br><span class="line"> </span><br><span class="line">如果主从延迟过大,主节点上会有很多数据更改没有同步到从节点上。这时候如果主节点故障,就有 两种情况:</span><br><span class="line">1）主节点故障并且无法恢复,如果应用上又无法忍受这部分数据的丢失,我们就得想各种办法将这部 数据更改找回来,再写入到从节点中去。可以想象,即使是有可能,那这也绝对是一件非常恶心的活。</span><br><span class="line">2）主节点能够恢复,但是需要花的时间比较长,这种情况如果应用能忍受,我们可以直接让从节点提 供服务,只是对用户来说,有一段时间的数据丢失了,而如果应用不能接受数据的不一致,那么就只能下线整个业务,等主节点恢复后再提供服务了。</span><br><span class="line"> </span><br><span class="line">如果你只有一个从节点,当主从延迟过大时,由于主节点只保存最近的一部分 oplog,可能会导致从 节点青黄不接,不得不进行 resync 操作,全量从主节点同步数据。</span><br><span class="line">带来的问题是：当从节点全量同步的时候,实际只有主节点保存了完整的数据,这时候如果主节点故障,很可能全 部数据都丢掉了。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-6实现Replica-Set"><a href="#2-6实现Replica-Set" class="headerlink" title="2.6实现Replica Set"></a>2.6实现Replica Set</h4><p>需要将原有的数据文件、日志文件删除，重新创建</p>
<ol>
<li>环境准备</li>
</ol>
<table>
<thead>
<tr>
<th>主机</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.146.220</td>
<td>N/A</td>
</tr>
<tr>
<td>192.168.146.221</td>
<td>N/A</td>
</tr>
<tr>
<td>192.168.146.222</td>
<td>N/A</td>
</tr>
</tbody></table>
<ol>
<li>mongodb.conf文件配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">logappend&#x3D;true</span><br><span class="line">port&#x3D;27017  #端口</span><br><span class="line">dbpath&#x3D;&#x2F;usr&#x2F;local&#x2F;mongodb409&#x2F;data&#x2F;db&#x2F; #数据库文件目录</span><br><span class="line">logpath&#x3D;&#x2F;usr&#x2F;local&#x2F;mongodb409&#x2F;data&#x2F;log&#x2F;mongod.log #数据库日志文件目录</span><br><span class="line">fork&#x3D;true #后台运行</span><br><span class="line">bind_ip&#x3D;192.168.146.220&#x2F;221&#x2F;222  #绑定的IP最好是自己服务器IP</span><br><span class="line">replSet&#x3D;replset #副本集名称</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>启动3台服务器上面的mongodb</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;mongodb408&#x2F;bin&#x2F;mongod -f &#x2F;usr&#x2F;local&#x2F;mongodb408&#x2F;conf&#x2F;mongodb.conf</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>初始化副本集</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;mongodb408&#x2F;bin&#x2F;mongo 192.168.3.172:27017 #副本集&#x3D;&gt;连接到一台机器</span><br><span class="line"></span><br><span class="line">&gt;rs.status() # 查看副本集状态</span><br><span class="line">&gt;rs.initiate() # 初始化副本集</span><br><span class="line">&gt;rs.add(&#39;IP:Port&#39;) #添加副本集成员</span><br><span class="line">&gt;rs.remove(&#39;IP:Port&#39;) #删除副本集成员</span><br><span class="line">&gt;rs.isMaster() #查询Primary</span><br><span class="line"></span><br><span class="line">&gt;cfg&#x3D;&#123; _id:&quot;replset&quot;, members:[ &#123;_id:0,host:&#39;192.168.3.221:27017&#39;&#125;,&#123;_id:1,host:&#39;192.168.3.222:27017&#39;&#125;]&#125;</span><br><span class="line">&gt;rs.reconfig(cfg,&#123;&quot;force&quot;:true&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>测试数据是否能同步</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> for(var i&#x3D;1;i&lt;&#x3D;10000;i++) db.users.insert(&#123;id:i,address:&quot;Beijing&quot;,name:&quot;gerry&quot;&#125;);</span><br><span class="line"> </span><br><span class="line"> &gt;show dbs;</span><br><span class="line"> ### 出现错误</span><br><span class="line"> _getErrorWithCode@src&#x2F;mongo&#x2F;shell&#x2F;utils.js:25:13</span><br><span class="line">Mongo.prototype.getDBs@src&#x2F;mongo&#x2F;shell&#x2F;mongo.js:139:1</span><br><span class="line">shellHelper.show@src&#x2F;mongo&#x2F;shell&#x2F;utils.js:882:13</span><br><span class="line">shellHelper@src&#x2F;mongo&#x2F;shell&#x2F;utils.js:766:15</span><br><span class="line">@(shellhelp2):1:1</span><br><span class="line"></span><br><span class="line">&gt;rs.slaveOk(); ### 全量同步primary中的数据</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>测试副本集的故障转移</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill -QUIT mongodb进程ID</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3、分片集群Sharding"><a href="#3、分片集群Sharding" class="headerlink" title="3、分片集群Sharding"></a>3、分片集群Sharding</h3><p>Sharding cluster是一种可以水平扩展的模式,在数据量很大时特给力,实际大规模应用一般会采用这种架构去构建。sharding分片很好的解决了单台服务器磁盘空间、内存、cpu等硬件资源的限制问题，把数据水平拆分出去，降低单节点的访问压力。每个分片都是一个独立的数据库，所有的分片组合起来构成一个逻辑上的完整的数据库。因此，分片机制降低了每个分片的数据操作量及需要存储的数据量，达到多台服务器来应对不断增加的负载和数据的效果。</p>
<h4 id="3-1Sharding分区概念"><a href="#3-1Sharding分区概念" class="headerlink" title="3.1Sharding分区概念"></a>3.1Sharding分区概念</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">分片 (sharding)是指将数据库拆分,将其分散在不同的机器上的过程。将数据分散到不同的机器上,不需要功能强大的服务器就可以存储更多的数据和处理更大的负载。</span><br><span class="line"> </span><br><span class="line">分片的基本思想就是：</span><br><span class="line">将集合切成小块,这些块分散到若干片里,每个片只负责总数据的一部分。通过一个名为 mongos 的路由进程进行操作,mongos 知道数据和片的对应</span><br><span class="line">关系(通过配置服务器)。 大部分使用场景都是解决磁盘空间的问题,对于写入有可能会变差(+++里面的说明+++),查 询则尽量避免跨分片查询。使用分片的时机:</span><br><span class="line"> </span><br><span class="line">使用场景：</span><br><span class="line">1）机器的磁盘不够用了。使用分片解决磁盘空间的问题。</span><br><span class="line">2）单个mongod已经不能满足写数据的性能要求。通过分片让写压力分散到各个分片上面,使用分片服务器自身的资源。</span><br><span class="line">3）想把大量数据放到内存里提高性能。和上面一样,通过分片使用分片服务器自身的资源。</span><br><span class="line"> </span><br><span class="line">要构建一个MongoDB Sharding Cluster（分片集群）,需要三种角色:</span><br><span class="line">1）分片服务器（Shard Server）</span><br><span class="line">   mongod 实例,用于存储实际的数据块,实际生产环境中一个 shard server 角色可由几台机器组个一个 relica set 承担,防止主机单点故障</span><br><span class="line">   这是一个独立普通的mongod进程,保存数据信息。可以是一个副本集也可以是单独的一台服务器。</span><br><span class="line">2）配置服务器（Config Server）</span><br><span class="line">   mongod 实例,存储了整个 Cluster Metadata,其中包括 chunk 信息。</span><br><span class="line">   这是一个独立的mongod进程,保存集群和分片的元数据,即各分片包含了哪些数据的信息。最先开始建立,启用日志功能。像启动普通的 mongod 一样启动</span><br><span class="line">   配置服务器,指定configsvr 选项。不需要太多的空间和资源,配置服务器的 1KB 空间相当于真是数据的 200MB。保存的只是数据的分布表。</span><br><span class="line">3）路由服务器（Route Server）</span><br><span class="line">   mongos实例,前端路由,客户端由此接入,且让整个集群看上去像单一数据库,前端应用</span><br><span class="line">   起到一个路由的功能,供程序连接。本身不保存数据,在启动时从配置服务器加载集群信息,开启 mongos 进程需要知道配置服务器的地址,指定configdb选项。</span><br><span class="line"> </span><br><span class="line">片键的意义</span><br><span class="line">一个好的片键对分片至关重要。 片键必须是一个索引 ,通 过 sh.shardCollection 加会自动创建索引。一个自增的片键对写入和数据均匀分布就不是很好, 因为自增的片键总会在一个分片上写入,后续达到某个阀值可能会写到别的分片。但是按照片键查询会非常高效。随机片键对数据的均匀分布效果很好。注意尽量避免在多个分片上进行查询。</span><br><span class="line">在所有分片上查询,mongos 会对结果进行归并排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">为何需要水平分片</span><br><span class="line">1）减少单机请求数,将单机负载,提高总负载 </span><br><span class="line">2）减少单机的存储空间,提高总存空间</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-2分片架构"><a href="#3-2分片架构" class="headerlink" title="3.2分片架构"></a>3.2分片架构</h4><p><strong>分片示意图:</strong></p>
<p><img src="D:\Typora\resources\app\asserts\icon\907596-20170604035137258-762254443.png" alt="907596-20170604035137258-762254443"></p>
<p><strong>mongodb sharding 服务器架构:</strong></p>
<p><img src="D:\Typora\resources\app\asserts\icon\907596-20170604035229055-909393426.png" alt="907596-20170604035229055-909393426"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">上图解释:</span><br><span class="line"></span><br><span class="line">分片集群主要由三种组件组成:mongos,config server,shard</span><br><span class="line">1) mongos  (路由进程, 应用程序接入 mongos 再查询到具体分片)</span><br><span class="line">数据库集群请求的入口,所有的请求都通过 mongos 进行协调,不需要在应用程序添加一个路由选择器,mongos 自己就是一个请求分发中心,它负责把对应的数据请求转发到对应的 shard 服务器上。在生产环境通常有多个 mongos 作为请求的入口,防止其中一个挂掉所有的 mongodb 请求都没有办法操作。</span><br><span class="line"> </span><br><span class="line">2) config server  (路由表服务。 每一台都具有全部 chunk 的路由信息)</span><br><span class="line">顾名思义为配置服务器,存储所有数据库元信息(路由、分片)的配置。mongos 本身没有物理存储分片服务器和数据路由信息,只是缓存在内存里,配置服务器则实际存储这些数据。mongos 第一次启动或者关掉重启就会从 config server 加载配置信息,以后如果配置服务器信息变化会通知到所有的 mongos 更新自己的状态,这样mongos 就能继续准确路由。在生产环境通常有多个 config server 配置服务器,因为它存储了分片路由的元数据,这个可不能丢失!就算挂掉其中一台,只要还有存货,</span><br><span class="line">mongodb 集群就不会挂掉。</span><br><span class="line"> </span><br><span class="line">3) shard  (为数据存储分片。 每一片都可以是复制集(replica set))</span><br><span class="line">这就是传说中的分片了。如图所示,一台机器的一个数据表 Collection1 存储了 1T 数据,压力太大了!在分给 4 个机器后, 每个机器都是 256G,则分摊了集中在一台机器的压力。事实上,上图4个分片如果没有副本集(replica set)是个不完整架构,假设其中的一个分片挂掉那四 分之一的数据就丢失了,所以在高可用性的分片架构还需要对于每一个分片构建 replica set 副本集保 证分片的可靠性。生产环境通常是 2 个副本 + 1 个仲裁。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-3分片配置实现"><a href="#3-3分片配置实现" class="headerlink" title="3.3分片配置实现"></a>3.3分片配置实现</h4><h5 id="3-3-1系统环境"><a href="#3-3-1系统环境" class="headerlink" title="3.3.1系统环境"></a>3.3.1系统环境</h5><p>Centos7.4、MongoDB4.0.8、关闭防火墙。</p>
<p>IP                         路由服务端口    配置服务端口    分片1端口    分片2端口<br>192.168.3.220    27017                      27018                        27001    27002<br>192.168.3.221    27017                      27018                        27001    27002<br>192.168.3.222    27017                      27018                        27001    27002</p>
<p><img src="D:\Typora\resources\app\asserts\icon\845791bd1c2593ec43ed1fd7877decb82fc.jpg" alt="845791bd1c2593ec43ed1fd7877decb82fc"></p>
<p>三台机器的配置服务(27018)形成复制集，分片1、2、3也在各机器都部署一个实例，它们之间形成复制集，客户端直接连接3个路由服务与之交互，配置服务和分片服务对客户端是透明的。</p>
<h5 id="3-3-2-服务器的安装及配置-3台服务器执行相同操作"><a href="#3-3-2-服务器的安装及配置-3台服务器执行相同操作" class="headerlink" title="3.3.2  服务器的安装及配置(3台服务器执行相同操作)"></a>3.3.2  服务器的安装及配置(3台服务器执行相同操作)</h5><ol>
<li><p>下载解压MongoDB</p>
<p>到MongoDB官网下载：<a target="_blank" rel="noopener" href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.2.tgz">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.2.tgz</a></p>
<p>解压到/home/mongodb，设置环境变量:</p>
<p>export PATH=$PATH:/home/mongodb/bin<br>保存后执行：</p>
<p>srouce /etc/profile</p>
</li>
<li><p>创建路由、配置、分片等的相关目录与文件</p>
<p>启动配置文件存放的文件夹：mkdir -p /home/mongodb/conf<br>配置服务数据存放目录：mkdir -p /home/mongodb/data/config<br>分片1服务数据存放目录：mkdir -p /home/mongodb/data/shard1<br>分片2服务数据存放目录：mkdir -p /home/mongodb/data/shard2<br>分片3服务数据存放目录：mkdir -p /home/mongodb/data/shard3<br>配置服务日志存放文件：mkdir -p /home/mongodb/log/config.log<br>路由服务日志存放文件：mkdir -p /home/mongodb/log/mongos.log<br>分片1服务日志存放文件：mkdir -p /home/mongodb/log/shard1.log<br>分片2服务日志存放文件：mkdir -p /home/mongodb/log/shard2.log<br>分片3服务日志存放文件：mkdir -p /home/mongodb/log/shard3.log</p>
</li>
</ol>
<h5 id="3-3-3-配置服务器部署-3台服务器执行相同操作"><a href="#3-3-3-配置服务器部署-3台服务器执行相同操作" class="headerlink" title="3.3.3 配置服务器部署(3台服务器执行相同操作)"></a>3.3.3 配置服务器部署(3台服务器执行相同操作)</h5><ol>
<li><p>在/home/mongodb/conf目录创建config.conf</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dbpath=/home/mongodb/data/config</span><br><span class="line">logpath=/home/mongodb/log/config.log</span><br><span class="line">port=27018</span><br><span class="line">logappend=true</span><br><span class="line">fork=true</span><br><span class="line">maxConns=5000</span><br><span class="line"><span class="meta">#</span><span class="bash">复制集名称</span></span><br><span class="line">replSet=configs</span><br><span class="line"><span class="meta">#</span><span class="bash">置参数为<span class="literal">true</span></span></span><br><span class="line">configsvr=true</span><br><span class="line"><span class="meta">#</span><span class="bash">允许任意机器连接</span></span><br><span class="line">bind_ip=0.0.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>配置复制集</p>
<p>分别启动三台服务器的配置服务： </p>
<p>mongod -f /home/mongodb/conf/config.conf<br>连接mongo,只需在任意一台机器执行即可：</p>
<p>mongo –host 192.168.3.220 –port 27018<br>切换数据库：</p>
<p>use admin<br>初始化复制集：</p>
<p>rs.initiate({_id:”configs”,members:[{_id:0,host:”192.168.3.220:27018”},{_id:1,host:”192.168.3.221:27018”}, {_id:2,host:”192.168.3.222:27018”}]})<br>其中_id:”configs”的configs是上面config.conf配置文件里的复制集名称，把三台服务器的配置服务组成复制集。</p>
<p>查看状态：</p>
<p>rs.status()</p>
<p>等几十秒左右，执行上面的命令查看状态，三台机器的配置服务就已形成复制集，其中1台为PRIMARY，其他2台为SECONDARY。</p>
</li>
</ol>
<h5 id="3-3-4-分片服务部署-3台服务器执行相同操作"><a href="#3-3-4-分片服务部署-3台服务器执行相同操作" class="headerlink" title="3.3.4 分片服务部署(3台服务器执行相同操作)"></a>3.3.4 分片服务部署(3台服务器执行相同操作)</h5><ol>
<li><p>在/home/mongodb/conf目录创建shard1.conf、shard2.conf、shard3.conf</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bpath=/home/mongodb/data/shard1 #其他2个分片对应修改为shard2、shard3文件夹</span><br><span class="line">logpath=/home/mongodb/log/shard1.log #其他2个分片对应修改为shard2.log、shard3.log</span><br><span class="line">port=27001 #其他2个分片对应修改为27002、27003</span><br><span class="line">logappend=true</span><br><span class="line">fork=true</span><br><span class="line">maxConns=5000</span><br><span class="line">storageEngine=mmapv1</span><br><span class="line">shardsvr=true</span><br><span class="line">replSet=shard1 #其他2个分片对应修改为shard2、shard3</span><br><span class="line">bind_ip=0.0.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>端口分别是27001、27002、27003，分别对应shard1.conf、shard2.conf、shard3.conf。</p>
<p>还有数据存放目录、日志文件这几个地方都需要对应修改。</p>
<p>在3台机器的相同端口形成一个分片的复制集，由于3台机器都需要这3个文件，所以根据这9个配置文件分别启动分片服务：</p>
<p>mongod -f /home/mongodb/conf/shard{1/2/3}.conf</p>
</li>
<li><p>将分片配置为复制集</p>
<p>连接mongo，只需在任意一台机器执行即可：</p>
<p>mongo –host 192.168.3.220 –port 27001 //这里以shard1为例，其他两个分片则再需对应连接到27002、27003的端口进行操作即可<br>切换数据库：</p>
<p>use admin<br>初始化复制集：</p>
<p>rs.initiate({_id:”shard1”,members:[{_id:0,host:”192.168.3.220:27001”},{_id:1,host:”192.168.3.221:27001”},{_id:2,host:”192.168.3.222:27001”}]})<br>以上是基于分片1来操作，同理，其他2个分片也要连到各自的端口来执行一遍上述的操作，让3个分片各自形成1主2从的复制集，注意端口及仲裁节点的问题即可，操作完成后3个分片都启动完成，并完成复集模式。</p>
</li>
</ol>
<h5 id="3-3-5-路由服务部署-3台服务器执行相同操作"><a href="#3-3-5-路由服务部署-3台服务器执行相同操作" class="headerlink" title="3.3.5 路由服务部署(3台服务器执行相同操作)"></a>3.3.5 路由服务部署(3台服务器执行相同操作)</h5><ol>
<li><p>在/home/mongodb/conf目录创建mongos.conf</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ogpath=/home/mongodb/log/mongos.log</span><br><span class="line">logappend = true</span><br><span class="line">port = 27017</span><br><span class="line">fork = true</span><br><span class="line">configdb = configs/192.168.3.220:27018,192.168.3.221:27018,192.168.3.222:27018</span><br><span class="line">maxConns=20000</span><br><span class="line">bind_ip=0.0.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>启动mongos</p>
<p>分别在三台服务器启动：</p>
<p>mongos -f /home/mongodb/conf/mongos.conf</p>
</li>
<li><p>启动分片功能</p>
<p>连接mongo：</p>
<p>mongo –host 192.168.3.220 –port 27017<br>切换数据库：</p>
<p>use admin<br>添加分片，只需在一台机器执行即可：        </p>
<p>sh.addShard(“shard1/192.168.3.220:27001,192.168.3.221:27001,192.168.3.222:27001”)<br>sh.addShard(“shard2/192.168.3.220:27002,192.168.3.221:27002,192.168.3.222:27002”)<br>sh.addShard(“shard3/192.168.3.220:27003,192.168.3.221:27003,192.168.3.222:27003”)<br>查看集群状态：</p>
<p>sh.status()</p>
</li>
<li><p>实现分片功能</p>
<p>设置分片chunk大小        </p>
<p>use config<br>db.setting.save({“_id”:”chunksize”,”value”:1}) # 设置块大小为1M是方便实验，不然需要插入海量数据</p>
</li>
<li><p>模拟写入数据</p>
<p>use calon<br>for(i=1;i&lt;=50000;i++){db.user.insert({“id”:i,”name”:”jack”+i})} #模拟往calon数据库的user表写入5万数据</p>
</li>
<li><p>启用数据库分片</p>
<p>sh.enableSharding(“calon”)</p>
</li>
<li><p>创建索引，对表进行分片</p>
<p>db.user.createIndex({“id”:1}) # 以”id”作为索引<br>sh.shardCollection(calon.user”,{“id”:1}) # 根据”id”对user表进行分片<br>sh.status() # 查看分片情况</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/20/Nginx%E3%80%81MyCat%E3%80%81MongoDB/" data-id="ckk50chc3000kegmza8h7axb7" data-title="Nginx、Mycat、MongoDB" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">框架及中间件</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/01/20/es/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          es
        
      </div>
    </a>
  
  
    <a href="/2021/01/20/Dubbo%E3%80%81Netty%E3%80%81JMS%E3%80%81AMQP/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Dubbo、Netty、JMS、AMQP</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80/" rel="tag">java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">框架及中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 16.67px;">java基础</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 10px;">大数据</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 13.33px;">服务器</a> <a href="/tags/%E6%A1%86%E6%9E%B6%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 20px;">框架及中间件</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/20/Arthas/">Arthas</a>
          </li>
        
          <li>
            <a href="/2021/01/20/COLA/">COLA</a>
          </li>
        
          <li>
            <a href="/2021/01/20/HazelCast%E3%80%81Ignite/">HazelCast、Ignite</a>
          </li>
        
          <li>
            <a href="/2021/01/20/Shiro%E3%80%81Spring%20Security/">Shiro、Spring Security</a>
          </li>
        
          <li>
            <a href="/2021/01/20/cucumber/">cucumber</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
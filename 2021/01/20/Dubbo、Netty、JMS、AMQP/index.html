<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Dubbo、Netty、JMS、AMQP | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Dubbo简单实用项目应用1.创建一个maven父项目主要用于版本控制 1234567891011121314151617181920212223242526272829303132&lt;dependencyManagement&gt;    &lt;dependencies&gt;      &lt;dependency&gt;        &lt;groupId&gt;org.projec">
<meta property="og:type" content="article">
<meta property="og:title" content="Dubbo、Netty、JMS、AMQP">
<meta property="og:url" content="http://example.com/2021/01/20/Dubbo%E3%80%81Netty%E3%80%81JMS%E3%80%81AMQP/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Dubbo简单实用项目应用1.创建一个maven父项目主要用于版本控制 1234567891011121314151617181920212223242526272829303132&lt;dependencyManagement&gt;    &lt;dependencies&gt;      &lt;dependency&gt;        &lt;groupId&gt;org.projec">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:/Typora/resources/app/asserts/icon/1556888914380.png">
<meta property="og:image" content="d:/Typora/resources/app/asserts/icon/1556888985648.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553326640593.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553248929136.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553265921711.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553266422464.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553266301430.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553252425296.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553335854885.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553406783277.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553407461457.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553415250572.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553416384973.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553418773318.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553421288581.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553603924034.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553603947340.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553604903198.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553783881131.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553785003285.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553785364607.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553785247263.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553835916799.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553911572200.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553846233867.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553862424112.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553953835310.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553956783900.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553957959977.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553995279589.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553995778445.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553996635996.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553997969062.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1553998094639.png">
<meta property="og:image" content="https://img-blog.csdn.net/20150817113531436">
<meta property="og:image" content="https://img-blog.csdn.net/20150817113626248">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1554089086467.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1554101586395.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1554105610378.png">
<meta property="og:image" content="c:/Users/Administrator/AppData/Local/Temp/1554104930623.png">
<meta property="og:image" content="d:/Typora/resources/app/asserts/icon/QQ图片20190630095208.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15356343-1386aef5785dfa6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/939/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15356343-30a590133aa5ba1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/907/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15356343-0ae4d35569baec4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/895/format/webp">
<meta property="article:published_time" content="2021-01-19T16:00:00.000Z">
<meta property="article:modified_time" content="2021-01-20T06:09:09.353Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="框架及中间件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/Typora/resources/app/asserts/icon/1556888914380.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Dubbo、Netty、JMS、AMQP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/20/Dubbo%E3%80%81Netty%E3%80%81JMS%E3%80%81AMQP/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T16:00:00.000Z" itemprop="datePublished">2021-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Dubbo、Netty、JMS、AMQP
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Dubbo简单实用"><a href="#Dubbo简单实用" class="headerlink" title="Dubbo简单实用"></a>Dubbo简单实用</h1><h2 id="项目应用"><a href="#项目应用" class="headerlink" title="项目应用"></a>项目应用</h2><h3 id="1-创建一个maven父项目"><a href="#1-创建一个maven父项目" class="headerlink" title="1.创建一个maven父项目"></a>1.创建一个maven父项目</h3><p>主要用于版本控制</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!--引入打包到本地maven仓库的api接口--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.charlie.dubbo.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>user-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-bate<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--SpringBoot版本管理--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!--引入dubbo--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-定义接口maven模块"><a href="#2-定义接口maven模块" class="headerlink" title="2.定义接口maven模块"></a>2.定义接口maven模块</h3><ol>
<li><p>修改pom.xml的父类为dubbo-parent</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.charlie.dubbo.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-bate<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>定义实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>项目结构：</p>
</li>
</ol>
<p><img src="D:\Typora\resources\app\asserts\icon\1556888914380.png" alt="1556888914380"></p>
<p>完成模块后打包到maven本地方别进行接口引入</p>
<p><img src="D:\Typora\resources\app\asserts\icon\1556888985648.png" alt="1556888985648"></p>
<h3 id="3-定义实现接口的springboot模块"><a href="#3-定义实现接口的springboot模块" class="headerlink" title="3.定义实现接口的springboot模块"></a>3.定义实现接口的springboot模块</h3><ol>
<li><p>修改pom.xml的父模块为dubbo-parent</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.charlie.dubbo.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-bate<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入接口依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.charlie.dubbo.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>user-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入dubbo依赖，包含zookeeper和curator--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在启动类上启用dubbo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDubboConfig</span>	<span class="comment">//启用dubbo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProviderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(UserProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置dubbo服务</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10011</span></span><br><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span>  <span class="comment">#注册的业务名称</span></span><br><span class="line">  <span class="attr">protocol:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">20880</span>		<span class="comment">#协议端口</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181</span></span><br></pre></td></tr></table></figure></li>
<li><p>实现接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Service(retries = 1,interfaceClass = UserService.class)</span><span class="comment">//dubbo业务定义重试一次,实现的接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户编号&quot;</span>+user.getId()+<span class="string">&quot;，用户名称&quot;</span>+user.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps:这里的Service为com.alibaba.dubbo.config.annotation.Service;</p>
</li>
</ol>
<h3 id="4-定义消费接口的springboot模块"><a href="#4-定义消费接口的springboot模块" class="headerlink" title="4.定义消费接口的springboot模块"></a>4.定义消费接口的springboot模块</h3><ol>
<li><p>引入接口和dubbo依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.charlie.dubbo.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-bate<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入接口依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.charlie.dubbo.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>user-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入dubbo依赖，包含zookeeper和curator--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动类上启动dubbo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDubbo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProviderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(UserProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>修改application.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10012</span></span><br><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-webapi</span>  <span class="comment">#注册的业务名称</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>通过@Reference引用服务端业务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference</span></span><br><span class="line">   <span class="keyword">private</span> UserService userService;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       User user = <span class="keyword">new</span> User();</span><br><span class="line">       user.setId(<span class="number">111L</span>);</span><br><span class="line">       user.setName(<span class="string">&quot;陈翰林&quot;</span>);</span><br><span class="line">       System.out.println(userService.addUser(user));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<h1 id="NIO通信"><a href="#NIO通信" class="headerlink" title="NIO通信"></a>NIO通信</h1></li>
</ol>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>同步</li>
<li>异步</li>
<li>阻塞</li>
<li>非阻塞</li>
</ul>
<p><strong>阻塞/非阻塞</strong>关注的是程序在等待调用结果时的状态。</p>
<p><em>阻塞调用指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回</em></p>
<p><em>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程</em></p>
<p><strong>同步/异步</strong>关注的是消息通信机制</p>
<p><em>所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回</em></p>
<p><em>异步则是相反，调用在发出之后，这个调用就直接返回了</em></p>
<p><strong>总结</strong></p>
<p><strong>阻塞/非阻塞</strong>进程在访问数据的时候，是否需要缓冲区中的数据准备就绪。</p>
<p>阻塞：往往需要等待缓冲区中的数据准备好过后才处理其他的事务，否则一直等待在那里面。</p>
<p>非阻塞：当我们的进程访问数据缓冲区的时候，数据没有准备好，直接返回不需要等待，数据准备好了，也直接返回。</p>
<p><strong>同步/异步</strong>基于应用程序和操作系统出了IO事件锁采用的方式</p>
<p>同步：应用程序要直接参与IO读写的操作，同步的方式在处理IO事件的时候必须阻塞在某个方法上面等待IO事件完成（阻塞事件或者通过轮询IO事件的方式）</p>
<p>异步：所有的IO读写都交给操作系统去处理，由于所有的IO读写都交给了操作系统，所以它可以去做其他的事情，并不需要等到IO事件完成。当操作的IO事件完成后，给我们的应用程序一个通知就OK</p>
<p><strong>同步方式</strong></p>
<ol>
<li>阻塞到IO事件，阻塞read/write，完全不能做其他的事情</li>
<li>IO事件的轮询——多路复用技术（selector模式），阻塞的是selector的轮询线程，不是所有的IO线程</li>
</ol>
<h2 id="JAVA-IO模型"><a href="#JAVA-IO模型" class="headerlink" title="JAVA IO模型"></a>JAVA IO模型</h2><p>BIO：JDK1.4版本之前使用的都是BIO，同步阻塞，接受请求和处理请求是一个线程，所以处理请求时，接受请求阻塞，客户端不能返回，虽然可以启动一个线程去单独处理每一个请求，但会占用更多系统内存</p>
<p>NIO：JDK1.4版本之后 引入linux Selector模式的多路复用技术，实现IO事务的轮询，完成同步非阻塞方式，现在主流网络通信模式 优秀框架有mina2，netty5（主流）</p>
<p>AIO：真正实现了异步IO，使用linux epoll模式</p>
<h2 id="NIO的原理"><a href="#NIO的原理" class="headerlink" title="NIO的原理"></a>NIO的原理</h2><p><img src="C:\Users\Administrator\AppData\Local\Temp\1553326640593.png" alt="1553326640593"></p>
<p>通过selector(选择器)管理所有的IO</p>
<p>Connection 接受所有客户端和服务端的IO事件</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553248929136.png" alt="1553248929136"></p>
<p><strong>selector</strong>如何进行管理IO事件</p>
<p>当IO事件注册给我们的选择器的时候，选择器会给他们分配一个key，当IO事件完成后可以通过key值来找到相应的通道，然后通过通道发送数据和接收数据操作</p>
<p><strong>通道</strong></p>
<p>通道是对原IO包中流的模拟。通道是双向的，而流是单向的。所有要写入通道的字节都需要先写入缓冲区，然后通道从缓冲区读取字节，同样所有要从通道读取的字节也需要从通道写入缓冲区，然后从缓冲区读取字节</p>
<p><strong>通道的类型</strong></p>
<ul>
<li><p>FileChannel通道</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile (<span class="string">&quot;somefile&quot;</span>, <span class="string">&quot;r&quot;</span>); </span><br><span class="line">FileChannel fc = raf.getChannel( );</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>ServerSocketChannel通道</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(somelocalport));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>SocketChannel通道</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel sc = SocketChannel.open( ); </span><br><span class="line">sc.connect (<span class="keyword">new</span> InetSocketAddress (<span class="string">&quot;somehost&quot;</span>, someport));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>DatagramChannel通道</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatagramChannel dc = DatagramChannel.open( );</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>数据缓冲区</strong></p>
<p>为了解决IO设备与CPU之间速度的不匹配。</p>
<p>当应用程序将要读取某块数据的时候，如果这块数据已经存放在缓冲区中，那么就可以立即返回给程序，而不需要经过实际的读取设备操作。当然，如果数据在读取之前并未被存入缓冲区，那么系统会将一大块数据从设备先读取到缓冲区中。对于写入操作来说也是同样的道理，通常应用程序也会先将数据陆续写入到缓冲区中，直到缓冲区被写满或者文件关闭时才一次性地写入到设备中。 </p>
<p>通过多种缓冲区类型，提供很多读写的方法put(),get()，和BIO不同的是不是使用流的读写而是缓冲区的读写</p>
<p><strong>缓冲区的类型</strong></p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<p><strong>数据缓冲区属性</strong></p>
<ul>
<li>Capacity容量：能够容纳元素的最大量，一旦设定是无法更改的</li>
<li>Limit 上界：缓冲区的第一个不能被读或者写的元素</li>
<li>Position位置：下一个要操作的数据元素的位置</li>
<li>Mark标记：标记position的前一个位置，方便之后通过reset()恢复该位置</li>
</ul>
<p>属性间的关系：0&lt;=mark&lt;=position&lt;limit&lt;=capacity</p>
<ul>
<li>初始化时各属性的值(这里mark应该为0)</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553265921711.png" alt="1553265921711"></p>
<ul>
<li>切换到读模式(这里mark应该为0)</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553266422464.png" alt="1553266422464"></p>
<p>position的位置随着get方法往后移动，初始为0</p>
<ul>
<li><p>切换到写模式(这里mark应该为0)</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553266301430.png" alt="1553266301430"></p>
<p>position的位置是读模式limit的位置</p>
</li>
<li><p>读写模式的切换通过ByteBuffer缓冲对象的flip()方法</p>
</li>
</ul>
<p><strong>选择器</strong>：Selector selector = Select.open();这样就打开了选择器</p>
<h2 id="SelectKey"><a href="#SelectKey" class="headerlink" title="SelectKey"></a>SelectKey</h2><p>可以通过它来判断IO事件是否已经就绪</p>
<p>key.isAcceptable:是否可以接受客户端的连接</p>
<p>key.isConnectionable():是否可以连接服务器端</p>
<p>key.isReadable():缓冲区是否可读</p>
<p>key.isWriteable():缓冲区是否可写</p>
<p>SelectionKey key = Selector.selectKeys();获取selectKey</p>
<h2 id="如何注册"><a href="#如何注册" class="headerlink" title="如何注册"></a>如何注册</h2><p>channel.regist(Selector,SelectionKey.IO_Write);</p>
<p>channel.regist(Selector,SelectionKey.IO_Read);</p>
<p>channel.regist(Selector,SelectionKey.IO_Connect);</p>
<p>channel.regist(Selector,SelectionKey.IO_Accept);</p>
<h2 id="Linux的虚拟内存"><a href="#Linux的虚拟内存" class="headerlink" title="Linux的虚拟内存"></a>Linux的虚拟内存</h2><p><img src="C:\Users\Administrator\AppData\Local\Temp\1553252425296.png" alt="1553252425296"></p>
<p>Linux的虚拟内存空间分为Kernel space内核空间和User space用户空间。为了安全，他们是隔离的，即使用户程序崩溃了，内核也不受影响。</p>
<p>当进程运行在内核空间时就处于内核态，当进程运行在用户空间时就处于用户态。 </p>
<p>Kernel space 可以执行任意命令，调用系统的一切资源；User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。 </p>
<h2 id="缓冲区代码示例"><a href="#缓冲区代码示例" class="headerlink" title="缓冲区代码示例"></a>缓冲区代码示例</h2><h3 id="缓冲区的直接读写"><a href="#缓冲区的直接读写" class="headerlink" title="缓冲区的直接读写"></a>缓冲区的直接读写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 创建ByteBuffer缓冲区，容量为10</span></span><br><span class="line">      ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">      <span class="comment">//写入五个字符的字节码</span></span><br><span class="line">      byteBuffer.put(((<span class="keyword">byte</span>) <span class="string">&#x27;G&#x27;</span>)).put(((<span class="keyword">byte</span>) <span class="string">&#x27;e&#x27;</span>)).put(((<span class="keyword">byte</span>) <span class="string">&#x27;r&#x27;</span>)).put(((<span class="keyword">byte</span>) <span class="string">&#x27;r&#x27;</span>)).put(((<span class="keyword">byte</span>) <span class="string">&#x27;y&#x27;</span>));</span><br><span class="line">      <span class="comment">// 写模式切换读模式</span></span><br><span class="line">      byteBuffer.flip();</span><br><span class="line">      <span class="comment">// 读取缓冲区的2个字节,position变为2</span></span><br><span class="line">      System.out.println(<span class="string">&quot;&quot;</span>+((<span class="keyword">char</span>) byteBuffer.get()) + ((<span class="keyword">char</span>) byteBuffer.get()) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="comment">// 使用mark标记当前position的位置，值为2</span></span><br><span class="line">      byteBuffer.mark();</span><br><span class="line">      <span class="comment">// 读取2个元素，并且恢复到之前mark的位置处</span></span><br><span class="line">      System.out.println(<span class="string">&quot;&quot;</span>+((<span class="keyword">char</span>) byteBuffer.get()) + ((<span class="keyword">char</span>) byteBuffer.get()) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">      byteBuffer.reset(); <span class="comment">// 让其回到刚刚标记位置</span></span><br><span class="line">      System.out.println(byteBuffer.position());</span><br><span class="line">      <span class="comment">/*while (byteBuffer.hasRemaining()) &#123;//循环打印出position到limit的所有数据</span></span><br><span class="line"><span class="comment">          System.out.print(((char) byteBuffer.get()));</span></span><br><span class="line"><span class="comment">      &#125;*/</span></span><br><span class="line">   System.out.println(<span class="keyword">new</span> String(byteBuffer.array(),<span class="number">0</span>,byteBuffer.limit()));</span><br><span class="line">      System.out.println(<span class="string">&quot;\n========================&quot;</span>);</span><br><span class="line">      <span class="comment">// 释放已经读取的空间，即position往前移动一位</span></span><br><span class="line">      System.out.println(byteBuffer.compact().position()); </span><br><span class="line">      System.out.println(byteBuffer);</span><br><span class="line"><span class="comment">//重复读取,position置0</span></span><br><span class="line">byteBuffer.rewind();</span><br><span class="line"><span class="comment">//clear只清空四个基本属性为初始值，保存的数据并没有清空，会被覆盖</span></span><br><span class="line">       byteBuffer.clear();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">          System.out.print(((<span class="keyword">char</span>) byteBuffer.get()));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="文件缓冲区的读写"><a href="#文件缓冲区的读写" class="headerlink" title="文件缓冲区的读写"></a>文件缓冲区的读写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//项目需要抛出异常</span></span><br><span class="line"><span class="comment">//定义文件输入流，绑定文件位置</span></span><br><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D://SpringBoot的课程大纲.md&quot;</span>);</span><br><span class="line">      <span class="comment">// 获取输入流的通道</span></span><br><span class="line">      FileChannel fc = fin.getChannel();</span><br><span class="line">      <span class="comment">// 创建字节缓冲区</span></span><br><span class="line">      ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">      Charset charset = Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">      <span class="comment">// 把通道中的数据读取到缓冲区中</span></span><br><span class="line">      fc.read(buffer);</span><br><span class="line">      <span class="comment">// 切换写模式为读模式</span></span><br><span class="line">      buffer.flip();</span><br><span class="line">      <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">          System.out.println(charset.decode(buffer).toString());</span><br><span class="line">          buffer.clear();</span><br><span class="line">      &#125;</span><br><span class="line">      fin.close();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line"></span><br><span class="line">      RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;D://SpringBoot的课程大纲.md&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建字符集对象</span></span><br><span class="line">      Charset charset = Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">      FileChannel inChannel = aFile.getChannel();</span><br><span class="line">      ByteBuffer buf = ByteBuffer.allocate(((<span class="keyword">int</span>) inChannel.size()));</span><br><span class="line">      <span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">          System.out.println(<span class="string">&quot;Read &quot;</span> + bytesRead);</span><br><span class="line">          buf.flip();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">              System.out.println(charset.decode(buf).toString());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//System.out.println(charset.decode(buf).toString());</span></span><br><span class="line">          buf.clear();</span><br><span class="line">          bytesRead = inChannel.read(buf);</span><br><span class="line">      &#125;</span><br><span class="line">      aFile.close();</span><br><span class="line">      inChannel.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="NIO缓冲区的分类"><a href="#NIO缓冲区的分类" class="headerlink" title="NIO缓冲区的分类"></a>NIO缓冲区的分类</h2><ol>
<li><p>直接缓冲区</p>
<p>存放在物理内存中的缓冲区，IO速度更快</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>非直接缓冲区</p>
<p>主要存放在Jvm缓冲区中，来回拷贝</p>
<p>可以把一个数据文件分散写入到不同非直接缓冲区中然后分别读取，直接缓冲区不支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="多路复用模式"><a href="#多路复用模式" class="headerlink" title="多路复用模式"></a>多路复用模式</h2><p><img src="C:\Users\Administrator\AppData\Local\Temp\1553335854885.png" alt="1553335854885"></p>
<ol>
<li><p>创建一个Selector</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>将通道注册在Selector选择器上</p>
</li>
<li><p>register()方法返回一个SelectionKey，是用于跟踪这些被注册事件的句柄 </p>
</li>
<li><p>将返回的SelectionKey保存在Keys集合中</p>
</li>
<li><p>执行Selector的select()方法，如果与SelectionKey相关的事件发生了，这个SelectionKey就被加入到selected-keys集合中 ，但如果关闭了与SelectionKey对象关联的Channel对象，或者调用了SelectionKey对象的cancel方法，这个SelectionKey对象就会被加入到cancelled-keys集合中，表示这个SelectionKey对象已经被取消 </p>
</li>
<li><p>select()返回</p>
</li>
<li><p>一个线程轮询处理</p>
</li>
<li><p>处理完成后remove移除selectedKeys</p>
</li>
</ol>
<h2 id="注册事件的分类"><a href="#注册事件的分类" class="headerlink" title="注册事件的分类"></a>注册事件的分类</h2><ol>
<li>SelectionKey.OP_CONNECT  — 连接就绪事件，表示客户端与服务器的连接已经建立成功</li>
<li>SelectionKey.OP_ACCEPT   — 接收连接事件，表示服务器监听到了客户连接，服务器可以接收这个连接了</li>
<li>SelectionKey.OP_READ     — 读事件，表示通道中已经有了可读的数据，可以执行读操作了</li>
<li>SelectionKey.OP_WRITE    — 写事件，表示已经可以向通道写数据了</li>
</ol>
<h2 id="NIO实现原理"><a href="#NIO实现原理" class="headerlink" title="NIO实现原理"></a>NIO实现原理</h2><ul>
<li><p>服务端和客户端各自维护一个管理管道的对象，我们称之为选择器selector</p>
</li>
<li><p>该选择器能检测一个或多个通道(channel)上的事件</p>
</li>
<li><p>服务端的处理线程会轮询地访问selector</p>
</li>
<li><p>如果访问selector时发现有感兴趣的事件到达，则处理这些事件。如果没有感兴趣的事件到达，则处理线程会一直阻塞直到感兴趣的事件到达位置</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553406783277.png" alt="1553406783277"></p>
<center>NIO服务端通信时序图</center>

<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553407461457.png" alt="1553407461457"></p>
</li>
</ul>
<center>NIO客户端通信时序图</center>

<h2 id="NIO代码示例"><a href="#NIO代码示例" class="headerlink" title="NIO代码示例"></a>NIO代码示例</h2><p>NIO服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*标识数字*/</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*缓冲区大小*/</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> BLOCK = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">/*接受数据缓冲区*/</span></span><br><span class="line">    <span class="keyword">private</span>  ByteBuffer sendbuffer = ByteBuffer.allocate(BLOCK);</span><br><span class="line">    <span class="comment">/*发送数据缓冲区*/</span></span><br><span class="line">    <span class="keyword">private</span>  ByteBuffer receivebuffer = ByteBuffer.allocate(BLOCK);</span><br><span class="line">    <span class="keyword">private</span>  Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NIOServer</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 打开服务器通道</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 服务器配置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 检索与此通道关联的服务器套接字</span></span><br><span class="line">        ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">        <span class="comment">// 进行服务的绑定</span></span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        <span class="comment">// 通过open()方法找到Selector</span></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">// 注册到selector，等待连接</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;Server Start----8888:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 轮询IO事件</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=====&quot;</span>);</span><br><span class="line">            <span class="comment">// 选择一组键，并且相应的通道已经打开</span></span><br><span class="line">            <span class="comment">//如果没有客户端连接，此方法将阻塞</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">// 返回此选择器的已选择键集。</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                handleKey(selectionKey);</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleKey</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 接受请求</span></span><br><span class="line">        ServerSocketChannel server = <span class="keyword">null</span>;</span><br><span class="line">        SocketChannel client = <span class="keyword">null</span>;</span><br><span class="line">        String receiveText;</span><br><span class="line">        String sendText;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 测试此键的通道是否已准备好接受新的套接字连接。</span></span><br><span class="line">        <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// 返回为此键对应的通道。</span></span><br><span class="line">            server = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">// 接受到此通道套接字的连接。</span></span><br><span class="line">            <span class="comment">// 此方法返回的套接字通道（如果有）将处于阻塞模式。</span></span><br><span class="line">            client = server.accept();</span><br><span class="line">            <span class="comment">// 配置为非阻塞</span></span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 注册到selector，等待连接</span></span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// 返回此键的通道。</span></span><br><span class="line">            client = (SocketChannel) selectionKey.channel();</span><br><span class="line">            <span class="comment">//将缓冲区清空以备下次读取</span></span><br><span class="line">            receivebuffer.clear();</span><br><span class="line">            <span class="comment">//读取服务器发送来的数据到缓冲区中</span></span><br><span class="line">            count = client.read(receivebuffer);</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                receiveText = <span class="keyword">new</span> String( receivebuffer.array(),<span class="number">0</span>,count);</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器端接受客户端数据--:&quot;</span>+receiveText);</span><br><span class="line">                client.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isWritable()) &#123;</span><br><span class="line">            <span class="comment">//将缓冲区清空以备下次写入</span></span><br><span class="line">            sendbuffer.clear();</span><br><span class="line">            <span class="comment">// 返回为之创建此键的通道。</span></span><br><span class="line">            client = (SocketChannel) selectionKey.channel();</span><br><span class="line">            sendText=<span class="string">&quot;message from server--&quot;</span> + flag++;</span><br><span class="line">            <span class="comment">//向缓冲区中输入数据</span></span><br><span class="line">            sendbuffer.put(sendText.getBytes());</span><br><span class="line">            <span class="comment">//将缓冲区各标志复位,因为向里面put了数据标志被改变要想从中读取数据发向服务器,就要复位</span></span><br><span class="line">            sendbuffer.flip();</span><br><span class="line">            <span class="comment">//输出到通道</span></span><br><span class="line">            client.write(sendbuffer);</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器端向客户端发送数据--：&quot;</span>+sendText);</span><br><span class="line">            client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8888</span>;</span><br><span class="line">        NIOServer server = <span class="keyword">new</span> NIOServer(port);</span><br><span class="line">        server.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>NIO客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*标识数字*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*缓冲区大小*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> BLOCK = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">/*接受数据缓冲区*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer sendbuffer = ByteBuffer.allocate(BLOCK);</span><br><span class="line">    <span class="comment">/*发送数据缓冲区*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer receivebuffer = ByteBuffer.allocate(BLOCK);</span><br><span class="line">    <span class="comment">/*服务器端地址*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> InetSocketAddress SERVER_ADDRESS = <span class="keyword">new</span> InetSocketAddress(</span><br><span class="line">            <span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 打开socket通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">// 设置为非阻塞方式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 打开选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 注册连接服务端socket动作</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">        <span class="comment">// 连接</span></span><br><span class="line">        socketChannel.connect(SERVER_ADDRESS);</span><br><span class="line">        <span class="comment">// 分配缓冲区大小内存</span></span><br><span class="line"></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeys;</span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator;</span><br><span class="line">        SelectionKey selectionKey;</span><br><span class="line">        SocketChannel client;</span><br><span class="line">        String receiveText;</span><br><span class="line">        String sendText;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//选择一组键，其相应的通道已为 I/O 操作准备就绪。</span></span><br><span class="line">            <span class="comment">//此方法执行处于阻塞模式的选择操作。</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//返回此选择器的已选择键集。</span></span><br><span class="line">            selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//System.out.println(selectionKeys.size());</span></span><br><span class="line">            iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                selectionKey = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isConnectable()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;client connect&quot;</span>);</span><br><span class="line">                    client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">// 判断此通道上是否正在进行连接操作。</span></span><br><span class="line">                    <span class="comment">// 完成套接字通道的连接过程。</span></span><br><span class="line">                    <span class="keyword">if</span> (client.isConnectionPending()) &#123;</span><br><span class="line">                        client.finishConnect();</span><br><span class="line">                        System.out.println(<span class="string">&quot;完成连接!&quot;</span>);</span><br><span class="line">                        sendbuffer.clear();</span><br><span class="line">                        sendbuffer.put(<span class="string">&quot;Hello,Server&quot;</span>.getBytes());</span><br><span class="line">                        sendbuffer.flip();</span><br><span class="line">                        client.write(sendbuffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                    client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">//将缓冲区清空以备下次读取</span></span><br><span class="line">                    receivebuffer.clear();</span><br><span class="line">                    <span class="comment">//读取服务器发送来的数据到缓冲区中</span></span><br><span class="line">                    count=client.read(receivebuffer);</span><br><span class="line">                    <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        receiveText = <span class="keyword">new</span> String( receivebuffer.array(),<span class="number">0</span>,count);</span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端接受服务器端数据--:&quot;</span>+receiveText);</span><br><span class="line">                        client.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isWritable()) &#123;</span><br><span class="line">                    sendbuffer.clear();</span><br><span class="line">                    client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    sendText = <span class="string">&quot;message from client--&quot;</span> + (flag++);</span><br><span class="line">                    sendbuffer.put(sendText.getBytes());</span><br><span class="line">                    <span class="comment">//将缓冲区各标志复位,因为向里面put了数据标志被改变要想从中读取数据发向服务器,就要复位</span></span><br><span class="line">                    sendbuffer.flip();</span><br><span class="line">                    client.write(sendbuffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端向服务器端发送数据--：&quot;</span>+sendText);</span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            selectionKeys.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="高性能NIO框架——Netty"><a href="#高性能NIO框架——Netty" class="headerlink" title="高性能NIO框架——Netty"></a>高性能NIO框架——Netty</h2><p>Netty是一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持，作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获取IO操作结果</p>
<p>作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛应用，一些业界著名的开源组件也基于Netty的NIO框架构建。</p>
<h2 id="Netty高效的Reactor线程模型"><a href="#Netty高效的Reactor线程模型" class="headerlink" title="Netty高效的Reactor线程模型"></a>Netty高效的Reactor线程模型</h2><p>常用的Reactor线程模型有三种，分别如下：</p>
<ol>
<li>Reactor单线程模型</li>
<li>Reactor多线程模型</li>
<li>主从Reactor多线程模型</li>
</ol>
<p><strong>Reactor单线程模型</strong>，指的是所有的IO操作都在同一个NIO线程上面完成。NIO线程的职责如下：</p>
<ul>
<li>如果是 NIO服务器，接收客户端的TCP连接</li>
<li>如果是NIO客户端，向服务端发起TCP连接</li>
<li>读取通信对端的请求或相应消息</li>
<li>向通信对端发送消息请求或者消息应答</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553415250572.png" alt="1553415250572"></p>
<p>由于Reactor模型使用的是异步非阻塞IO，所有的IO操作都不会导致阻塞，理论上一个线程可以独立处理所有的IO相关的操作。从架构层面看，一个NIO线程确实可以完成其承担的职责。例如，通过Acceptor接受客户端的TCP连接请求消息，链路建立成功后，通过Dispatch将对应的ByteBuffer派发到指定的Handler上进行消息解码。用户Handler可以通过NIO线程将消息发送给客户端。</p>
<p>对于一些小容量应用场景，可以使用单线程模型。但对于高负载、大并发的应用却不适合，主要原因如下：</p>
<ol>
<li>一个NIO线程处理成百上千的链路，性能上无法支撑，即便NIO线程的CPU负载达到100%，也无法满足海量消息的编码、解码、读取和发送</li>
<li>当NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更会加重NIO线程的负担，最终导致大量消息积压和处理超时，NIO线程会成为系统的性能瓶颈</li>
<li>可靠性问题：一旦NIO线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接受和处理外部消息，造成节点故障</li>
</ol>
<p><strong>Reactor多线程模型</strong>和单线程模型最大的区别就是有一组NIO线程处理IO操作</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553416384973.png" alt="1553416384973"></p>
<p>Reactor多线程模型的特点：</p>
<ol>
<li>有专门一个NIO线程（Acceptor线程）用于监听服务端，接受客户端的TCP请求</li>
<li>网络IO操作——读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送</li>
<li>1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止发生并发操作问题</li>
</ol>
<p><strong>主从Reactor多线程模型</strong></p>
<p>在绝大多数场景下，Reactor多线程模型都可以满足性能需求；但是，在极特殊应用场景中，一个NIO线程负责监听和处理所有客户端连接可能会存在性能问题。例如百万客户端并发连接，或者服务端需要对客户端的握手消息进行安全认证，认证本身就是非常损耗性能的。在这类场景下，单独一个Acceptor线程可能会存在性能不足问题，为了解决性能问题，产生了主从Reactor多线程模型</p>
<p>主从Reactor线程模型的特点：</p>
<p>服务端用于接收客户端连接的不再是1个单独的NIO线程，而是一个独立的NIO线程池。Accept接收到客户端TCP连接请求处理完成后（包含接入认证等），将新创建的SocketChannel注册到IO线程池的某个IO线程上，由它负责SocketChannel的读写和编码工作。Acceptor线程池仅仅只用于客户端的登录、握手和安全认证，一旦链路建立成功，就将链路注册到后端subReactor线程池的IO线程上，由IO线程负责后续的IO操作</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553418773318.png" alt="1553418773318"></p>
<h2 id="Netty的无锁化串行设计理念"><a href="#Netty的无锁化串行设计理念" class="headerlink" title="Netty的无锁化串行设计理念"></a>Netty的无锁化串行设计理念</h2><p>在大多数场景下，并行多线程处理可以提升系统并发性能。但是，如果对于共享资源的并发访问处理不当，会带来严重的锁竞争，这最终会导致性能的下降。为了尽可能的避免锁竞争带来的性能损耗。可以通过串行化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁</p>
<p>为了尽可能提升性能，Netty采用了串行无锁化设计。在IO线程内部进行串行操作，避免多线程竞争导致的性能下降。表明上看，串行化设计似乎CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程相比一个队列-多个工作线程性能更优</p>
<p>Netty的串行化设计工作原理图：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553421288581.png" alt="1553421288581"></p>
<p>Netty的NioEventLoop读取到消息之后，直接调用ChannelPipeline的fireChannelRead(Object msg),只要用户不主动切换线程，一直会由NioEventLoop调用到用户的Handler，期间不进行线程切换，这种串行化处理方式避免了多线程操作导致的锁的竞争，从性能角度看是最优的。</p>
<h2 id="使用Netty实现简易版Tomcat"><a href="#使用Netty实现简易版Tomcat" class="headerlink" title="使用Netty实现简易版Tomcat"></a>使用Netty实现简易版Tomcat</h2><h3 id="1-引入Netty的依赖"><a href="#1-引入Netty的依赖" class="headerlink" title="1.引入Netty的依赖"></a>1.引入Netty的依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;4.1.6.Final&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-编写web-properties属性文件"><a href="#2-编写web-properties属性文件" class="headerlink" title="2.编写web.properties属性文件"></a>2.编写web.properties属性文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">servlet.first=firstServlet</span><br><span class="line">servlet.first.className=com.gerry.tomcat.servlets.FirstServlet</span><br><span class="line">servlet.first.urlPattern=/first/query*</span><br><span class="line"></span><br><span class="line">servlet.second=secondServlet</span><br><span class="line">servlet.second.className=com.gerry.tomcat.servlets.SecondServlet</span><br><span class="line">servlet.second.urlPattern=/second/query*</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-定义所有servlet的抽象父类"><a href="#3-定义所有servlet的抽象父类" class="headerlink" title="3.定义所有servlet的抽象父类"></a>3.定义所有servlet的抽象父类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GServlet</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GRequest request, GResponse response)</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GRequest request, GResponse response)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-定义servlet实体"><a href="#4-定义servlet实体" class="headerlink" title="4.定义servlet实体"></a>4.定义servlet实体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">GServlet</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GRequest request, GResponse response)</span> </span>&#123;</span><br><span class="line">		doPost(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GRequest request, GResponse response)</span> </span>&#123;</span><br><span class="line">		String param = <span class="string">&quot;name&quot;</span>;  </span><br><span class="line">	    String str = request.getParameter(param);  </span><br><span class="line">	    response.write(param + <span class="string">&quot;:&quot;</span> + str,<span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondServlet</span> <span class="keyword">extends</span> <span class="title">GServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(GRequest request, GResponse response)</span> </span>&#123;</span><br><span class="line">		doPost(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(GRequest request, GResponse response)</span> </span>&#123;</span><br><span class="line">	    String str = JSON.toJSONString(request.getParameters(),<span class="keyword">true</span>);  </span><br><span class="line">	    response.write(str,<span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-自定义请求类和响应类"><a href="#5-自定义请求类和响应类" class="headerlink" title="5.自定义请求类和响应类"></a>5.自定义请求类和响应类</h3><p>请求类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GRequest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> ChannelHandlerContext ctx;</span><br><span class="line">	<span class="keyword">private</span> HttpRequest request;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GRequest</span><span class="params">(ChannelHandlerContext ctx, HttpRequest request)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">		<span class="keyword">this</span>.request = request;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getUri</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> request.getUri();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> request.getMethod().name();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> Map&lt;String,List&lt;String&gt;&gt; getParameters()&#123;</span><br><span class="line">		QueryStringDecoder decoderQuery = <span class="keyword">new</span> QueryStringDecoder(request.getUri());</span><br><span class="line">		<span class="keyword">return</span> decoderQuery.parameters();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; params = getParameters();  </span><br><span class="line">        List&lt;String&gt; param = params.get(name);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != param)&#123;</span><br><span class="line">        		<span class="keyword">return</span> param.get(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>响应类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ChannelHandlerContext ctx;</span><br><span class="line">	<span class="keyword">private</span> HttpRequest request;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,HttpResponseStatus&gt; statusMapping = <span class="keyword">new</span> HashMap&lt;Integer,HttpResponseStatus&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		statusMapping.put(<span class="number">200</span>, HttpResponseStatus.OK);</span><br><span class="line">		statusMapping.put(<span class="number">404</span>, HttpResponseStatus.NOT_FOUND);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GResponse</span><span class="params">(ChannelHandlerContext ctx, HttpRequest request)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">		<span class="keyword">this</span>.request = request;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String outString,Integer status)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(</span><br><span class="line">				HTTP_1_1,</span><br><span class="line">				statusMapping.get(status),</span><br><span class="line">				Unpooled.wrappedBuffer(outString.getBytes(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">			response.headers().set(CONTENT_TYPE, <span class="string">&quot;text/json&quot;</span>);</span><br><span class="line">			response.headers().set(CONTENT_LENGTH,response.content().readableBytes());</span><br><span class="line">			response.headers().set(EXPIRES, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (HttpHeaders.isKeepAlive(request)) &#123;</span><br><span class="line">				response.headers().set(CONNECTION, Values.KEEP_ALIVE);</span><br><span class="line">			&#125;</span><br><span class="line">			ctx.write(response);  </span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			ctx.flush(); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-启动类"><a href="#6-启动类" class="headerlink" title="6.启动类"></a>6.启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GTomcat</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Logger LOG = Logger.getLogger(GTomcat.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">// 主线程池</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();  <span class="comment">// 从线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap(); <span class="comment">// 管理主和从线程池的根类</span></span><br><span class="line">            b.group(bossGroup, workerGroup)             <span class="comment">//使用主从线程模型</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">                            <span class="comment">//服务端发送的是httpResponse，所以要使用HttpResponseEncoder进行编码</span></span><br><span class="line">                            <span class="comment">//也可以使用ProtobufDecoder</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> HttpResponseEncoder());  </span><br><span class="line">                            <span class="comment">//服务端接收到的是httpRequest，所以要使用HttpRequestDecoder进行解码  </span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> HttpRequestDecoder()); </span><br><span class="line">                            <span class="comment">//最后处理自己的逻辑</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> GTomcatHandler());</span><br><span class="line">                        &#125;  </span><br><span class="line">                     &#125;).option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)<span class="comment">//支持的最多连接数,windows默认为200</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">//保持子线程不死</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//绑定服务端口</span></span><br><span class="line">            ChannelFuture f = b.bind(port).sync();</span><br><span class="line">            </span><br><span class="line">            LOG.info(<span class="string">&quot;HTTP服务已启动，监听端口:&quot;</span> + port);</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//开始接收客户</span></span><br><span class="line">            f.channel().closeFuture().sync();  </span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 优雅的方式关闭线程池</span></span><br><span class="line">            workerGroup.shutdownGracefully();  </span><br><span class="line">            bossGroup.shutdownGracefully();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">new</span> GTomcat().start(<span class="number">8080</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="7-定义自己的处理逻辑"><a href="#7-定义自己的处理逻辑" class="headerlink" title="7.定义自己的处理逻辑"></a>7.定义自己的处理逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GTomcatHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Logger LOG = Logger.getLogger(GTomcatHandler.class);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Pattern,Class&lt;?&gt;&gt; servletMapping = <span class="keyword">new</span> HashMap&lt;Pattern,Class&lt;?&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">    		CustomConfig.load(<span class="string">&quot;web.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">    		<span class="keyword">for</span> (String key : CustomConfig.getKeys()) &#123;</span><br><span class="line">			<span class="keyword">if</span>(key.startsWith(<span class="string">&quot;servlet&quot;</span>))&#123;</span><br><span class="line">				String name = key.replaceFirst(<span class="string">&quot;servlet.&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span>(name.indexOf(<span class="string">&quot;.&quot;</span>) != -<span class="number">1</span>)&#123;</span><br><span class="line">					name = name.substring(<span class="number">0</span>,name.indexOf(<span class="string">&quot;.&quot;</span>));<span class="comment">//截取fist或second</span></span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				String pattern = CustomConfig.getString(<span class="string">&quot;servlet.&quot;</span> + name + <span class="string">&quot;.urlPattern&quot;</span>);</span><br><span class="line">				pattern = pattern.replaceAll(<span class="string">&quot;\\*&quot;</span>, <span class="string">&quot;.*&quot;</span>);</span><br><span class="line">				String className = CustomConfig.getString(<span class="string">&quot;servlet.&quot;</span> + name + <span class="string">&quot;.className&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span>(!servletMapping.containsKey(pattern))&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						servletMapping.put(Pattern.compile(pattern), Class.forName(className));<span class="comment">//进行请求的url和servlet类的映射</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">&quot;ServletMapping:&quot;</span>+servletMapping);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;  </span><br><span class="line">        		HttpRequest r = (HttpRequest) msg;</span><br><span class="line">        		GRequest request = <span class="keyword">new</span> GRequest(ctx,r);</span><br><span class="line">        		GResponse response = <span class="keyword">new</span> GResponse(ctx,r);</span><br><span class="line">            String uri = request.getUri();</span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">  </span><br><span class="line">            LOG.info(String.format(<span class="string">&quot;Uri:%s method %s&quot;</span>, uri, method));  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">boolean</span> hasPattern = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;Pattern, Class&lt;?&gt;&gt; entry : servletMapping.entrySet()) &#123;</span><br><span class="line">            		<span class="keyword">if</span> (entry.getKey().matcher(uri).matches()) &#123;  </span><br><span class="line">	            		GServlet servlet = (GServlet)entry.getValue().newInstance();</span><br><span class="line">	            		<span class="keyword">if</span>(<span class="string">&quot;get&quot;</span>.equalsIgnoreCase(method))&#123;</span><br><span class="line">	            			servlet.doGet(request, response);</span><br><span class="line">	            		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	            			servlet.doPost(request, response);</span><br><span class="line">	            		&#125;</span><br><span class="line">	            		hasPattern = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!hasPattern)&#123;  </span><br><span class="line">                String out = String.format(<span class="string">&quot;404 NotFound URL%s for method %s&quot;</span>, uri,method);  </span><br><span class="line">                response.write(out,<span class="number">404</span>);  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        ctx.flush();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;  </span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-定义配置文件工具类"><a href="#8-定义配置文件工具类" class="headerlink" title="8.定义配置文件工具类"></a>8.定义配置文件工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConfig</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PLACEHOLDER_START = <span class="string">&quot;$&#123;&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; ctx; </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(String... props)</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> CustomConfig(props);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">CustomConfig</span><span class="params">(String... props)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (String path : props) &#123;</span><br><span class="line">			Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				p.load(CustomConfig.class.getClassLoader().getResourceAsStream(path));</span><br><span class="line">				</span><br><span class="line">				resolvePlaceHolders(p);</span><br><span class="line">				ctx = <span class="keyword">new</span> HashMap&lt;String, String&gt;();  </span><br><span class="line">		        <span class="keyword">for</span> (Object key : p.keySet()) &#123;  </span><br><span class="line">		            String keyStr = key.toString();  </span><br><span class="line">		            String value = p.getProperty(keyStr);</span><br><span class="line">                    System.out.println(<span class="string">&quot;key:&quot;</span>+keyStr+<span class="string">&quot;value:&quot;</span>+value);</span><br><span class="line">		            ctx.put(keyStr, value);  </span><br><span class="line">		        &#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取已加载的配置信息</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getValue</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> ctx.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取已加载的配置信息</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> ctx.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取已加载的配置信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(ctx.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取已加载的配置信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Boolean.valueOf(ctx.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取已加载的配置信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Long.valueOf(ctx.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取已加载的配置信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">short</span> <span class="title">getShort</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Short.valueOf(ctx.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取已加载的配置信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Float.valueOf(ctx.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取已加载的配置信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(String key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Double.valueOf(ctx.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有的key值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">getKeys</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> ctx.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 解析占位符 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> properties </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resolvePlaceHolders</span><span class="params">(Properties properties)</span> </span>&#123;  </span><br><span class="line">        Iterator&lt;?&gt; itr = properties.entrySet().iterator();  </span><br><span class="line">        <span class="keyword">while</span> ( itr.hasNext() ) &#123;  </span><br><span class="line">            <span class="keyword">final</span> Map.Entry entry = ( Map.Entry ) itr.next();  </span><br><span class="line">            <span class="keyword">final</span> Object value = entry.getValue();  </span><br><span class="line">            <span class="keyword">if</span> ( value != <span class="keyword">null</span> &amp;&amp; String.class.isInstance( value ) ) &#123;  </span><br><span class="line">                <span class="keyword">final</span> String resolved = resolvePlaceHolder(properties, (String)value );  </span><br><span class="line">                <span class="keyword">if</span> ( !value.equals( resolved ) ) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> ( resolved == <span class="keyword">null</span> ) &#123;  </span><br><span class="line">                        itr.remove();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">else</span> &#123;  </span><br><span class="line">                        entry.setValue( resolved );  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 解析占位符具体操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">resolvePlaceHolder</span><span class="params">(Properties prots,String value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> ( value.indexOf( PLACEHOLDER_START ) &lt; <span class="number">0</span> ) &#123;  </span><br><span class="line">            <span class="keyword">return</span> value;  </span><br><span class="line">        &#125;  </span><br><span class="line">        StringBuffer buff = <span class="keyword">new</span> StringBuffer();  </span><br><span class="line">        <span class="keyword">char</span>[] chars = value.toCharArray();  </span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> pos = <span class="number">0</span>; pos &lt; chars.length; pos++ ) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ( chars[pos] == <span class="string">&#x27;$&#x27;</span> ) &#123;  </span><br><span class="line">                <span class="keyword">if</span> ( chars[pos+<span class="number">1</span>] == <span class="string">&#x27;&#123;&#x27;</span> ) &#123;  </span><br><span class="line">                    String key = <span class="string">&quot;&quot;</span>;  </span><br><span class="line">                    <span class="keyword">int</span> x = pos + <span class="number">2</span>;  </span><br><span class="line">                    <span class="keyword">for</span> (  ; x &lt; chars.length &amp;&amp; chars[x] != <span class="string">&#x27;&#125;&#x27;</span>; x++ ) &#123;  </span><br><span class="line">                    	key += chars[x];  </span><br><span class="line">                        <span class="keyword">if</span> ( x == chars.length - <span class="number">1</span> ) &#123;  </span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException( <span class="string">&quot;unmatched placeholder start [&quot;</span> + value + <span class="string">&quot;]&quot;</span> );  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    String val = extractFromSystem(prots, key);  </span><br><span class="line">                    buff.append( val == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : val );  </span><br><span class="line">                    pos = x + <span class="number">1</span>;  </span><br><span class="line">                    <span class="keyword">if</span> ( pos &gt;= chars.length ) &#123;  </span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            buff.append( chars[pos] );  </span><br><span class="line">        &#125;  </span><br><span class="line">        String rtn = buff.toString();  </span><br><span class="line">        <span class="keyword">return</span> isEmpty( rtn ) ? <span class="keyword">null</span> : rtn;  </span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 获得系统属性 当然 你可以选择从别的地方获取值 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">extractFromSystem</span><span class="params">(Properties prots,String key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> prots.getProperty(key);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">catch</span>( Throwable t ) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 判断字符串的空(null或者.length=0) </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(String string)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> string == <span class="keyword">null</span> || string.length() == <span class="number">0</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="TCP的粘包、拆包问题"><a href="#TCP的粘包、拆包问题" class="headerlink" title="TCP的粘包、拆包问题"></a>TCP的粘包、拆包问题</h2><p>​        在基于流的传输里比如TCP/IP，接收到的数据会先被存储到一个socket接收缓冲里。不幸的是，基于流的传输并不是一个数据包队列，而是一个字节队列。即使你发送了2个独立的数据包，操作系统也不会作为2个消息处理而仅仅是作为一连串的字节而言。因此这是不能保证你远程写入的数据就会准确地读取</p>
<ul>
<li>粘包：当你把A、B两个数据从甲发送到乙，本想A与B单独发送，但是你却把AB一起发送了，此时AB粘在一起，就是粘包了</li>
<li>拆包：如果发送数据的时候，你把A、B拆成了几份发，就是拆包了。当然数据不是主动拆的，是TCP流自动拆的</li>
</ul>
<h2 id="TCP粘包、拆包产生的原因及解决方案"><a href="#TCP粘包、拆包产生的原因及解决方案" class="headerlink" title="TCP粘包、拆包产生的原因及解决方案"></a>TCP粘包、拆包产生的原因及解决方案</h2><ol>
<li>TCP是基于字节流的，没有边界</li>
<li>要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包 </li>
<li>待发送数据大于MSS(最大报文长度)，TCP在传输前将进行拆包</li>
<li>以太网帧的plyload(数据部分)大于MTU(帧的负载)进行了IP分片</li>
<li>应用程序write写入的字节大小大于套接口发送的缓冲区的大小</li>
</ol>
<p><strong>解决方案</strong></p>
<ol>
<li>消息定长，比如把报文消息固定为500字节，不够用空格补位</li>
<li>在包尾增加回车换行符或特殊符号进行分割，例如FTP协议</li>
<li>将消息分为消息头、消息体，消息头中包含表示总长度的字段</li>
<li>更复杂的应用层协议</li>
</ol>
<h2 id="Netty实现数据通信"><a href="#Netty实现数据通信" class="headerlink" title="Netty实现数据通信"></a>Netty实现数据通信</h2><p>使用特殊字符作为终结符解决粘包、拆包问题</p>
<p><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup acceptorGroup = <span class="keyword">new</span> NioEventLoopGroup();<span class="comment">//创建主线程池</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();<span class="comment">//创建从线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建辅助类</span></span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(acceptorGroup, workerGroup);</span><br><span class="line">            <span class="comment">// 设置选项参数</span></span><br><span class="line">            b.option(ChannelOption.SO_BACKLOG, <span class="number">128</span>);</span><br><span class="line">            b.childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 设置channel的类型</span></span><br><span class="line">            b.channel(NioServerSocketChannel.class);</span><br><span class="line">            <span class="comment">// 装配流水线</span></span><br><span class="line">            b.childHandler(<span class="keyword">new</span> ServerHandlerInitializer());</span><br><span class="line">            <span class="comment">// 绑定端口等待客户连接</span></span><br><span class="line">            Channel channel = b.bind(<span class="number">8888</span>).sync().channel();</span><br><span class="line">            System.out.println(<span class="string">&quot;server start is running......&quot;</span>);</span><br><span class="line">            <span class="comment">// 优雅的关闭</span></span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程组</span></span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            acceptorGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandlerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 增加分割符处理器</span></span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;$&quot;</span>.getBytes());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">1024</span>, byteBuf));</span><br><span class="line">        <span class="comment">// 装配处理器</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;<span class="comment">//读请求处理</span></span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(byteBuf.toString(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));<span class="comment">//展示读取数据</span></span><br><span class="line">        ctx.writeAndFlush(</span><br><span class="line">            Unpooled.copiedBuffer(<span class="keyword">new</span> String(<span class="string">&quot;Hello Client$&quot;</span>).getBytes()));<span class="comment">//发送响应消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(workerGroup);</span><br><span class="line">            b.channel(NioSocketChannel.class);</span><br><span class="line">            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">            b.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">// 增加分割符处理器</span></span><br><span class="line">                    ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;$&quot;</span>.getBytes());</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">1024</span>, byteBuf));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 连接服务端</span></span><br><span class="line">            ChannelFuture f = b.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>).sync();</span><br><span class="line">            f.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="keyword">new</span> String(<span class="string">&quot;Hello Server$&quot;</span>).getBytes()));</span><br><span class="line">            f.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="keyword">new</span> String(<span class="string">&quot;Hello Server$&quot;</span>).getBytes()));</span><br><span class="line">            f.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="keyword">new</span> String(<span class="string">&quot;Hello Server$&quot;</span>).getBytes()));</span><br><span class="line"></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = (ByteBuf)msg;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(byteBuf.toString(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            byteBuf.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="JMS（JAVA-Message-Service）"><a href="#JMS（JAVA-Message-Service）" class="headerlink" title="JMS（JAVA Message Service）"></a>JMS（JAVA Message Service）</h2><h3 id="JMS基本概念"><a href="#JMS基本概念" class="headerlink" title="JMS基本概念"></a>JMS基本概念</h3><p>JMS（java消息服务）的客户端之间可以通过JMS服务进行异步的消息传输。JMS API是一个消息服务的标准或者说规范，允许应用程序组件基于JAVAEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>
<h3 id="JMS五种不同的消息正文格式"><a href="#JMS五种不同的消息正文格式" class="headerlink" title="JMS五种不同的消息正文格式"></a>JMS五种不同的消息正文格式</h3><p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接受以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p>
<ul>
<li>StreamMessage——Java原始值的数据流</li>
<li>MapMessage——一套名称-值对</li>
<li>TextMessage——一个字符串对象</li>
<li>ObjectMessage——一个序列化的JAVA对象</li>
<li>BytesMessage——一个字节的数据流</li>
</ul>
<h3 id="JMS的两种消息模型"><a href="#JMS的两种消息模型" class="headerlink" title="JMS的两种消息模型"></a>JMS的两种消息模型</h3><ol>
<li><p>点对点(P2P)模型</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553603924034.png" alt="1553603924034"></p>
<p>使用<strong>队列</strong>(Queue)作为消息通信载体；满足<strong>生产者与消费者模式</strong>，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：生产者发送100条消息的话，两个消费者来消费一般情况下两个消费者都按照消息发送的顺序各自消费一半（也就是你一个我一个的消费）</p>
</li>
<li><p>发布/订阅(Pub/Sub)模型</p>
</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553603947340.png" alt="1553603947340"></p>
<h3 id="JMS编码接口之间的关系"><a href="#JMS编码接口之间的关系" class="headerlink" title="JMS编码接口之间的关系"></a>JMS编码接口之间的关系</h3><p><img src="C:\Users\Administrator\AppData\Local\Temp\1553604903198.png" alt="1553604903198"></p>
<ul>
<li><strong>ConnectionFactory</strong>：创建Connection对象的工厂，针对两种不同的jms消息模型，分别有QueueConnectionFactory(队列连接工厂)和TopicConnectionFactory(主题连接工厂)两种。可以通过JNDI来查找ConnectionFactory对象。</li>
<li><strong>Connection</strong>：Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。</li>
<li><strong>Session</strong>：Session是操作消息的接口。可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分QueueSession和TopicSession。</li>
<li><strong>MessageProducer</strong>：消息生产者由Session创建，并用于将消息发送到Destination。同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。</li>
<li><strong>MessageConsumer</strong> ：消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。</li>
<li><strong>Destination</strong>：Destination的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。</li>
<li><strong>MessageListener</strong>： 消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。</li>
</ul>
<h3 id="消息队列的使用场景"><a href="#消息队列的使用场景" class="headerlink" title="消息队列的使用场景"></a>消息队列的使用场景</h3><ol>
<li>异步通信 不需要即时处理的业务，将其放去消息队列中，在需要处理的时候直接去队列中取出来，达到了生产者和消费者不用互相了解对方，生产者只需要专注于生产，消费者专注于消费。</li>
<li>解耦 降低工程之间的耦合程度，从设计角度来讲，达到低耦合高内聚的目的。当应用需要维护的时候，不同应用可以独立的扩展或修改，只需要遵循同样的接口约束即可。</li>
<li>冗余 消息队列可以对队列中的消息进行持久化处理，防止数据丢失。很多消息队列都采用“插入-获取-删除”的模式，只有当处理数据的过程成功并且返回提示，才会进行消息的删除，否则消息将一直保存在队列之中。</li>
<li>过载保护 在请求量突发的高峰期间，为了让系统保持正常工作，又不想每时每刻都按最大峰值投入资源。使用消息队列就可以让关键组件顶住突发压力，不至于让整个系统崩溃。</li>
<li>保证有序 消息队列可以对消息进行优先级设定，然后根据优先级来对消息进行排序，达到重要数据优先处理。</li>
<li><strong>缓冲</strong> 消息队列有助于控制和优化数据流经过系统的速度。以调节系统响应时间。</li>
<li><strong>数据流处理</strong> 大数据业务需要对数据流进行分析，在消息队列中进行处理是最好不过的。</li>
</ol>
<h2 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h2><h3 id="什么是ActiveMQ"><a href="#什么是ActiveMQ" class="headerlink" title="什么是ActiveMQ"></a>什么是ActiveMQ</h3><ol>
<li>首先你得了解什么是MOM：MOM(Message Oriented Middleware)，分布式系统的集成，指的是利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成</li>
<li>然后你得知道什么是JMS：JMS(Java Message Service)Java消息服务，应用程序接口，是一个Java平台中关于面向消息中间件(MOM)的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信</li>
<li>ActiveMQ：Apache下的一个非常流行的消息中间件，使用JAVA支持的JMS Provider实现，所以和Python、PHP、Ruby、Websocket等多种客户端都可以提供良好的服务</li>
</ol>
<h3 id="ActiveMQ的组成模块"><a href="#ActiveMQ的组成模块" class="headerlink" title="ActiveMQ的组成模块"></a>ActiveMQ的组成模块</h3><ul>
<li>Broker:消息服务器，作为server提供消息核心服务</li>
<li>Producer:消息生产者，业务的发起方，负责生产消息传输给broker</li>
<li>Consumer:消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理</li>
<li>Topic:主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播</li>
<li>Queue:队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收</li>
<li>Message:消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输</li>
</ul>
<h3 id="ActiveMQ的安装"><a href="#ActiveMQ的安装" class="headerlink" title="ActiveMQ的安装"></a>ActiveMQ的安装</h3><p>a、到这个ActiveMQ官网下<a target="_blank" rel="noopener" href="http://activemq.apache.org/activemq-5158-release.html%E4%B8%8B%E8%BD%BDActiveMQ">http://activemq.apache.org/activemq-5158-release.html下载ActiveMQ</a></p>
<p>b、解压直接执行bin下面win64的activemq.bat文件</p>
<p>c、输入localhost:8161 检查是否正常打开</p>
<h3 id="ActiveMQ的简单使用"><a href="#ActiveMQ的简单使用" class="headerlink" title="ActiveMQ的简单使用"></a>ActiveMQ的简单使用</h3><p>添加maven依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.15.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>点对点模拟通信</strong></p>
<p>生产者发送消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueueProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、创建一个连接工厂对象，需要指定服务的ip及端口。</span></span><br><span class="line">    ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">&quot;tcp://10.29.33.195:61616&quot;</span>);</span><br><span class="line">    <span class="comment">// 2、使用工厂对象创建一个Connection对象。</span></span><br><span class="line">    Connection connection = connectionFactory.createConnection();</span><br><span class="line">    <span class="comment">// 3、开启连接，调用Connection对象的start方法。</span></span><br><span class="line">    connection.start();</span><br><span class="line">    <span class="comment">// 4、创建一个Session对象。</span></span><br><span class="line">    <span class="comment">// 第一个参数：是否开启事务。如果true开启事务，需要手动提交消息，多条消息要么全部提交成功要么全部回滚，第二个参数无意义。一般不开启事务false。</span></span><br><span class="line">    <span class="comment">// 第二个参数：应答模式。自动应答或者手动应答。一般自动应答。</span></span><br><span class="line">    Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">    <span class="comment">// 5、使用Session对象创建一个Destination对象。两种形式queue、topic，现在应该使用queue</span></span><br><span class="line">    Queue queue = session.createQueue(<span class="string">&quot;test-queue&quot;</span>);</span><br><span class="line">    <span class="comment">// 6、使用Session对象创建一个Producer对象。</span></span><br><span class="line">    MessageProducer producer = session.createProducer(queue);</span><br><span class="line">    <span class="comment">// 7、创建一个Message对象，可以使用TextMessage。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        TextMessage textMessage = session.createTextMessage(<span class="string">&quot;第 &quot;</span>+i+ <span class="string">&quot;一个ActiveMQ队列目的地的消息 &quot;</span>);</span><br><span class="line">        <span class="comment">// 8、发送消息</span></span><br><span class="line">        producer.send(textMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是事务性会话，我们都需要手动来commit提交发送消息</span></span><br><span class="line">	session.commit();</span><br><span class="line">    <span class="comment">// 9、关闭资源</span></span><br><span class="line">    producer.close();</span><br><span class="line">    session.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>消费者消费消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueueConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 创建一个ConnectionFactory对象连接MQ服务器</span></span><br><span class="line">       ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">&quot;tcp://10.29.33.195:61616&quot;</span>);</span><br><span class="line">       <span class="comment">// 创建一个连接对象</span></span><br><span class="line">       Connection connection = connectionFactory.createConnection();</span><br><span class="line">       <span class="comment">// 开启连接</span></span><br><span class="line">       connection.start();</span><br><span class="line">       <span class="comment">// 使用Connection对象创建一个Session对象</span></span><br><span class="line">       Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">       <span class="comment">// 创建一个Destination对象。queue对象</span></span><br><span class="line">       Queue queue = session.createQueue(<span class="string">&quot;test-queue&quot;</span>);</span><br><span class="line">       <span class="comment">// 使用Session对象创建一个消费者对象。</span></span><br><span class="line">       MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line">       <span class="comment">// 接收消息</span></span><br><span class="line">       consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">               <span class="comment">// 打印结果</span></span><br><span class="line">               TextMessage textMessage = (TextMessage) message;</span><br><span class="line">               String text;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   text = textMessage.getText();</span><br><span class="line">                   System.out.println(<span class="string">&quot;这是接收到的消息： &quot;</span> + text);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">// 等待接收消息</span></span><br><span class="line">       System.in.read();</span><br><span class="line">       <span class="comment">//如果是事务性会话，我们都需要手动来commit来表示接受消息成功</span></span><br><span class="line">    session.commit();</span><br><span class="line">       <span class="comment">// 关闭资源</span></span><br><span class="line">       consumer.close();</span><br><span class="line">       session.close();</span><br><span class="line">       connection.close();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>发布/订阅模拟通信</strong></p>
<p>生产者发布消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopicProducer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 1、创建一个连接工厂对象，需要指定服务的ip及端口。</span></span><br><span class="line">       ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">&quot;tcp://10.29.33.195:61616 &quot;</span>);</span><br><span class="line">       <span class="comment">// 2、使用工厂对象创建一个Connection对象。</span></span><br><span class="line">       Connection connection = connectionFactory.createConnection();</span><br><span class="line">       <span class="comment">// 3、开启连接，调用Connection对象的start方法。</span></span><br><span class="line">       connection.start();</span><br><span class="line">       <span class="comment">// 4、创建一个Session对象。</span></span><br><span class="line">       <span class="comment">// 第一个参数：是否开启事务。如果true开启事务，第二个参数无意义。一般不开启事务false。</span></span><br><span class="line">       <span class="comment">// 第二个参数：应答模式。自动应答或者手动应答。一般自动应答。</span></span><br><span class="line">       Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">       <span class="comment">// 5、使用Session对象创建一个Destination对象。两种形式queue、topic，现在应该使用topic</span></span><br><span class="line">       Topic topic = session.createTopic(<span class="string">&quot;test-topic&quot;</span>);</span><br><span class="line">       <span class="comment">// 6、使用Session对象创建一个Producer对象。</span></span><br><span class="line">       MessageProducer producer = session.createProducer(topic);</span><br><span class="line">       <span class="comment">// 生产者发送的消息默认就是持久的，可以设置为非持久的，但持久订阅方式要求必须设置为持久</span></span><br><span class="line">       <span class="comment">// producer.setDeliveryMode(DeliveryMode.PERSISTENT);</span></span><br><span class="line">       <span class="comment">// 7、创建一个Message对象，可以使用TextMessage。</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">           TextMessage textMessage = session.createTextMessage(<span class="string">&quot;第 &quot;</span>+i+ <span class="string">&quot;一个ActiveMQ队列目的地的消息 &quot;</span>);</span><br><span class="line">           <span class="comment">// 8、发送消息</span></span><br><span class="line">           producer.send(textMessage);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 9、关闭资源</span></span><br><span class="line">       producer.close();</span><br><span class="line">       session.close();</span><br><span class="line">       connection.close();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>消费者订阅消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopicConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个ConnectionFactory对象连接MQ服务器</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">&quot;tcp://10.29.33.195:61616 &quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个连接对象</span></span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        <span class="comment">// 开启连接</span></span><br><span class="line">        connection.start();</span><br><span class="line">        <span class="comment">// 使用Connection对象创建一个Session对象</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">// 创建一个Destination对象。topic对象</span></span><br><span class="line">        Topic topic = session.createTopic(<span class="string">&quot;test-topic&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用Session对象创建一个消费者对象。</span></span><br><span class="line">        MessageConsumer consumer = session.createConsumer(topic);</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 打印结果</span></span><br><span class="line">                TextMessage textMessage = (TextMessage) message;</span><br><span class="line">                String text;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    text = textMessage.getText();</span><br><span class="line">                    System.out.println(<span class="string">&quot;这是接收到的消息： &quot;</span> + text);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;topic消费者启动。。。。 &quot;</span>);</span><br><span class="line">        <span class="comment">// 等待接收消息</span></span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        consumer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ps:这里需要先运行消费者进程（提前订阅，否则收不到发送的消息）</p>
<p>持久订阅方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopicPersistenceConsumer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个ConnectionFactory对象连接MQ服务器</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">&quot;tcp://10.29.33.195:61616 &quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个连接对象</span></span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line">        <span class="comment">// 设置ClientID===</span></span><br><span class="line">        connection.setClientID(<span class="string">&quot;client01&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启连接</span></span><br><span class="line">        connection.start();</span><br><span class="line">        <span class="comment">// 使用Connection对象创建一个Session对象</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">// 创建一个Destination对象。topic对象</span></span><br><span class="line">        Topic topic = session.createTopic(<span class="string">&quot;test-topic&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用Session对象创建一个持久订阅消费者对象===</span></span><br><span class="line">        MessageConsumer consumer = session.createDurableSubscriber(topic,<span class="string">&quot;client01&quot;</span>);</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 打印结果</span></span><br><span class="line">                TextMessage textMessage = (TextMessage) message;</span><br><span class="line">                String text;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    text = textMessage.getText();</span><br><span class="line">                    System.out.println(<span class="string">&quot;这是接收到的消息： &quot;</span> + text);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;topic消费者启动。。。。 &quot;</span>);</span><br><span class="line">        <span class="comment">// 等待接收消息</span></span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        consumer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>持久订阅方式客户端启动订阅后，即使客户端关闭，仍然可以在客户端重新上线后接收到(即可以接收离线消息)，因为消息会持久化到磁盘上(apache-activemq/data/kahadb/db.data)，接收过消息后下次再启动客户端将不再接收消费过的消息</p>
<h3 id="ActiveMQ整合SpringBoot"><a href="#ActiveMQ整合SpringBoot" class="headerlink" title="ActiveMQ整合SpringBoot"></a>ActiveMQ整合SpringBoot</h3><ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在application.yml中添加配置</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  activemq:</span><br><span class="line">    broker-url: tcp:<span class="comment">//localhost:61616</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>在配置类中装配AvtiveMQ队列或主题Bean</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">// 创建一个mq的队列对象交给spring管理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActiveMQQueue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQQueue(<span class="string">&quot;boot-queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>定义发送类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqSender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Queue queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        jmsMessagingTemplate.convertAndSend(<span class="keyword">this</span>.queue, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>定义监听事件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMqReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;boot-queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveQueue</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message+<span class="string">&quot;已经被消费了&quot;</span>); <span class="comment">//写处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>消息的发送</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private ActiveMqSender sender;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testSendMessage() throws Exception &#123;</span><br><span class="line">    sender.send(&quot;创建一个订单信息&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ActiveMQ的消息可靠传输"><a href="#ActiveMQ的消息可靠传输" class="headerlink" title="ActiveMQ的消息可靠传输"></a>ActiveMQ的消息可靠传输</h3><h4 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h4><p>消息的成功消费一般包含三个阶段：客户端接收消息、客户处理消息和消息被确认。在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式。该参数有以下三个可选值：</p>
<ul>
<li>Session.AUTO_ACKNOWLEDGE.当客户端成功从receive方法或onMessage方法返回的时候，会话自动确认客户收到的消息</li>
<li>Session.CLIENT_ACKNOWLEDGE.客户通过acknowledge()方法确认消息。需要注意的是，这种方式的确认是在会话层上进行：确认一个被消费的消息将自动确认<strong>之前</strong>所有已被会话消费的消息，即只签收第三条消息将签收前3条消息</li>
<li>Session.UDPS_ACKNOWLEDGE.该模式会使会话延迟确认消息的提交。如果JMS provide失败，那么可能会导致一些重复的消息</li>
</ul>
<ol>
<li>取消客户端的自动签收，改为客户端手动确认</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.CLIENT_ACKNOWLEDGE);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>消费后手动确认签收</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">textMessage.acknowledge();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="消息持久化机制"><a href="#消息持久化机制" class="headerlink" title="消息持久化机制"></a>消息持久化机制</h4><p>默认即为<strong>开启</strong>，把服务端发送的消息持久化到kahaDB，即使activeMQ服务器宕机重启后消息仍然存在</p>
<p>也可以使用其他的持久化方式，比如jdbc，优点是消息可视化、高可靠：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="消息重发机制"><a href="#消息重发机制" class="headerlink" title="消息重发机制"></a>消息重发机制</h4><p>触发条件：</p>
<ul>
<li>Client用了transactions(事务)，且在session中调用了rollback()</li>
<li>Client用了transactions，且在调用session.commit()之前关闭</li>
<li>Client在CLIENT_ACKNOWLEDGE的传递模式下，在session中调用了recover()</li>
</ul>
<p>创建定时任务扫描消息表，超时消息采取重新发送，重发超过一定次数后定义为发送失败。</p>
<h3 id="ActiveMQ集群搭建以及HA"><a href="#ActiveMQ集群搭建以及HA" class="headerlink" title="ActiveMQ集群搭建以及HA"></a>ActiveMQ集群搭建以及HA</h3><p>集群是<strong>单通道</strong>的，A broker生成的数据在B broker消费，如果消费到了A中生成的数据，这个时候再在A服务器上面消费是消费不到的。【5.5版本后可以配置回流策略解决】</p>
<p>ActiveMQ的集群需要结合zookeeper协作完成主从，挂掉的master会把消息同步到新的master上。</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553783881131.png" alt="1553783881131"></p>
<h4 id="高可用方案——主从"><a href="#高可用方案——主从" class="headerlink" title="高可用方案——主从"></a>高可用方案——主从</h4><ol>
<li><p>先修改activeMQ.xml节点名称(brokerName)，这里三台机器必须一致</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">broker</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://activemq.apache.org/schema/core&quot;</span> <span class="attr">brokerName</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">dataDirectory</span>=<span class="string">&quot;$&#123;activemq.data&#125;&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>三台机器的activeMQ.xml文件的持久配置如下：</p>
</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553785003285.png" alt="1553784198286"></p>
<ol start="3">
<li><p>修改三台机器activemq文件下的jetty.xml端口分别为8161,8162,8163</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553785364607.png" alt="1553785364607"></p>
</li>
<li><p>修改activeMQ.xml的连接器，三个修改为61616,61617,61618</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553785247263.png" alt="1553785247263"></p>
</li>
<li><p>启动zookeeper服务器</p>
</li>
<li><p>启动ActiveMQ</p>
</li>
</ol>
<p><strong>使用</strong></p>
<p>创建连接工厂时由原先的单个brokerURL</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">&quot;tcp://localhost:61616&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改为多地址映射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">&quot;failover:(tcp://localhost:61616,tcp://localhost:61617,tcp://localhost:61618)?randomize=true&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="高性能方案——NetworkConnector【负载均衡】"><a href="#高性能方案——NetworkConnector【负载均衡】" class="headerlink" title="高性能方案——NetworkConnector【负载均衡】"></a>高性能方案——NetworkConnector【负载均衡】</h4><p>修改61616的activemq.xml，添加NetworkConnector,必须加在persistenceAdapter这个元素之前</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">networkConnectors</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">networkConnector</span> <span class="attr">name</span>=<span class="string">&quot;local_network&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;static:(tcp://127.0.0.1:61617,tcp://127.0.0.1:61618)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">networkConnectors</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里61617(b)为master，61618(c)为slave，工作队列为61616(a)和b，如果b宕机会由c顶替，但是之前b的消息会丢失，所以通常情况，我们会使用<u>高可用</u>和<u>高性能</u>结合的方案：给a,b,c队列服务器分别建立主从</p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>Kafka官网的下载地址：<a target="_blank" rel="noopener" href="https://kafka.apache.org/downloads">https://kafka.apache.org/downloads</a></p>
<h3 id="什么是Kafka"><a href="#什么是Kafka" class="headerlink" title="什么是Kafka"></a>什么是Kafka</h3><p>Kafka是一种高吞吐量的分布式<strong>发布订阅</strong>消息系统，它可以处理消费者规模的网站中的所有动作流数据。这种动作（页面浏览、搜索和其他用户的动作）是在现代网络上的许多社会功能的一个关键因素。这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。对于像Hadoop一样 的日志数据和离线分析系统，但又要求实时处理的，这是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群机来提供实时的消费。</p>
<p>它有以下特性：<br>消息持久化：通过O（1）的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。（文件追加的方式写入数据，过期的数据定期删除）</p>
<p>高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息</p>
<p>分布式：Kafka Broker的中心化集群支持消息分区，而consumer采用分布式进行消费</p>
<p>实时： 消息由producer产生后立即对consumer可见。这个特性对于基于事件的系统是很关键的</p>
<p>支持Hadoop并行数据加载</p>
<h3 id="Kafka的使用场景"><a href="#Kafka的使用场景" class="headerlink" title="Kafka的使用场景"></a>Kafka的使用场景</h3><ol>
<li><p>Messging</p>
<p>对于一些常规的消息系统，kafka是一个不错的选择；partitons/replication和容错，可以使kafka具有良好的扩展性和性能优势。不过到目前为止，我们应该很清楚认识到，kafka并没有提供JMS中的“事务性”“消息传输担保”“消息分组”等企业级特性。</p>
</li>
<li><p>Website activity tracking</p>
<p>kafka可以作为“网站活性跟踪”的最佳工具；可以将网页/用户操作等信息发送到kafka中。并实时监控或者离线统计分析等</p>
</li>
<li><p>Log Aggregation</p>
<p>kafka的特性决定它非常适合作为“日志收集中心”；application可以将操作日志“批量”“异步”的发送到kafka集群中，而不是保存在本地或者DB中；kafka可以批量提交消息/压缩消息等；这对producer端而言，几乎感觉不到性能的开支。此时consumer端可以使hadoop等其他系统化的存储和分析系统。</p>
</li>
</ol>
<h3 id="Kafka中的术语解释"><a href="#Kafka中的术语解释" class="headerlink" title="Kafka中的术语解释"></a>Kafka中的术语解释</h3><p><img src="C:\Users\Administrator\AppData\Local\Temp\1553835916799.png" alt="1553835916799"></p>
<p>上图中，1个topic配置了3个partition（分区）。partition1有两个offset(偏移量)：0和1。partition2有四个offset。Partition3有1个offset。副本的id和副本所在的机器id恰巧相同。</p>
<p>如果一个topic的副本数为3，那么kafka将在集群中为每个partition创建3个相同的副本。集群中的每个broker存储一个或多个partition。多个producer和consumer可同时生产和消费数据。</p>
<p><strong>broker</strong></p>
<p>Kafka服务器节点称为broker。</p>
<p>broker存储topic数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个patition。</p>
<p>如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。</p>
<p>如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition.在实际生产环境中，尽量避免这种情况发生，这种情况容易导致Kafka集群数据不均衡。</p>
<p><strong>topic</strong></p>
<p>顾名思义topics是一些主题的集合，更通俗的说topic就像一个消息队列，生产者可以向其写入消息，消费者可以从中读取消息，一个topic支持多个生产者或消费者同时订阅它，所以其扩展性很好。topic由一个或多个partition组成：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553911572200.png" alt="1553911572200"></p>
<p>其中每个partition中的消息是有序的，但相互之间的顺序就不能保证了，若Topic有多个partition,生产者的消息可以指定或者由系统根据算法分配到指定分区，若你需要所有的消息都是有序的，那么最好只用一个分区。另外partition支持消息位移读取，消息位移由消费者自身管理，比如下图：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553846233867.png" alt="1553846233867"></p>
<p>由上图可以看出，不同消费者对同一分区的消息读取互不干扰，消费者可以通过设置消息位移(offset)来控制自己想要获取的数据，比如可以从头读取，最新数据读取，重读读取等功能</p>
<p><strong>patition</strong></p>
<p>topic中的数据分割为一个或多个patition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。patition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition,消费数据时就不能保证数据的顺序。在需要严格保证消费顺序的场景下，需要将partition数据设为1</p>
<p><strong>Producer</strong></p>
<p>生产者即数据发布者，该角色将消息发布到Kafka的topic中。broker接受到生产者发送的消息后，broker将该消息<strong>追加</strong>到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个patition中，生产者也可以指定数据存储的partition。</p>
<p><strong>Consumer</strong></p>
<p>消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。</p>
<p><strong>Consumer Group/Consumers</strong></p>
<p>每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）</p>
<p>Consumers是一群消费者的集合，可以称之为消费者组，是一种更高层次的抽象，向Topic订阅消费消息的单位是Consumers,当然它其中也可以只有一个消费者(consumer)。下面是关于consumer的两条原则：</p>
<ul>
<li>假如所有消费者都在同一个消费者组中，那么它们将协同消费订阅Topic的部分消息（根据分区和消费者的数量分配），保证负载均衡</li>
<li>加入所有的消费者都在不同的消费者组当中，并且订阅了同个Topic，那么它们将可以消费Topic的所有消息</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553862424112.png" alt="1553862424112"></p>
<p>Topic的消息根据一定规则将消息推送给具体消费者，主要原则如下：</p>
<ul>
<li>若消费者数小于partition数，且消费者数为一个，那么它就消费所有消息</li>
<li>若消费者数小于partition数，假设消费者为N，partition数为M，那么每个消费者能消费的分区数为M/N或M/N+1</li>
<li>若消费者数等于partition数，那么每个消费者都会均等分配到一个分区消息</li>
<li>若消费者数大于partition数，则将会出现部分消费者得不到消息分区，出现空闲的情况</li>
</ul>
<p>总的来说，Kafka会根据消费者组的情况均衡分配消息，比如有消息的实例宕机，亦或者有新的消费者加入等情况，为了达到最好的效果，消费者的数量最好等于分区的数量，来保证高吞吐量</p>
<p><strong>Leader</strong></p>
<p>每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition</p>
<p><strong>Follower</strong></p>
<p>Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从”in sync replicas”(ISR)列表中删除，重新创建一个Follower。</p>
<h3 id="Kafka集群的搭建"><a href="#Kafka集群的搭建" class="headerlink" title="Kafka集群的搭建"></a>Kafka集群的搭建</h3><ol>
<li><p>环境搭建</p>
<p>安装kafka集群之前，确保zookeeper服务已经正常运行</p>
<p>wget <a target="_blank" rel="noopener" href="http://mirror.bit.edu.cn/apache/kafka/2.1.1/kafka_2.11-2.1.1.tgz">http://mirror.bit.edu.cn/apache/kafka/2.1.1/kafka_2.11-2.1.1.tgz</a>    拉取压缩包安装</p>
<p>tar -xf kafka_2.11-2.1.1.tgz        解压文件</p>
<p>mv kafka-2.1.1-src /usr/local/kafka        移动到/usr/local/kafka目录下面</p>
</li>
<li><p>编辑配置</p>
<p>cd /usr/local/kafka/config</p>
<p>vim server.properties</p>
<p>修改配置文件的以下属性</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 强调这个ID在集群中必须是唯一否则会出现ID冲突问题</span></span><br><span class="line"><span class="meta">broker.id</span>=<span class="string">0 </span></span><br><span class="line"><span class="comment">## 配置kafka的服务监听端口</span></span><br><span class="line"><span class="comment">## 如果配置0.0.0.0则绑定全部网卡，如果默认像下面这样，kafka会绑定默认的所有网卡ip，一般在机器中hosts，hostname都要正确配置，这里默认即可；然后下面的port默认9092不用配置，如果自定义端口号需要设置和listeners的一致，这个是kafka服务监听的端口号. </span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://192.168.146.220:9092</span></span><br><span class="line"><span class="comment">## 配置日志目录，建议在kafka的根目录创建一个日志目录</span></span><br><span class="line"><span class="meta">log.dirs</span>=<span class="string">/usr/local/kafka/logs</span></span><br><span class="line"><span class="comment">## 配置分区个数,1个是顺序消费</span></span><br><span class="line"><span class="meta">num.partitions</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">## 配置Zookeeper集群字符串</span></span><br><span class="line"><span class="meta">zookeeper.connect</span>=<span class="string">192.168.146.220:2181,192.168.146.221:2181,192.168.146.222:2181</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>把刚的配置远程拷贝到其他的2台机器上面</p>
<p>scp -r /usr/local/kafka 192.168.146.221:/usr/local/</p>
<p>scp -r /usr/local/kafka 192.168.146.222:/usr/local/</p>
<p>并修改上面配置文件的broker.id和listeners</p>
</li>
<li><p>启动kafka集群</p>
<p>/usr/local/kafka/bin/kafka-server-start.sh -daemon /usr/local/kafka/config/server.properties</p>
</li>
</ol>
<h3 id="测试kafka集群"><a href="#测试kafka集群" class="headerlink" title="测试kafka集群"></a>测试kafka集群</h3><p>连接zookeeper,创建一个名为test-topic的topic</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh kafka-topics.sh --create --zookeeper 192.168.146.220:2181,192.168.146.221:2181,192.168.146.222:2181 --replication-factor 1 --partitions 1 --topic test-topic </span><br><span class="line"></span><br><span class="line">Created topic &quot;test-topic&quot;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看此topic的分区状况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">单体：</span><br><span class="line">sh kafka-topics.sh --describe --zookeeper 192.168.146.220:2181 --topic test-topic	</span><br><span class="line"></span><br><span class="line">Topic:test-topic	PartitionCount:1	ReplicationFactor:1	Configs:</span><br><span class="line">	Topic: test-topic	Partition: 0	Leader: 1	Replicas: 1	Isr: 1</span><br><span class="line">集群：	</span><br><span class="line">sh kafka-topics.sh --describe --zookeeper 192.168.3.220:2181,192.168.3.221:2181,192.168.3.222:2181 --topic test-topic</span><br><span class="line"></span><br><span class="line">Topic:test-topic	PartitionCount:3	ReplicationFactor:3	Configs:</span><br><span class="line">    Topic: test-topic       Partition: 0    Leader: 2       Replicas: 2,1,3 Isr: 2,1</span><br><span class="line">    Topic: test-topic       Partition: 1    Leader: 3       Replicas: 3,2,1 Isr: 3,2,1</span><br><span class="line">    Topic: test-topic       Partition: 2    Leader: 1       Replicas: 1,3,2 Isr: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>PartitionCount</strong>(分区数量)</p>
<p><strong>ReplicationFactor</strong>(副本数量)所有Partition的Replica默认情况会均匀分布到所有Broker上。</p>
<p><strong>Topic</strong>(主题名) </p>
<p>Partition(分区编号) 每个Partition有一个leader与多个follower，producer往某个Partition中写入数据是，只会往leader中写入数据，然后数据才会被复制进其他的Replica中。<br>数据是由leader push过去还是有flower pull过来？ </p>
<p>kafka是由follower周期性或者尝试去pull(拉)过来(其实这个过程与consumer消费过程非常相似)，写是都往leader上写，但是读并不是任意flower上读都行，读也只在leader上读，flower只是数据的一个备份，保证leader被挂掉后顶上来，并不往外提供服务。</p>
<p><strong>Leader</strong>(领导)</p>
<p><strong>Replicas</strong>(副本)</p>
<p><strong>ISR</strong>(基本同步副本表)由Leader进行维护，如果一个follow比一个leader落后太多，或者超过一定时间未发起数据复制请求，则leader将其从Isr移除，当ISR中所有Repalica都向leader发送ACK时，leader才commit</p>
<p>查看已经创建的topic列表</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh kafka-topics.sh --list --zookeeper 192.168.146.220:2181</span><br><span class="line">test-topic</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建消息生产者发送消息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh kafka-console-producer.sh --broker-list 192.168.146.220:9092 --topic test-topic</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>创建消息消费者接收消息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh kafka-console-consumer.sh --bootstrap-server 192.168.146.220:9092 --topic test-topic --from-beginning</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>★错误记录:-bash: ./kafka-server-start.sh: Permission denied</p>
<p>在执行启动启动kafka集群的时候，报错没有权限操作该文件，直接通过 chmod 777 zookeeper-server-start.sh命令给无权限的文件更改权限。</p>
<p>[2019-02-28 22:00:23,657] WARN [Producer clientId=console-producer] Connection to node 1 (/192.168.3.220:9092) could not be established. Broker may not be available. (org.apache.kafka.clients.NetworkClient)</p>
<p>这个是因为防火墙没有放行端口</p>
<p>firewall-cmd –add-port=9092/tcp –permanent</p>
<p>★错误记录:zk连接超时</p>
<p>修改192.168.146.220为127.0.0.1</p>
<p>★错误记录:客户端监听不到服务端消息</p>
<p>数据数据重读导致，清空zookeeper节点数据</p>
<h3 id="使用JAVA发送和接受Kafka消息"><a href="#使用JAVA发送和接受Kafka消息" class="headerlink" title="使用JAVA发送和接受Kafka消息"></a>使用JAVA发送和接受Kafka消息</h3><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编写生产者代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">		<span class="comment">//kafka服务器地址</span></span><br><span class="line">		props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.146.220:9092&quot;</span>);</span><br><span class="line">		<span class="comment">//ack判断是否成功发送。all将会阻塞消息，这种设置性能最低，但是最可靠。</span></span><br><span class="line">		props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">		<span class="comment">//retries,如果请求失败，生产者会自动重试，我们指定是0次，如果启用重试，则会有重复消息的可能性。</span></span><br><span class="line">		props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//producer缓存每个分区未发送消息，缓存的大小是通过batch.size()配置设定的。值较大的话将会产生更大的批。并需要更多的内存(因为每个“活跃”的分区都有一个缓冲区)</span></span><br><span class="line">		props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line">		<span class="comment">//默认缓冲区可立即发送，即便缓冲区空间没有满；但是，如果你想减少请求的数量，可以设置linger.ms大于0.这将指示生产者发送请求之前等待一段时间</span></span><br><span class="line">		<span class="comment">//希望更多的消息补填到未满的批中。这类似于tcp的算法，例如上面的代码段，可能100条消息在一个请求发送，因为我们设置了linger时间为1ms，然后，如果我们</span></span><br><span class="line">		<span class="comment">//没有填满缓冲区，这个设置将增加1ms的延迟请求以等待更多的消息。需要注意的是，在高负载下，相近的时间一般也会组成批，即使是linger.ms=0。</span></span><br><span class="line">		<span class="comment">//不处于高负载的情况下，如果设置比0大，以少量的延迟代价换取更少的，更有效的请求。</span></span><br><span class="line">		props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//buffer.memory控制生产者可用的缓存总量，如果消息发送速度比其传输到服务器的快，将会耗尽这个缓存空间。当缓存空间耗尽，其他发送调用将被阻塞，阻塞时间的阈值</span></span><br><span class="line">		<span class="comment">//通过max.block.ms设定，之后他将抛出一个TimeoutExecption。</span></span><br><span class="line">		props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">		<span class="comment">//key.serializer和value.serializer示例：将用户提供的key和value对象ProducerRecord转换成字节，你可以使用附带的ByteArraySerizlizaer或StringSerializer处理简单的byte和String类型.</span></span><br><span class="line">		props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">		props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">		<span class="comment">//设置kafka的分区数量</span></span><br><span class="line">		props.put(<span class="string">&quot;kafka.partitions&quot;</span>, <span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">		Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;key--&gt;key&quot;</span>+i+<span class="string">&quot;  value--&gt;vvv&quot;</span>+i);</span><br><span class="line">			producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;key&quot;</span>+i, <span class="string">&quot;vvv&quot;</span>+i));</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		producer.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用于建立消费者的相关参数说明及其默认值参见producerconfigs，此处对代码中用到的几个参数进行解释： </p>
<p>bootstrap.servers:用于初始化时建立链接到kafka集群，以host:port形式，多个以逗号分隔host1:port1,host2:port2； </p>
<p>acks:生产者需要server端在接收到消息后，进行反馈确认的尺度，主要用于消息的可靠性传输；acks=0表示生产者不需要来自server的确认；acks=1表示server端将消息保存后即可发送ack，而不必等到其他follower角色的都收到了该消息；acks=all(or acks=-1)意味着server端将等待所有的副本都被接收后才发送确认。 </p>
<p>retries:生产者发送失败后，重试的次数 </p>
<p>batch.size:当多条消息发送到同一个partition时，该值控制生产者批量发送消息的大小，批量发送可以减少生产者到服务端的请求数，有助于提高客户端和服务端的性能。 </p>
<p>linger.ms:默认情况下缓冲区的消息会被立即发送到服务端，即使缓冲区的空间并没有被用完。可以将该值设置为大于0的值，这样发送者将等待一段时间后，再向服务端发送请求，以实现每次请求可以尽可能多的发送批量消息。 </p>
<p>batch.size和linger.ms是两种实现让客户端每次请求尽可能多的发送消息的机制，它们可以并存使用，并不冲突。 </p>
<p>buffer.memory:生产者缓冲区的大小，保存的是还未来得及发送到server端的消息，如果生产者的发送速度大于消息被提交到server端的速度，该缓冲区将被耗尽。 </p>
<p>key.serializer,value.serializer说明了使用何种序列化方式将用户提供的key和vaule值序列化成字节。</p>
<p>编写消费端代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line">s</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> KafkaConsumer&lt;String, String&gt;  <span class="title">getConsmer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">		<span class="comment">//设置kafka服务器</span></span><br><span class="line">		props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.146.220:9092&quot;</span>);</span><br><span class="line">		<span class="comment">//消费者群组ID，发布-订阅模式，即如果一个生产者，多个消费者都要消费，那么需要定义自己的群组，同一个群组内的消费者只有一个能消费到消息</span></span><br><span class="line">		props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">		<span class="comment">//true，消费者的偏移量将在后台定期提交；false关闭自动提交位移，在消息被完整处理之后再手动提交位移</span></span><br><span class="line">		props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">		<span class="comment">//如何设置为自动提交（enable.auto.commit=true）,这里设置自动提交周期</span></span><br><span class="line">		props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">		<span class="comment">//session.timeout.ms:在使用kafka的组管理时，用于检测消费者故障的超时</span></span><br><span class="line">		props.put(<span class="string">&quot;auto.offset.reset&quot;</span>,<span class="string">&quot;earliest&quot;</span>);</span><br><span class="line">		<span class="comment">//earliest表示无提交的offset时从头消费，否则从offset开始消费；latest表示从新产生的该分区下的数据开始消费，否则从offset开始消费；none只从已提交的offset开始消费，否则抛出异常</span></span><br><span class="line">		props.put(<span class="string">&quot;session.timeout.ms&quot;</span>, <span class="string">&quot;30000&quot;</span>);</span><br><span class="line">		<span class="comment">//key.serializer和value.serializer示例：将用户提供的key和value对象ProducerRecord转换成字节，你可以使用附带的ByteArraySerizlizaer或StringSerializer处理简单的byte和String类型.</span></span><br><span class="line">		props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">		props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">		KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">		<span class="keyword">return</span> consumer;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		KConsumer kconsumer =  <span class="keyword">new</span> KConsumer();</span><br><span class="line">		KafkaConsumer&lt;String, String&gt; consumer = kconsumer.getConsmer();</span><br><span class="line">		<span class="comment">//消费某一个分区的数据：</span></span><br><span class="line">		<span class="comment">//TopicPartition p2 = new TopicPartition(&quot;test-topic&quot;,0);</span></span><br><span class="line">		<span class="comment">//consumer.subscribe(Arrays.asList(p2));</span></span><br><span class="line">		consumer.subscribe(Arrays.asList(<span class="string">&quot;test-topic&quot;</span>));</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);<span class="comment">//拉取消息的间隔</span></span><br><span class="line">			<span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">				System.out.println(<span class="string">&quot;offset =  &quot;</span>+record.offset()+<span class="string">&quot;, key = &quot;</span>+record.key()+<span class="string">&quot;, value = &quot;</span>+ record.value());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// 通过多种方式操作Kafka的消息读取（）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011784767/article/details/78663168">https://blog.csdn.net/u011784767/article/details/78663168</a></p>
<h3 id="Kafka的高性能分布式存储模型"><a href="#Kafka的高性能分布式存储模型" class="headerlink" title="Kafka的高性能分布式存储模型"></a>Kafka的高性能分布式存储模型</h3><h4 id="高性能的日志存储"><a href="#高性能的日志存储" class="headerlink" title="高性能的日志存储"></a>高性能的日志存储</h4><p>kafka一个topic下面的所有消息都是以partition的方式分布式的存储在多个节点上。同时在kafka的机器上，每个Partition其实都会对应一个日志目录，在目录下面会对应多个日志分段(LogSegment)。LogSegment文件由两部分组成，分别为“.index”文件和“.log”文件，分别表示为segment索引文件和数据文件。这两个文件的命令规则为：partition全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值，数值大小为<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=64%E4%BD%8D&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">64位</a>，20位数字字符长度，没有数字用0填充，如下，假设有1000条消息，每个LogSegment大小为100，下面展现了900-1000的索引和Log：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553953835310.png" alt="1553953835310"></p>
<p>由于kafka消息数据太大，如果全部建立索引，即占了空间又增加了耗时，所以kafka选择了<strong>稀疏索引</strong>的方式，这样的话索引可以直接进入内存，加快偏查询速度。</p>
<p>　　简单介绍一下如何读取数据，如果我们要读取第911条数据首先第一步，找到他是属于哪一段的，根据二分法查找到他属于的文件，找到0000900.index和00000900.log之后，然后去index中去查找 (911-900) =11这个索引或者小于11最近的索引,在这里通过二分法我们找到了索引是[10,1367]然后我们通过这条索引的物理位置1367，开始往后找，直到找到911条数据。</p>
<p>　　上面讲的是如果要找某个offset的流程，但是我们大多数时候并不需要查找某个offset,只需要按照顺序读即可，而在顺序读中，操作系统会对内存和磁盘之间添加page cahe，也就是我们平常见到的预读操作，所以我们的顺序读操作时速度很快。但是kafka有个问题，如果分区过多，那么日志分段也会很多，写的时候由于是批量写，其实就会变成随机写了，随机I/O这个时候对性能影响很大。所以一般来说<strong>Kafka不能有太多的partition</strong>。针对这一点，RocketMQ把所有的日志都写在一个文件里面，就能变成顺序写，通过一定优化，读也能接近于顺序读。</p>
<h4 id="日志策略"><a href="#日志策略" class="headerlink" title="日志策略"></a>日志策略</h4><h5 id="日志保留策略"><a href="#日志保留策略" class="headerlink" title="日志保留策略"></a>日志保留策略</h5><p>无论消费者是否已经消费了消息，kafka都会一直保存这些消息，但并不会像数据库那样长期保存。为了避免磁盘被占满，kafka会配置响应的保留策略（retention policy），以实现周期性地删除陈旧的消息<br>kafka有两种“保留策略”：</p>
<ol>
<li>根据消息保留的时间，当消息在kafka中保存的时间超过了指定时间，就可以被删除；</li>
<li>根据topic存储的数据大小，当topic所占的日志文件大小大于一个阀值，则可以开始删除最旧的消息</li>
</ol>
<h5 id="日志压缩策略"><a href="#日志压缩策略" class="headerlink" title="日志压缩策略"></a>日志压缩策略</h5><p>在很多场景中，消息的key与value的值之间的对应关系是不断变化的，就像数据库中的数据会不断被修改一样，消费者只关心key对应的最新的value。我们可以开启日志压缩功能，kafka定期将相同key的消息进行合并，只保留最新的value值 </p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553956783900.png" alt="1553956783900"></p>
<h4 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h4><p>Kafka的副本机制是多个服务端节点对其他节点的主题分区的日志进行复制。当集群中的某个节点出现故障，访问故障节点的请求会被转移到其他正常节点(这一过程通常叫Reblance),kafka每个主题的每个分区都有一个主副本以及0个或者多个副本，副本保持和主副本的数据同步，当主副本出故障时就会被替代。</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553957959977.png" alt="1553957959977"></p>
<p>在Kafka中并不是所有的副本都能被拿来替代主副本，所以在kafka的leader节点中维护着一个<strong>ISR</strong>(In sync Replicas)集合，翻译过来也叫<strong>正在同步中集合</strong>，在这个集合中的需要满足两个条件:</p>
<ul>
<li>节点必须和ZK保持连接</li>
<li>在同步的过程中这个副本不能落后主副本太多</li>
</ul>
<p>　　另外还有个<strong>AR</strong>(Assigned Replicas)用来标识副本的全集**,OSR**用来表示由于落后被剔除的副本集合，所以公式如下:ISR = leader + 没有落后太多的副本; AR = OSR+ ISR;</p>
<p>　　这里先要说下两个名词:HW(high watermark)是consumer能够看到的此partition的位置，LEO( log end offset)是每个partition的log最后一条Message的位置。HW能保证leader所在的broker失效，该消息仍然可以从新选举的leader中获取，不会造成消息丢失。</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553995279589.png" alt="1553995279589"></p>
<h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><p>为避免broker挂掉后造成数据丢失，kafka使用了高可用方式。</p>
<ul>
<li>基于partition实现replica。并与zookeeper配合实现Leader选举</li>
<li>通过算法，将partition的Leader与Followers分散在不同broker</li>
</ul>
<h4 id="replica实现"><a href="#replica实现" class="headerlink" title="replica实现"></a>replica实现</h4><p>在”brokers的物理结构”中，relication有多个followers，分散于不同的brokers。通过增量日志实现。</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553995778445.png" alt="1553995778445"></p>
<p>partition的日志记录是顺序的，通过server.properties中log.retention.hours参数定义日志保留时长，过期则删除。新写入的message append记录在partition中。</p>
<p>为提升效率，</p>
<ul>
<li>followers会在message未写入log时，读到message就把ACK发送到Leader，因此不能保证数据一定持久化了</li>
<li>批量复制</li>
</ul>
<h4 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h4><p>判断Replica活着，(1)与zk有心跳通讯(2)与leader通讯及时。两者有一点不满足，follower都会从ISR中移除。</p>
<p><strong>选举算法</strong></p>
<p>一般的leader选举算法，有Majority Vote/Zab/Raft/PacificA。Kafka采用的是PacificA，Kafka维护多个ISR,但不像Majority Vote算法，限制至少2N+1节点和N+1以上投票。</p>
<p>即使只有1个follower，也可完成Leader选举。</p>
<p><strong>选举过程（详解）</strong></p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553996635996.png" alt="1553996635996"></p>
<p>正常选举：先在zk上注册节点的当选为Leader</p>
<h3 id="Kafka高吞吐量的因素"><a href="#Kafka高吞吐量的因素" class="headerlink" title="Kafka高吞吐量的因素"></a>Kafka高吞吐量的因素</h3><ol>
<li><p>顺序写的方式存储数据，采用稀疏索引方式获取日志信息</p>
</li>
<li><p>批量发送：在异步发送模式中。Kafka允许进行批量发送，也就是先将消息缓存到内存中，然后一次请求批量发送出去。这样减少了磁盘频繁IO以及网络IO造成的性能瓶颈</p>
<p>batch.size缓冲区的大小，也就是每次发送的数据的大小</p>
<p>lenger.ms间隔时间</p>
</li>
<li><p>零拷贝：消息从发送到落地保存，broker维护的消息日志本身就是文件目录，每个文件都是二进制保存，生产者和消费者使用相同的格式来处理。在消费者获取消息时，服务器先从硬盘读取数据到内存，然后把内存中的数据原封不懂的通过socket发送给消费者。虽然这个操作描述起来很简单，但实际上经历了很多步骤</p>
</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553997969062.png" alt="1553997969062"></p>
<p>1、操作系统将数据从磁盘读入到内核空间的页缓存<br>2、应用程序将数据从内核空间读入到用户空间缓存中<br>3、应用程序将数据写回到内核空间到socket缓存中<br>4、操作系统将数据从socket缓冲区复制到网卡缓冲区，以便将数据经网络发出</p>
<p>而零拷贝的过程简单的多：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1553998094639.png" alt="1553998094639"></p>
<p>通过“零拷贝”技术可以去掉这些没必要的数据复制操作，同时也会减少上下文切换次数</p>
<h3 id="Kafka消息可靠性"><a href="#Kafka消息可靠性" class="headerlink" title="Kafka消息可靠性"></a>Kafka消息可靠性</h3><p>Kafka.Producer消息发送有两种方式(配置producer.type):</p>
<ul>
<li>同步方式(sync)：后台线程中消息发送是同步的。</li>
<li>异步方式(async)：后台线程中发送消息是异步的，优点是可以批量发送消息(消息个数达到batch.num.messages或者时间达到linger.ms时)、吞吐量佳，缺点是发送不及时可能导致丢失；</li>
</ul>
<h4 id="三种消息确认机制"><a href="#三种消息确认机制" class="headerlink" title="三种消息确认机制"></a>三种消息确认机制</h4><p>​    当producer向leader<strong>同步</strong>方式发送数据时，可以通过request.required.acks参数来设置数据可靠性的级别：</p>
<p>　　1（默认）：这意味着producer在ISR中的leader已成功收到的数据并得到确认后发送下一条message。如果leader宕机了，则会丢失数据。</p>
<p>　　0：这意味着producer无需等待来自broker的确认而继续发送下一批消息。这种情况下数据传输效率最高，但是数据可靠性确是最低的。</p>
<p>　　-1：producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。但是这样也不能保证数据不丢失，比如当ISR中只有leader时(其他节点都和zk断开连接，或者都没追上)，这样就变成了acks=1的情况。</p>
<h4 id="三种消息传递语义"><a href="#三种消息传递语义" class="headerlink" title="三种消息传递语义"></a>三种消息传递语义</h4><ul>
<li>最多一次(自动提交)：客户端收到消息后，在处理消息前自动提交，这样kafka就认为consumer已经消费过了，偏移量增加 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mostOnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test-1&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);<span class="comment">//设为自动提交，不确保消息能被消费</span></span><br><span class="line">    props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">    consumer.subscribe(Arrays.asList(<span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;bar&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            process(record);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>最少一次(手动提交)：客户端收到消息，处理消息，再提交反馈。这样就可能出现消息处理完了，在提交反馈前，网络中断或者程序挂了，那么kafka认为这个消息还没有被consumer消费，产生重复消息推送 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leastOnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test-1&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>); <span class="comment">//取消自动提交</span></span><br><span class="line">        props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;bar&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">                process(record);</span><br><span class="line">                consumer.commitAsync(); <span class="comment">//异步提交offset</span></span><br><span class="line">            	<span class="comment">//consumer.commitSync(); //同步提交offset</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>正好一次：这是人们真正想要的，每条消息只传递一次。以事务保证</li>
</ul>
<h4 id="Kafka消息的问题"><a href="#Kafka消息的问题" class="headerlink" title="Kafka消息的问题"></a>Kafka消息的问题</h4><p>Kafka就比较适合高吞吐量并且允许少量数据丢失的场景，如果非要保证“消息只读取一次”，可以使用JMS。 </p>
<ul>
<li><p>消息重复</p>
<p>根本原因：已经消费了数据，但是 offset 没提交。<br>外在原因：(1)消费数据后、提交 offset 前，线程被杀；<br>(2)设置 offset 为自动提交，consumer.close() 之前 consumer.unsubscribe()；<br>(3)consumer 取了一批数据，尚未处理完毕时，达到了 session.timeout.ms，导致没有接收心跳而挂掉，自动提交offset失败，下次会重复消费本批消息；<br>解决办法：(1)唯一 ID 保存在外部介质中，每次消费时根据它判断是否已处理；<br>(2)如果在统计用，丢失几条关系不大，则无需理会；<br>(3)如果消费者来不及处理，可以这样优化：增加分区以提高并行能力；增加消费者线程；关闭自动提交 enable.auto.commit=false</p>
</li>
<li><p>消息丢失</p>
<p>根本原因：已经提交了 offset，但数据在内存中尚未处理，线程就被杀掉。 </p>
<p>消息丢失解决方案:</p>
<p>同步模式下，确认机制设置为-1(不可为1)，即让消息写入Leader和Follower之后再确认消息发送成功；<br>异步模式下，设置为不限制阻塞超时时间(不可为acks=0)，当缓冲区满时不清空缓冲池，而是让生产者一直处于阻塞状态</p>
</li>
<li><p>消息乱序</p>
<p>传统的队列，在并行处理时，由于网络故障或速度差异，尽管服务器传递是有序的，但消费者接收的顺序可能不一致；<br>Kafka 在主题内部有分区，并行处理时，每个分区仅由消费者组中的一个消费者使用，确保了消费者是该分区的唯一读者，并按顺序使用这些数据。 </p>
<p>但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序，除非只提供<strong>一个</strong>分区。</p>
</li>
</ul>
<h3 id="Kafka分区分配策略"><a href="#Kafka分区分配策略" class="headerlink" title="Kafka分区分配策略"></a>Kafka分区分配策略</h3><p>partition.assignmentStrategy指定分区策略</p>
<ul>
<li>Range 范围分区(默认的)</li>
</ul>
<p>假如有10个分区，3个消费者（属于同一消费组，通过group.id.config配置），把分区按照序号排列0，1，2，3，4，5，6，7，8，9；消费者为C1,C2,C3，那么用分区数除以消费者数来决定每个Consumer消费几个Partition，除不尽的前面几个消费者将会多消费一个<br>最后分配结果如下</p>
<p>C1：0，1，2，3<br>C2：4，5，6<br>C3：7，8，9</p>
<p>如果有11个分区将会是：</p>
<p>C1：0，1，2，3<br>C2：4，5，6，7<br>C3：8，9，10</p>
<p>假如我们有两个主题T1,T2，分别有10个分区，最后的分配结果将会是这样：</p>
<p>C1：T1（0，1，2，3） T2（0，1，2，3）<br>C2：T1（4，5，6） T2（4，5，6）<br>C3：T1（7，8，9） T2（7，8，9）</p>
<p>在这种情况下，C1多消费了两个分区</p>
<ul>
<li>RoundRobin 轮询分区</li>
</ul>
<p>把所有的partition和consumer列出来，然后轮询consumer和partition，尽可能的把partition均匀的分配给consumer</p>
<p>假如有3个Topic T0（三个分区P0-0，P0-1,P0-2），T1(两个分区P1-0,P1-1)，T2(四个分区P2-0，P2-1，P2-2，P2-3)</p>
<p>有三个消费者：C0(订阅了T0，T1),C1（订阅了T1，T2），C2(订阅了T0,T2)！</p>
<p>分区将会按照一定的顺序排列起来，消费者将会组成一个环状的结构，然后开始轮询。<br>P0-0分配给C0<br>P0-1分配给C1但是C1并没订阅T0，于是跳过C1把P0-1分配给C2,<br>P0-2分配给C0<br>P1-0分配给C1,<br>P1-1分配给C0,<br>P2-0分配给C1，<br>P2-1分配给C2,<br>P2-2分配给C1,<br>p2-3分配给C2</p>
<p>C0: P0-0，P0-2，P1-1<br>C1：P1-0，P2-0，P2-2<br>C2：P0-1，P2-1，P2-3</p>
<p>什么时候触发分区分配策略：<br>1.同一个Consumer Group内新增或减少Consumer </p>
<p>2.Topic分区发生变化</p>
<ul>
<li>Rebalance的执行</li>
</ul>
<p>kafka提供了一个角色Coordinator来执行。当Consumer Group的第一个Consumer启动的时候，他会向kafka集群中的任意一台broker发送GroupCoordinatorRequest请求，broker会返回一个负载最小的broker设置为coordinator，之后该group的所有成员都会和coordinator进行协调通信</p>
<p>整个Rebalance分为两个过程 jionGroup和sysncJion</p>
<ul>
<li>joinGroup过程</li>
</ul>
<p>在这一步中，所有的成员都会向coordinator发送JionGroup请求，请求内容包括group_id,member_id.protocol_metadata等，coordinator会从中选出一个consumer作为leader，并且把组成员信息和订阅消息，leader信息，rebanlance的版本信息发送给consumer</p>
<ul>
<li>Synchronizing Group State阶段</li>
</ul>
<p>组成员向coordinator发送SysnGroupRequet请求，但是只有leader会发送分区分配的方案（分区分配的方案其实是在消费者确定的），当coordinator收到leader发送的分区分配方案后，会通过SysnGroupResponse把方案同步到各个consumer中</p>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="什么是RabbitMQ"><a href="#什么是RabbitMQ" class="headerlink" title="什么是RabbitMQ"></a>什么是RabbitMQ</h3><p><strong>RabbitMQ是采用 Erlang语言实现AMQP协议的消息中间件，AMQP全称是 Advanced Message Queue Protocolo，高级消息队列协议</strong>。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，<strong>并不受产品、开发语言等条件的限制</strong>。</p>
<h3 id="RabbitMQ的消息模型"><a href="#RabbitMQ的消息模型" class="headerlink" title="RabbitMQ的消息模型"></a>RabbitMQ的消息模型</h3><p>RabbitMQ是一种典型的点对点模型，但是RabbitMQ可以通过设置交换器类型来实现发布订阅模型。</p>
<h4 id="RabbitMQ的点对点模型"><a href="#RabbitMQ的点对点模型" class="headerlink" title="RabbitMQ的点对点模型"></a>RabbitMQ的点对点模型</h4><p><img src="https://img-blog.csdn.net/20150817113531436" alt="image"></p>
<p>RabbitMQ的一个核心的原则是，消息不能直接投递到Queue中。Producer只能将自己的消息投递到Exchange中，由Exchange按照路由规则将消息投递到对应的Queue中。</p>
<p>在Consumer中，声明自己对哪个Exchange感兴趣，并将自己的Queue绑定到自己感兴趣的路由关键字上，建立相应的映射关系；第二，在Producer中，将消息投递到一个Exchange中，并指明它的路由关键字。</p>
<p>生产者将消息发送到exchange交换器，exchange交换器根据消息的路由关键字，将消息发送到不同的队列里面。消费者从自己的队列中拉取消息，由于队列不存储已经被消费的消息，此模型中每一条消息（不是队列）只有一个唯一的消费者</p>
<h4 id="RabbitMQ的发布订阅模型"><a href="#RabbitMQ的发布订阅模型" class="headerlink" title="RabbitMQ的发布订阅模型"></a>RabbitMQ的发布订阅模型</h4><p><img src="https://img-blog.csdn.net/20150817113626248" alt="image"></p>
<p>RabbitMQ通过exchange可以支持多订阅，当RabbitMQ需要支持多订阅时，生产者发送的消息通过路由同时写到多个Queue，不同消费者都可以消费此消息。</p>
<ul>
<li>Consumer声明自己对多个Exchange感兴趣，并将自己的Queue绑定到自己感兴趣的Exchange上，建立相应的映射关系。</li>
<li>图中queue1和queue2同时都与exchange1、exchange2建立映射关系。当生产者将消息发送到exchange1，exchange1会把同一份消息分别发送到queue1和queue2。同理exchange2也会把同一份消息分别发送给queue1和queue2。从而实现了同一份消息可以被多个消费者消费，消费者分别从自己的队列中拉取消息进行消费。</li>
<li>由于queue中的消息消费完后立即删除，不保留历史消息。所以在多订阅时，消息会以拷贝的形式存在不同的队列中。</li>
</ul>
<p>RabbitMQ消息模型的特点：</p>
<ul>
<li>通过Exchange交换器与消息拷贝实现多订阅</li>
<li>RabbitMQ既支持内存队列也支持持久化队列</li>
<li>消费端为推模型，消费状态和订阅关系由服务端进行维护</li>
</ul>
<h3 id="AMQP模型简介"><a href="#AMQP模型简介" class="headerlink" title="AMQP模型简介"></a>AMQP模型简介</h3><p>RabbitMQ是AMQP协议的一个开源实现，其内部模型实际上也是AMQP的内部模型，如下图所示：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1554089086467.png" alt="1554089086467"></p>
<p>AMQP模型的工作流程如下：消息(Message) 被发布者 (publisher) 发送给交换机(exchange)，交换机常常被比喻成邮局或者邮箱，然后交换机将收到的消息根据路由规则分发给绑定的队列(queue)，最后AMQP代理会将消息投递给订阅此队列的消费者，或者消费者按照需求从队列中拉取消息。</p>
<p>由于网络的不可靠，接收消息的应用也有可能在处理消息的时候失败，基于此原因，AMQP模型中有一个消息确认的概念：当一个消息从队列中投递给消费者后，消息者会通知一下消息代理(Broker),这个可以是自动的也可以是手动的。当”消息确认”被启用的时候，消息代理不会完全将消息从队列中删除，直到它收到来自消费者的确认回执（ACK)。</p>
<p>在AMQP中，为什么不直接将消息传到队列中，而是先通过 Exchange转发呢？</p>
<blockquote>
<p>AMQP协议中的核心思想就是生产者和消息者隔离，生产者从不直接将消息发送给队列。生产者通常不知道是否一个消息会被发送到队列中，只是将消息发送到一个交换机。先由 Exchange 来接收，然后 Exchange 按照特定的路由规则转发到 Queue 进行存储。</p>
</blockquote>
<h4 id="Exchange和Exchange类型"><a href="#Exchange和Exchange类型" class="headerlink" title="Exchange和Exchange类型"></a>Exchange和Exchange类型</h4><p>交换机，生产者将消息发送到交换机，交换机根据路由规则将消息路由一个或多个队列中。而路由规则受Exchange的类型和绑定(binding)关系的影响。有以下四种交换机的类型：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th>默认预定义的名字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*Direct Exchange</td>
<td>空字符串和amq.direct</td>
</tr>
<tr>
<td align="left">*Topic Exchange</td>
<td>amq.fanout</td>
</tr>
<tr>
<td align="left">Fanout Exchange</td>
<td>amq.fanout</td>
</tr>
<tr>
<td align="left">Headers Exchange</td>
<td>amq.match(在rabbitmq中额外提供amq.headers)</td>
</tr>
</tbody></table>
<p>每个交换机都有如下属性：</p>
<ul>
<li><strong>Name</strong>:Exchange的名字</li>
<li><strong>Durability</strong>:是否是持久的Exchange，当为真时，broker重启后也会保留此Exchange；反之，broker重启后交换机不存在</li>
<li><strong>Auto-delete</strong>:当为真时，如果所有绑定的Queue都不再使用时，此Exchange会自动删除</li>
<li><strong>Arguments</strong>:可选属性，由插件和消息代理的特定功能使用</li>
</ul>
<h5 id="关于默认的Direct-Exchange"><a href="#关于默认的Direct-Exchange" class="headerlink" title="关于默认的Direct Exchange"></a>关于默认的Direct Exchange</h5><p>默认的 exchange 是一个由 broker 预创建的 匿名的 (即名字为空字符串) direct Exchange，对于简单的程序来说，默认的 exchange 有一个实用的属性： 如果没有显示的绑定 Exchange ,那么创建的每个 queue 都会自动绑定到这个默认的 exchange中，并且此时这个 queue的route key 就是这个 queue的名字。</p>
<p>下面举个例子来说明：</p>
<p><strong>发送端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqProducer0</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">&quot;192.168.146.220&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RabbitMQ服务端默认端口号为5672</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//连接rabbitMQ服务器的工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置ip</span></span><br><span class="line">        factory.setHost(IP_ADDRESS);</span><br><span class="line">        <span class="comment">//设置端口</span></span><br><span class="line">        factory.setPort(PORT);</span><br><span class="line">        <span class="comment">//设置账号</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//设置密码</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//channel.exchangeDeclare(&quot;direct&quot;,&quot;direct&quot;);//默认方式，可以不写</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//2.是否可持久化3.是否排他队列（只有一个客户能消费）4.是否空闲时自动删除</span></span><br><span class="line">        <span class="comment">//channel.queueBind(QUEUE_NAME,&quot;direct&quot;,&quot;hello&quot;);//设置路由键，direct方式默认为队列名</span></span><br><span class="line">        String message = <span class="string">&quot;hello world &quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, MessageProperties.MINIMAL_BASIC, message.getBytes()<span class="comment">//使用默认交换机，路由键为队列名称</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>接收端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqConsumer0</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">&quot;192.168.146.220&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Address[] addresses = <span class="keyword">new</span> Address[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Address(IP_ADDRESS, PORT)</span><br><span class="line">        &#125;;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        Connection connection = factory.newConnection(addresses);</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;recv message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//手动确认，deliveryTag可以看做是消息的编号，它是一个位的长整型值</span></span><br><span class="line">                <span class="comment">//false表示接收消息,true表示拒收消息</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//可以指定autoAck为false,RabbitMQ会等待消费者显式地回复确认信号后才从内存中移去消息</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>, consumer);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们没有定义Exchange,也没有显示地将 queue 绑定到 exchange 中，因此 名为 “hello” 的queue 会自动绑定到默认的 exchange，即名字为空字符串的 exchange中。并且在这个默认的 exchange中，其 route key 和 queue名字一致。简言之，消息就以 route key为 “hello” 投递到默认的 exchange中，并被路由到 “hello” 这个queue中。</p>
<p>direct exchange 根据消息携带的 routing key 将消息投递到不同的 queue中，direct exchange 适用于消息的<strong>单播发送</strong>。工作流程如下：</p>
<ul>
<li>将一个队列绑定到某个交换机上，同时赋予该绑定 一个 route key。</li>
<li>当一个携带 route key为R 的消息被发送到 direct exchange 时，exchange 会将消息路由到 绑定值同样为 R 的队列。<strong>注意Route Key和绑定值要完全匹配才行</strong>。</li>
</ul>
<p>direct exchange 图示</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1554101586395.png" alt="1554101586395"></p>
<p>direct exchange 经常用于在 多个 worker 中分配任务，当这样做时，需注意，在AMQP 0-9-1中，消息的负载均衡发生在 consumer之间，而不是在 queue之间,默认的<strong>负载方式</strong>为轮询,不论服务器性能如何，服务器只完成分配给自己的工作量(除非别的服务器宕机)，这时就可以选择<u>服务质量保障功能</u>即使用<strong>工作队列</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);<span class="comment">//在非自动确认消息的前提下，如果一定数目的消息(基于consumer或channel设置的Qos值)未被确认前，不进行消费新的消息,达到性能负载</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h5><p>topic exchange 会根据 route key 将消息分发到与此消息的 route key <strong>相匹配</strong>的并且绑定此exchange的一个或多个 queue。这里的**”相匹配”**与 direct exchange的完全匹配的路由规则不一样，topic exchange 在匹配规则上进行了扩展，规则如下：</p>
<ul>
<li>RoutingKey（路由键）为一个点号 “.” 分隔的字符串，如 “com.rabbitmq.client”、”java.util.concurrent”、”com.hidden.client”等</li>
<li>BindingKey（绑定键) 和 RoutingKey一样也是点号 “.” 分隔的字符串</li>
<li>BindingKey （绑定键） 中可以存在两种 特殊字符串 “*” 和 “#” ，用于做模糊匹配，其中 “ # “ 只能匹配一个字符，” * “表示可以匹配多个字符,比如boys.*可以匹配boys.aa bb cc或boys.d,空格表示或的匹配关系,#可以匹配boys.a b c或boys.a.b</li>
</ul>
<p>topic exchange 经常用于实现 publish/subscribe模型，即消息的多播模型。前面介绍消息模型也曾提到过消息中间件一般有两种模式：点对点模式和发布/订阅模式。这里的Topic Exchange就适用于发布/订阅模型。RabbitMQ的一个原则就是，消息不能直接投递到 Queue中，必须先将消息投递到 Exchange中，然后由Exchange 按照路由规则将消息投递到对应的 Queue中。至于点对点模型就可以用 Direct Exchange来实现，利用完全匹配的路由规则。</p>
<p>topic exchange 图示：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1554105610378.png" alt="1554105610378"></p>
<h5 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h5><p>一个 fanout exchange 会将消息分发给所有绑定到此 exchange 的queue中，不管 queue中的 route key。如果有 N 个 Queue 绑定到 一个 fanout exchange 时，那么此时 exchange 收到消息时，会将此消息分发到 这 N 个 queue中，由于此性质， fanout exchange 也常用消息的广播,比如配置的自动刷新(通过push)。</p>
<p>fanout exchange图示：</p>
<p><img src="C:\Users\Administrator\AppData\Local\Temp\1554104930623.png" alt="1554104930623"></p>
<p>代码示例：</p>
<p><strong>发送端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutProducer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;fanout-queue&quot;</span>;	</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">		ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">		<span class="comment">//rabbitmq监听IP</span></span><br><span class="line">		factory.setHost(<span class="string">&quot;192.168.146.220&quot;</span>);</span><br><span class="line">		<span class="comment">//rabbitmq监听默认端口</span></span><br><span class="line">		factory.setPort(<span class="number">5672</span>);</span><br><span class="line">		factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">		factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">		Connection connection = factory.newConnection();</span><br><span class="line">		Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//声明路由名字和类型</span></span><br><span class="line">		channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">         channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">true</span>,<span class="keyword">null</span>);</span><br><span class="line">         channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">&quot;&quot;</span>);<span class="comment">//设置队列的路由键为空</span></span><br><span class="line">		String message = makeMessage(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;rabbit&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">		channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="keyword">null</span>, message.getBytes());<span class="comment">//要发送的路由键为空</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Sent msg is &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">		channel.close();</span><br><span class="line">		connection.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">makeMessage</span><span class="params">(String[] strings)</span></span>&#123;<span class="comment">//生产消息</span></span><br><span class="line">		<span class="keyword">if</span> (strings.length &lt; <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;这是默认消息！！&quot;</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			StringBuffer buffer= <span class="keyword">new</span> StringBuffer();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">				buffer.append(strings[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> buffer.toString();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>接收端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME 	= <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">		<span class="comment">//rabbitmq监听IP</span></span><br><span class="line">		factory.setHost(<span class="string">&quot;192.168.146.220&quot;</span>);</span><br><span class="line">		<span class="comment">//rabbitmq监听默认端口</span></span><br><span class="line">		factory.setPort(<span class="number">5672</span>);</span><br><span class="line">		<span class="comment">//设置访问的用户</span></span><br><span class="line">		factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">		factory.setPassword(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">		Connection connection = factory.newConnection();</span><br><span class="line">		Channel channel = connection.createChannel();</span><br><span class="line">		<span class="comment">//声明路由名字和类型</span></span><br><span class="line">		channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">		<span class="comment">//获取随机队列名称</span></span><br><span class="line">		String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">		<span class="comment">//创建队列</span></span><br><span class="line">		channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">//把队列绑定到路由上,不需要设置路由键</span></span><br><span class="line">		channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot; Waiting for msg....&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">					AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">				String message = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">				System.out.println(<span class="string">&quot;Received msg is &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="Headers-Exchange"><a href="#Headers-Exchange" class="headerlink" title="Headers Exchange"></a>Headers Exchange</h5><p>headers exchanges 不依赖于路由器的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。</p>
<p>all: 全部满足，条件成立,生产者： (aaa, bbb), (ccc,aaa)  消费者：  (aaa, bbb)&amp;&amp;(ccc,aaa)</p>
<p>any: 只要满足其中一种，条件成立,生产者： (aaa, bbb), (ccc,aaa)  消费者：  (aaa, bbb)||(ccc,aaa)</p>
<p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; headers =  <span class="keyword">new</span> Hashtable&lt;String, Object&gt;();</span><br><span class="line">		headers.put(<span class="string">&quot;aaffa&quot;</span>, <span class="string">&quot;01234&quot;</span>);</span><br><span class="line">		headers.put(<span class="string">&quot;mima&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">		Builder properties = <span class="keyword">new</span> Builder();</span><br><span class="line">		properties.headers(headers);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 为转发器指定队列，设置binding 绑定header键值对</span></span><br><span class="line">		channel.queueBind(QUEUE_NAME, EXCHANGE_NAME,<span class="string">&quot;&quot;</span>, headers);</span><br><span class="line">		<span class="comment">// 指定消息发送到的转发器,绑定键值对headers键值对</span></span><br><span class="line">		channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>,properties.build(),message.getBytes());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; headers = <span class="keyword">new</span> Hashtable&lt;String, Object&gt;();</span><br><span class="line">		headers.put(<span class="string">&quot;x-match&quot;</span>, <span class="string">&quot;all&quot;</span>);<span class="comment">//all any</span></span><br><span class="line">		headers.put(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;01234&quot;</span>);</span><br><span class="line">		headers.put(<span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;56789&quot;</span>);</span><br><span class="line">		<span class="comment">// 为转发器指定队列，设置binding 绑定header键值对</span></span><br><span class="line">		channel.queueBind(QUEUE_NAME, EXCHANGE_NAME,<span class="string">&quot;&quot;</span>, headers);</span><br><span class="line">		QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line">		<span class="comment">// 指定接收者，第二个参数为自动应答，无需手动应答</span></span><br><span class="line">		channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">			String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">			System.out.println(message);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>Queue: 队列，是RabbitMQ的内部对象，用于存储消息，RabbitMQ中的消息只能存储在队列中。它有几个重要的属性：</p>
<ul>
<li><code>Name</code>: 名字</li>
<li><code>Durable</code>: 是否是持久的，当为真时，即使消息代理 重启时，此 queue 也不会被删除</li>
<li><code>Exclusive</code>: 是否是独占的，当为真时，表示此 queue只能有一个消费者，并且当此消费者的连接断开时，此 queue 会被删除</li>
<li><code>Auto-delete</code>: 当为真时，此队列会在最后一个消费者取消订阅时被删除</li>
<li><code>Arguments</code>: 可选属性，由插件和消息代理的特定功能使用，例如消息TTL、队列长度限制等</li>
</ul>
<p>在使用一个队列时，需要先进行声明，如果我们声明的队列不存在，那么 broker 会自动创建它，但是如果队列已经存在，我们需要注意的是我们声明的队列的属性和已存在的的队列的属性是否一致，如果一致，则不会有任何问题，如果前后不一致，那就会 <code>PRECONDITION_FAILED</code>错误(错误码 406)</p>
<p><strong>队列名</strong></p>
<p>AMQP的队列名 不能为 “amq.” 开头，因为这样的队列名是 AMQP broker 内部所使用的，当我们使用了这样的队列名时，那么会有一个 <code>ACCESS_REFUSED</code> 错误 （错误码为 403）</p>
<p><strong>持久队列</strong></p>
<p>持久队列会被持久化到磁盘中去，因此即使 broker 重启了，持久队列依然存在。持久队列和消息的持久化不同，当broker 重启时，持久队列会自动重新声明，队列中的持久化消息(persistent message) 才会被恢复</p>
<p><strong>队列的绑定</strong></p>
<p>队列的绑定关系是 exchange 用于消息路由的规则，即一个 exchange 能够将消息路由到某个队列的前提是队列已经绑定到这个 exchange中了，当队列绑定到一个 exchange中时，我们设置了一个 route key，或者叫做绑定键，这个key 会被 direct exchange 和 topic exchange 作为额外的路由信息使用。</p>
<p>当exchange 没有任何的 queue 绑定时，那么此时会根据消息的属性来决定 是将此消息丢弃还是返回给生产者。</p>
<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><h5 id="消息分发模式-推拉"><a href="#消息分发模式-推拉" class="headerlink" title="消息分发模式(推拉)"></a>消息分发模式(推拉)</h5><p>AMQP 0-9-1 支持两种消息分发模式：</p>
<ul>
<li><code>push</code>模式，即broker 主动推送消息给 消费者</li>
<li><code>pull</code>模式，即消费者主动从 broker 中拉取消息</li>
</ul>
<p>在<code>push</code>模式中，消费者订阅一个消息主题，当有消息传递到消息主题时，broker主动将消息<strong>推送</strong>给订阅该主题的所有消费者。每个消费者都有一个唯一的标识符，即 consumer tag。我们也可以用这个 tag来取消一个消费者对某个主题的订阅。push模式下一般使用 Channel类的 <code>basicConsume</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">basicConsume</span><span class="params">(String queue, Consumer callback)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">basicConsume</span><span class="params">(String queue, DeliverCallback deliverCallback, CancelCallback cancelCallback)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">basicConsume</span><span class="params">(String queue, DeliverCallback deliverCallback, ConsumerShutdownSignalCallback shutdownSignalCallback)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该方法有几种重载形式，更多的信息可以参阅 API文档。</p>
<p>而<code>pull</code>模式，消费者主动从 broker 中<strong>拉取</strong>消息，通过 <code>channel.basicGet</code>方法可以单条地获取消息，其返回值是 <code>GetResponse</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GetResponse <span class="title">basicGet</span><span class="params">(String queue, <span class="keyword">boolean</span> autoAck)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中 queue 代表队列的名称，如果设置 autoAck 为 true，即消息自动ACK模式，为false,则为消息手动确认模式，同样需要调用 <code>channel.basicAck</code>来确认消息已被成功接收。下面将仔细阐述消息的ACK.</p>
<h5 id="消息的ACK"><a href="#消息的ACK" class="headerlink" title="消息的ACK"></a>消息的ACK</h5><p>AMQP 0-9-1 有两种消息 ACK 模式：</p>
<ul>
<li>自动 ACK 模式</li>
<li>手动 ACK 模式</li>
</ul>
<p><strong>在自动 ACK 模式下，当 broker 发送消息成功后，会立即将此消息 从消息队列中 删除，而不需要消费者的 ACK回复</strong>。示例程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Address[] addresses = <span class="keyword">new</span> Address[]&#123;</span><br><span class="line">        <span class="keyword">new</span> Address(IP_ADDRESS, PORT)</span><br><span class="line">&#125;;</span><br><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">factory.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">Connection connection = factory.newConnection(addresses);</span><br><span class="line"><span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;recv message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);<span class="comment">//设为自动回复</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 <code>channel.basicConsume(String queue, boolean autoAck, Consumer callback)</code>设置 autoAck参数。</p>
<p>而在手动的 ACK模式下，当 broker 发送消息给消费者时，不会立即将此消息删除，而是需要等待消息的消费者的ACK回复后才会删除消息，因此在手动 ACK模式下，当消费者收到消息并处理完成后，需要向 broker 显示地发送 ACK指令。示例程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Address[] addresses = <span class="keyword">new</span> Address[]&#123;</span><br><span class="line">        <span class="keyword">new</span> Address(IP_ADDRESS, PORT)</span><br><span class="line">&#125;;</span><br><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">factory.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">Connection connection = factory.newConnection(addresses);</span><br><span class="line"><span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;recv message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消费者显示调用Basic.Ack命令</span></span><br><span class="line">        <span class="comment">//deliveryTag可以看做是消息的编号，它是一个位的长整型值</span></span><br><span class="line">        channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这里还可以指定autoAck为false,RabbitMQ会等待消费者显式地回复确认信号后才从内存中移去消息</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME,consumer);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在手动 ACK模式下，如果消费者 因为意外的 crash 而没有发送 ACK 给 broker,那么此时 broker会将消息转发给其他的消费者 (如果此时没有消费者了，那么 broker 会缓存 此消息，直到有新的消费者注册)</p>
<p><strong>拒绝消息</strong></p>
<p>当一个 消费者处理消息失败或者此时不能处理消息时，那么可以给 broker 发送一个拒接消息的指令，并且可以要求 broker 丢弃或者重新分发此消息。不过需要的注意的是，如果此时只有一个消费者，那么此时消费者拒收消息并要求 broker 重新分发此消息时，那么就会造成此消息不断的分发和拒收，形成了死循环。拒收的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicReject</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过调用 <code>channel.basicReject</code>方法来告诉 RabbitMQ拒绝某个消息。其中 <code>deliveryTag</code> 可以看做是消息的编号，它是一个 64位的长整型值。如果 <code>requeue</code> 为 true, <strong>broker会重新将这条消息存入 队列</strong>，以便发送给下一个订阅的消费者。如果为false,则 broker<strong>会立即把消息从队列中移除，而不会把它发送给新的消费者</strong>。</p>
<p><strong>预读消息</strong></p>
<p>通过 预读消息机制，消费者可以一次性批量取出消息，然后在处理后对这些消息进行统一的 ACK,这样可以提高消息的吞吐量。不过需要注意的是，RabbitMQ 仅支持 channel级别的预读消息的数量配置，不支持基于连接的预读消息数量配置。</p>
<h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>AMQP的连接是长连接，它是一个使用 TCP作为可靠传输的应用层协议。AMQP使用认证机制并且体用 TLS(SSL) 保护。当一个应用不再需要连接到 AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。</p>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>有些应用需要与 AMQP代理(Broker)建立多个连接，无论怎样，同时开启多个 TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了 Channel 来处理多个连接，可以把Channel理解为 共享 一个TCP连接的多个轻量化连接。（PS:这里让我想到了多路复用模型，原理相似）</p>
<p>在涉及多线程/进程的应用中，为每个线程/进程开启一个通道 (channel) 是很常见的，并且这些通道不能被线程/进程共享。</p>
<h4 id="virtual-hosts"><a href="#virtual-hosts" class="headerlink" title="virtual hosts"></a>virtual hosts</h4><p>为了在一个单独的代理上实现多个隔离的环境(用户、用户组、交换机、队列等)，AMQP提供了一个 虚拟主机 (virtual hosts -vhosts)的概念。这与 虚拟机的概念相似，这为AMQP提供了完全隔离的环境。当连接被建立时，AMQP客户端指定使用哪个虚拟主机。</p>
<h4 id="message"><a href="#message" class="headerlink" title="message"></a>message</h4><p>AMQP模型中的消息 (Message)对象是带有 属性(Attributes)的。有些属性非常常见，例如：</p>
<ul>
<li><code>Content type</code>: 内容类型</li>
<li><code>Content encoding</code>: 内容编码</li>
<li><code>Routing Key</code>: 路由键</li>
<li><code>Delivery mode</code>: 投递方式(持久化 or 非持久化)</li>
<li><code>Message priority</code>: 消息优先权</li>
<li><code>Message publishing timestamp</code>: 消息发布的时间戳</li>
<li><code>Expiration period</code>: 消息的有效期</li>
<li><code>Publisher application id</code>: 发布应用的id</li>
</ul>
<p>有些属性是被 AMQP代理所使用的，比如 <code>Routing Key</code>，但是大多数是对给接收消息的消费者使用的，有些属性是可选为做消息头的。它们与HTTP协议的 <code>X-headers</code>很相似，比如 <code>Content type</code>、<code>Content encoding</code> 。</p>
<p><strong>AMQP的消息除属性外，还含有一个消息体，即消息实际携带的数据，它对AMQP代理不透明。broker 不会检查或修改消息体，但是消息可以只包含属性而不携带消息体</strong>。</p>
<h4 id="通过docker安装RabbitMQ"><a href="#通过docker安装RabbitMQ" class="headerlink" title="通过docker安装RabbitMQ"></a>通过docker安装RabbitMQ</h4><ol>
<li><p>启动docker</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>提取rabbitMQ镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3.7.7-management</span><br><span class="line"></span><br><span class="line">docker images #查看所有的镜像</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>创建和启动容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name rabbitmq3.7.7 -p 5672:5672 -p 15672:15672 -v &#x27;pwd&#x27;/data:/var/lib/rabbitmq --hostname myRabbit -e RABBITMQ_DEFAULT_VHOST=my_vhost -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin &lt;镜像id&gt;</span><br><span class="line"></span><br><span class="line">docker ps #查看运行中容器</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>-d 交互式 -v 是挂载的位置</p>
</li>
<li><p>开放Linux防火墙端口5672和15672</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-port=8080/tcp --permanent </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>查看RabbitMQ管理界面</p>
<p>在浏览器地址输入192.168.146.220:15672进入登录界面，默认用户名密码admin</p>
</li>
</ol>
<h3 id="注解方式使用RabbitMQ"><a href="#注解方式使用RabbitMQ" class="headerlink" title="注解方式使用RabbitMQ"></a>注解方式使用RabbitMQ</h3><ol>
<li><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>修改application.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.3</span><span class="number">.201</span>					<span class="comment">#rabbitmq所在主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">test</span>						<span class="comment">#用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">test</span>						<span class="comment">#密码</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span>						<span class="comment">#虚拟主机</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>					<span class="comment">#启用重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">10000ms</span>		 <span class="comment">#第一次与第二次投递尝试的时间间隔</span></span><br><span class="line">        <span class="attr">max-interval:</span> <span class="string">30000ms</span>			 <span class="comment">#两次尝试的最大时间间隔</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">2</span>					<span class="comment">#上一次尝试的时间间隔的乘数</span></span><br><span class="line">      <span class="attr">exchange:</span> <span class="string">yt.sms.queue</span>			</span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span>			<span class="comment">#发布确认机制</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>发送消息到队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;phone&quot;</span>, phone);</span><br><span class="line">map.put(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">amqpTemplate.convertAndSend(<span class="string">&quot;yt.sms.exchange&quot;</span>, <span class="string">&quot;sms.verify.code&quot;</span>, map);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>监听队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">           value = @Queue(value = &quot;yt.sms.queue&quot;,durable = &quot;true&quot;),//durable是否持久化</span></span><br><span class="line"><span class="meta">           exchange = @Exchange(value = &quot;yt.sms.exchange&quot;,ignoreDeclarationExceptions = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">           key = &#123;&quot;sms.verify.code&quot;&#125;</span></span><br><span class="line"><span class="meta">   ))</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenSms</span><span class="params">(Map&lt;String,String&gt; msg)</span></span>&#123;</span><br><span class="line">  	｝</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<h3 id="使用消息队列调用业务和Spring4-x的-Async的区别"><a href="#使用消息队列调用业务和Spring4-x的-Async的区别" class="headerlink" title="使用消息队列调用业务和Spring4.x的@Async的区别"></a>使用消息队列调用业务和Spring4.x的@Async的区别</h3></li>
</ol>
<p>@Async注解是多线程处理，用在一个应用中对操作的处理，一般不会涉及多个系统的协作</p>
<p> MQ 则使用在多个应用/服务间通讯，核心处理的就是<u>多系统</u>/<u>服务</u>的协作问题，并且提供了更加完备的消息机制， 点到点，发布订阅等。 </p>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>RocketMQ的顺序设计特性使得RocketMQ成为一个天然的排队引擎，例如，三个应用同时对一个后台引擎发起请求，排队引擎的特性可以确保不会引起“撞车”事故,所以RocketMQ适合做分布式事务的控制。</p>
<p><strong>背景</strong></p>
<blockquote>
<p>在2007年的时候，淘宝实施了“五彩石”项目，“五彩石”用于将交易系统从单机变成分布式，也是在这个过程中产生了阿里巴巴第一代消息引擎——Notify。</p>
</blockquote>
<blockquote>
<p>在2010年的时候，阿里巴巴B2B部门基于ActiveMQ的5.1版本也开发了自己的一款消息引擎，称为Napoli，这款消息引擎在B2B里面广泛地被使用，不仅仅是在交易领域，在很多的后台异步解耦等方面也得到了广泛的应用。</p>
</blockquote>
<blockquote>
<p>在2011年的时候，业界出现了现在被很多大数据领域所推崇的Kafka消息引擎，阿里巴巴在研究了Kafka的整体机制和架构设计之后，基于Kafka的设计使用Java进行了完全重写并推出了MetaQ 1.0版本，主要是用于解决顺序消息和海量堆积的问题。</p>
</blockquote>
<blockquote>
<p>在2012年，阿里巴巴对于MetaQ进行了架构重组升级，开发出了MetaQ 2.0，这时就发现MetaQ原本基于Kafka的架构在阿里巴巴如此庞大的体系下很难进行水平扩展，所以在2012年的时候就开发了RocketMQ 3.0版本。很多人会问到RocketMQ 3.0和MetaQ 3.0的区别，其实这两者是等价的版本，只不过阿里内部使用的称为MetaQ 3.0，外部开源称之为RocketMQ 3.0。</p>
</blockquote>
<blockquote>
<p>在2015年，又基于RocketMQ开发了阿里云上的Aliware MQ和Notify 3.0。</p>
</blockquote>
<blockquote>
<p>在2016年的时候，阿里巴巴将RocketMQ的内核引擎捐赠给了Apache基金会。</p>
</blockquote>
<blockquote>
<p>以上就是RocketMQ的整体发展历史，其实在阿里巴巴内部围绕着RocketMQ内核打造了三款产品，分别是MetaQ、Notify和Aliware MQ。这三者分别采用了不同的模型，MetaQ主要使用了<strong>拉模型</strong>，解决了顺序消息和海量堆积问题；Notify主要使用了<strong>推模型</strong>，解决了事务消息；而云产品Aliware MQ则是提供了商业化的版本。</p>
</blockquote>
<h3 id="RocketMQ的概念模型"><a href="#RocketMQ的概念模型" class="headerlink" title="RocketMQ的概念模型"></a>RocketMQ的概念模型</h3><p><img src="D:\Typora\resources\app\asserts\icon\QQ图片20190630095208.png" alt="QQ图片20190630095208"></p>
<p>上图就是对Topic、Producer、Consumer扩展后的概念模型。RocketMQ中可以接触到的所有概念都可以在这个概念模型图中找到。</p>
<p>左边有两个Producer，中间就是两个分布式的Topic，用于存储逻辑地址的两个Topic中分别有两个用于存储物理存储地址的Message Queue，Broker是实际部署过程的对应的一台设备，右边则是两个Consumer，Consumer Group是代表两个Consumer可共享相互之间的订阅。不同的Consumer Group相互独立。</p>
<p>一句话总结就是不同的Group是广播订阅的，同一个Group则是负载订阅的。图中的连线表示各模块之间的关系，例如Consumer Group A中的Consumer1对应着Message Queue0和Message Queue1的两个队列，分布在BrokerA这一台设备上。</p>
<p>补充：</p>
<blockquote>
<p>Producer Group：<br>用来表示一个发送消息应用，一个 Producer Group 下包含多个 Producer 实例，可以是多台机器，也可以 是一台机器的多个进程，或者一个进程的多个 Producer 对象。一个 Producer Group 可以发送多个 Topic 消息，Producer Group 作用如下：</p>
<ol>
<li>标识一类 Producer</li>
<li>发送分布式事务消息时，如果 Producer 中途意外宕机，Broker 会主动回调 Producer Group 内的任意一台机器来确认事务状态(反查)</li>
</ol>
</blockquote>
<blockquote>
<p>Consumer Group：<br>用来表示一个消费消息应用，一个 Consumer Group 下包含多个 Consumer 实例，可以是多台机器，也可<br>以是多个进程，或者是一个进程的多个 Consumer 对象。一个 Consumer Group 下的多个 Consumer 以均摊方式消费消息，如果设置为广播方式， Consumer Group 下的每个实例都消费全量数据。</p>
</blockquote>
<blockquote>
<p>Topic：消息的逻辑管理单位。</p>
</blockquote>
<blockquote>
<p>Message Queue：消息的物理管理单位。一个Topic下可以有多个Queue，类比Kafka中的分区，Queue的引入使得消息存储可以分布式集群化，具有了水平扩展的能力。</p>
</blockquote>
<blockquote>
<p>下订单（orderId=1001），支付订单（orderId=1001），订单成功（orderId=1001）。</p>
<p>顺序消息：用户实现MessageQueueSelector为某一批消息（通常是有同样的唯一的标示ID），选择同一个Queue，则这一批消息的消费将是顺序消费（并由同一个consumer完成消费）。</p>
</blockquote>
<blockquote>
<p>事务消息：这样的消息有多个状态，并且其发送是两阶段的。第一个阶段发送PREPARED状态的消息，此时consumer是看不见这种状态的消息的，发送完毕后回调用户的TransactionExecutor接口，执行相应的事务操作（如数据库），当事务操作成功时，则对此条消息返回commit，让broker对该消息执行commit操作，成为commit状态的消息对consumer是可见的。</p>
</blockquote>
<h4 id="RocketMQ的心跳机制"><a href="#RocketMQ的心跳机制" class="headerlink" title="RocketMQ的心跳机制"></a>RocketMQ的心跳机制</h4><ul>
<li>单个Broker跟所有Namesrv保持心跳请求，心跳间隔为30秒，心跳请求中包括当前Broker所有的Topic信息。Namesrv会反查Broker的心跳信息， 如果某个Broker在2分钟之内都没有心跳，则认为该Broker下线，调整Topic跟Broker的对应关系。但此时Namesrv不会主动通知Producer、Consumer有Broker宕机。</li>
<li>Consumer跟Broker是长连接，会每隔30秒发心跳信息到Broker。Broker端每10秒检查一次当前存活的Consumer，若发现某个Consumer 2分钟内没有心跳， 就断开与该Consumer的连接，并且向该消费组的其他实例发送通知，触发该消费者集群的负载均衡(rebalance)。</li>
<li>生产者每30秒从Namesrv获取Topic跟Broker的映射关系，更新到本地内存中。再跟Topic涉及的所有Broker建立长连接，每隔30秒发一次心跳。 在Broker端也会每10秒扫描一次当前注册的Producer，如果发现某个Producer超过2分钟都没有发心跳，则断开连接。</li>
</ul>
<h3 id="RocketMQ的存储摸型"><a href="#RocketMQ的存储摸型" class="headerlink" title="RocketMQ的存储摸型"></a>RocketMQ的存储摸型</h3><p>RocketMQ的消息的存储是由ConsumeQueue和CommitLog 配合来完成的，ConsumeQueue中只存储很少的数据，消息主体都是通过CommitLog来进行读写。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15356343-1386aef5785dfa6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/939/format/webp" alt="img"></p>
<h4 id="CommitLog"><a href="#CommitLog" class="headerlink" title="CommitLog"></a>CommitLog</h4><p>是消息主体以及元数据的存储主体，对CommitLog建立一个ConsumeQueue，每个ConsumeQueue对应一个（概念模型中的）MessageQueue，所以只要有Commit Log在，Consume Queue即使数据丢失，仍然可以恢复出来。</p>
<h4 id="Consume-Queue"><a href="#Consume-Queue" class="headerlink" title="Consume Queue"></a>Consume Queue</h4><p>是一个消息的逻辑队列，存储了这个Queue在CommitLog中的起始offset，log大小和MessageTag的hashCode。每个Topic下的每个Queue都有一个对应的ConsumerQueue文件，例如Topic中有三个队列，每个队列中的消息索引都会有一个编号，编号从0开始，往上递增。并由此一个位点offset的概念，有了这个概念，就可以对Consumer端的消费情况进行队列定义。</p>
<p>补充：</p>
<blockquote>
<p>RocketMQ的broker端，不负责推送消息，无论消费者是否消费消息，都将消息存储起来。谁要消费消息，就向broker发请求获取消息，消费记录由consumer来维护。RocketMQ提供了两种存储方式来保留消费记录：一种是保留在consumer所在的服务器上；另一种是保存在broker服务器上。用户还可以自己实现相应的消费进度存储接口。</p>
</blockquote>
<blockquote>
<p>默认情况下，采用集群消费（CLUSTERING），会将记录保存在broker端；而采用广播消费（BROADCASTING）则会将消费记录保存在本地。</p>
</blockquote>
<blockquote>
<p>RocketMQ以Topic来管理不同应用的消息。对于生产者而言，发送消息是，需要指定消息的Topic，对于消费者而言，在启动后，需要订阅相应的Topic，然后可以消费相应的消息。Topic是逻辑上的概念，在物理实现上，一个Topic由多个Queue组成，采用多个Queue的好处是可以将Broker存储分布式化，提高系统性能。</p>
</blockquote>
<blockquote>
<p>RocketMQ中，producer将消息发送给Broker时，需要制定发送到哪一个队列中，默认情况下，producer会轮询的将消息发送到每个队列中（所有broker下的Queue合并成一个List去轮询）。</p>
</blockquote>
<blockquote>
<p>对于consumer而言，会为每个consumer分配固定的队列（如果队列总数没有发生变化），consumer从固定的队列中去拉取没有消费的消息进行处理。</p>
</blockquote>
<h3 id="RocketMQ-存储特点"><a href="#RocketMQ-存储特点" class="headerlink" title="RocketMQ 存储特点"></a>RocketMQ 存储特点</h3><blockquote>
<p>零拷贝原理：Consumer 消费消息过程，使用了零拷贝，零拷贝包含以下两种方式：</p>
</blockquote>
<blockquote>
<ol>
<li>使用 mmap + write 方式</li>
</ol>
</blockquote>
<blockquote>
<p>优点：即使频繁调用，使用小块文件传输，效率也很高</p>
</blockquote>
<blockquote>
<p>缺点：不能很好的利用 DMA 方式，会比 sendfile 多消耗CPU，内存安全性控制复杂，需要避免 JVM Crash 问题。</p>
</blockquote>
<blockquote>
<ol>
<li>使用 sendfile 方式</li>
</ol>
</blockquote>
<blockquote>
<p>优点：可以利用 DMA 方式，消耗 CPU 较少，大块文件传输效率高，无内存安全新问题。</p>
</blockquote>
<blockquote>
<p>缺点：小块文件效率低于 mmap 方式，只能是 BIO 方式传输，不能使用 NIO。</p>
</blockquote>
<blockquote>
<p>RocketMQ 选择了第一种方式，mmap+write 方式，因为有小块数据传输的需求，效果会比 sendfile 更好。</p>
</blockquote>
<h3 id="RocketMQ-数据存储结构"><a href="#RocketMQ-数据存储结构" class="headerlink" title="RocketMQ 数据存储结构"></a>RocketMQ 数据存储结构</h3><p><img src="https://upload-images.jianshu.io/upload_images/15356343-30a590133aa5ba1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/907/format/webp" alt="img"></p>
<h3 id="RocketMQ-存储目录结构"><a href="#RocketMQ-存储目录结构" class="headerlink" title="RocketMQ 存储目录结构"></a>RocketMQ 存储目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">|-- abort </span><br><span class="line">|-- checkpoint </span><br><span class="line">|-- config</span><br><span class="line">| |-- consumerOffset.json</span><br><span class="line">| |-- consumerOffset.json.bak</span><br><span class="line">| |-- delayOffset.json</span><br><span class="line">| |-- delayOffset.json.bak</span><br><span class="line">| |-- subscriptionGroup.json.bak</span><br><span class="line">| |-- topics.json</span><br><span class="line">| |-- topics.json.bak </span><br><span class="line">|-- commitlog</span><br><span class="line">| |-- 00000003384434229248</span><br><span class="line">| |-- 000000033855079710</span><br><span class="line">| |-- 0000000338658171289</span><br><span class="line">|-- consumequeue</span><br><span class="line">  |-- %DLQ%ConsumerGroupA</span><br><span class="line">  | |-- 0</span><br><span class="line">  | | |-- 00000000000006000000</span><br><span class="line">  |-- %RETRY%ConsumerGroupA</span><br><span class="line">  | |-- 0</span><br><span class="line">  | | |-- 00000000000000000000</span><br><span class="line">  |-- %RETRY%ConsumerGroupB</span><br><span class="line">  | |-- 0</span><br><span class="line">  | | |-- 00000000000000000000</span><br><span class="line">  |-- SCHEDULE_TOPIC_XXXX</span><br><span class="line">  | |-- 2</span><br><span class="line">  | | |-- 00000000000006000000</span><br><span class="line">  | |-- 3</span><br><span class="line">  | | |-- 00000000000006000000</span><br><span class="line">  |-- TopicA</span><br><span class="line">  | |-- 0</span><br><span class="line">  | | |-- 00000000002604000000</span><br><span class="line">  | | |-- 00000000002610000000</span><br><span class="line">  | | |-- 00000000002616000000</span><br><span class="line">  | |-- 1</span><br><span class="line">  | | |-- 00000000002610000000</span><br><span class="line">  | | |-- 00000000002610000000</span><br><span class="line">  |-- TopicB</span><br><span class="line">  | |-- 0</span><br><span class="line">  | | |-- 00000000000732000000</span><br><span class="line">  | |-- 1</span><br><span class="line">  | | |-- 00000000000732000000</span><br><span class="line">  | |-- 2</span><br><span class="line">  | | |-- 00000000000732000000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="RocketMQ的部署模型"><a href="#RocketMQ的部署模型" class="headerlink" title="RocketMQ的部署模型"></a>RocketMQ的部署模型</h3><p>在实际的部署过程中，Broker是实际存储消息的数据节点，Nameserver则是服务发现节点，Producer发送消息到某一个Topic，并给到某个Consumer用于消费的过程中，需要先请求Nameserver拿到这个Topic的路由信息，即Topic在哪些Broker上有，每个Broker上有哪些队列，拿到这些请求后再把消息发送到Broker中；相对的，Consumer在消费的时候，也会经历这个流程。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15356343-0ae4d35569baec4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/895/format/webp" alt="img"></p>
<p>补充：</p>
<p>NameServer：</p>
<blockquote>
<p>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步（类似ZK）。</p>
</blockquote>
<blockquote>
<p>NameServer用于存储Topic、Broker关系信息，功能简单，稳定性高。多个NameServer之间相互没有通信，单台NameServer宕机不影响其他NameServer与集群；即使整个NameServer集群宕机，已经正常工作的Producer，Consumer，Broker仍然能正常工作，但新起的Producer, Consumer，Broker就无法工作。</p>
</blockquote>
<blockquote>
<p>NameServer压力不会太大，平时主要开销是在维持心跳和提供Topic-Broker的关系数据。但有一点需要注意，Broker向NameServer发心跳时，会带上当前自己所负责的所有Topic信息，如果Topic个数太多（万级别），会导致一次心跳中，就Topic的数据就几十M，网络情况差的话，网络传输失败，心跳失败，导致NameServer误认为Broker心跳失败。</p>
</blockquote>
<h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><blockquote>
<p>Broker 部署相对复杂，Broker分为Master 与 Slave，一个Master可以对应多个 Slave，但是一个Slave只能对应一个Master。</p>
</blockquote>
<blockquote>
<p>Master 与 Slave 的对应关系通过指定相同的BrokerName，不同的 BrokerId 来定义，BrokerId为0表示Master，非 0 表示 Slave。</p>
</blockquote>
<blockquote>
<p>Master可以部署多个。每个Broker与NameServer 集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。</p>
</blockquote>
<blockquote>
<p>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从 Name Server 取 Topic 路由信息，并向提供 Topic 服务的 Master 建立长连接，且定时向 Master 发送心跳。</p>
</blockquote>
<h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><blockquote>
<p>Producer 完全无状态，可集群部署。</p>
</blockquote>
<blockquote>
<p>Producer启动时，也需要指定NameServer的地址，从NameServer集群中选一台建立长连接。如果该NameServer宕机，会自动连其他NameServer。直到有可用的NameServer为止。</p>
</blockquote>
<blockquote>
<p>Producer每30秒从NameServer获取Topic跟Broker的映射关系，更新到本地内存中。再跟Topic涉及的所有Broker建立长连接，每隔30秒发一次心跳。在Broker端也会每10秒扫描一次当前注册的Producer，如果发现某个Producer超过2分钟都没有发心跳，则断开连接。</p>
</blockquote>
<blockquote>
<p>Producer发送时，会自动轮询当前所有可发送的broker，一条消息发送成功，下次换另外一个broker发送，以达到消息平均落到所有的broker上。</p>
</blockquote>
<blockquote>
<p>假如某个Broker宕机，意味生产者最长需要30秒才能感知到。在这期间会向宕机的Broker发送消息。当一条消息发送到某个Broker失败后，会往该broker自动再重发2次，假如还是发送失败，则抛出发送失败异常。业务捕获异常，重新发送即可。客户端里会自动轮询另外一个Broker重新发送，这个对于用户是透明的。</p>
</blockquote>
<h4 id="Consumer-1"><a href="#Consumer-1" class="headerlink" title="Consumer"></a>Consumer</h4><blockquote>
<p>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向 Master、Slave发送心跳。</p>
</blockquote>
<blockquote>
<p>Consumer既可以从Master订阅消息，也可以从 Slave 订阅消息，订阅规则由 Broker 配置决定。</p>
</blockquote>
<blockquote>
<p>Consumer启动时需要指定NameServer地址，与其中一个NameServer建立长连接。消费者每隔30秒从NameServer获取所有Topic的最新队列情况，这意味着某个Broker如果宕机，客户端最多要30秒才能感知。连接建立后，从NameServer中获取当前消费Topic所涉及的Broker，直连Broker。</p>
</blockquote>
<blockquote>
<p>Consumer跟Broker是长连接，会每隔30秒发心跳信息到Broker。Broker端每10秒检查一次当前存活的Consumer，若发现某个Consumer 2分钟内没有心跳，就断开与该Consumer的连接，并且向该消费组的其他实例发送通知，触发该Consumer集群的负载均衡。</p>
</blockquote>
<blockquote>
<p>Consumer有两种模式消费：集群消费，广播消费。</p>
</blockquote>
<blockquote>
<p>广播消费：每个消费者消费Topic下的所有队列。</p>
</blockquote>
<blockquote>
<p>集群消费：一个topic可以由同一个ID下所有消费者分担消费。</p>
</blockquote>
<h3 id="RocketMQ使用方式"><a href="#RocketMQ使用方式" class="headerlink" title="RocketMQ使用方式"></a>RocketMQ使用方式</h3><p>RocketMQ的四个依赖</p>
<ul>
<li>rocketmq-spring-boot-parent （父pom文件，定义相关的依赖管理和Plugin，供其它几个模块引用）</li>
<li>rocketmq-spring-boot (定义auto-configuration实现，具体RocketMQ相关的自动配置和Bean创建代码都集中在这里)</li>
<li>rocketmq-spring-starter (将rocketmq-spring-boot和其它的依赖打包生成全量的依赖，用户引用它即可完成所有rocketmq-spring的客户端操作)</li>
<li>rocketmq-spring-samples (使用示例，展示如何使用spring-boot方式发送和消费消息)</li>
</ul>
<h4 id="1-定义Spring-Boot的Application-properties"><a href="#1-定义Spring-Boot的Application-properties" class="headerlink" title="1. 定义Spring-Boot的Application.properties"></a>1. 定义Spring-Boot的Application.properties</h4><p>​        <code>spring.rocketmq.nameServer=127.0.0.1:9876</code></p>
<p>​        你可以根据自己的name-server信息进行修改</p>
<p>　　<code>spring.rocketmq.producer.group=my-group</code></p>
<p>​        生产设组别，当发送失败时，Broker 会主动回调 Producer Group 内的任意一台机器来确认事务状态</p>
<p>​        其他的配置信息</p>
<p>​        spring.rocketmq.producer.retryTimesWhenSendAsyncFailed=0</p>
<p>　　spring.rocketmq.producer.sendMessageTimeout=300000</p>
<p>　　spring.rocketmq.producer.compressMessageBodyOverHowmuch=4096</p>
<p>　　spring.rocketmq.producer.maxMessageSize=4194304</p>
<p>　　spring.rocketmq.producer.retryAnotherBrokerWhenNotStoreOk=false</p>
<p>　　spring.rocketmq.producer.retryTimesWhenSendFailed=2</p>
<h4 id="2-声明RocketMQTemplate"><a href="#2-声明RocketMQTemplate" class="headerlink" title="2. 声明RocketMQTemplate"></a>2. 声明RocketMQTemplate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-根据发送方式的不同选择合适的方法进行消息发送"><a href="#3-根据发送方式的不同选择合适的方法进行消息发送" class="headerlink" title="3. 根据发送方式的不同选择合适的方法进行消息发送"></a>3. 根据发送方式的不同选择合适的方法进行消息发送</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以同步的方式发送消息，构造器构造对象消息给指定的topic　　</span></span><br><span class="line">sendResult = rocketMQTemplate.syncSend(springTopic, MessageBuilder.withPayload(<span class="string">&quot;Hello, World! I&#x27;m from spring message&quot;</span>).build());　　	`</span><br><span class="line">System.out.printf(<span class="string">&quot;string-topic syncSend2 sendResult=%s %n&quot;</span>, sendResult); </span><br><span class="line"><span class="comment">// 异步方式发送用户定义对象类型的消息，并实现回调接口SendCallback　　</span></span><br><span class="line">rocketMQTemplate.asyncSend(orderPaidTopic, <span class="keyword">new</span> OrderPaidEvent(<span class="string">&quot;T_001&quot;</span>, <span class="keyword">new</span> BigDecimal(<span class="string">&quot;88.00&quot;</span>)), <span class="keyword">new</span> SendCallback() &#123;　</span><br><span class="line">    <span class="comment">// 实现消息发送成功的后续处理　　</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult var1)</span> </span>&#123;　　</span><br><span class="line">        System.out.printf(<span class="string">&quot;async onSucess SendResult=%s %n&quot;</span>, var1);　　</span><br><span class="line">    &#125;　　</span><br><span class="line">    <span class="comment">// 实现消息发送失败的后续处理　　</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable var1)</span> </span>&#123;　　</span><br><span class="line">        System.out.printf(<span class="string">&quot;async onException Throwable=%s %n&quot;</span>, var1);　　</span><br><span class="line">    &#125;　　</span><br><span class="line">&#125;);　　<span class="comment">// 指定topic的同时，设置tag值，以便消费端可以根据tag值进行选择性消费　</span></span><br><span class="line">rocketMQTemplate.convertAndSend(msgExtTopic + <span class="string">&quot;:tag0&quot;</span>, <span class="string">&quot;I&#x27;m from tag0&quot;</span>);　　</span><br><span class="line"><span class="comment">// tag0 will not be consumer-selected　</span></span><br><span class="line">rocketMQTemplate.convertAndSend(msgExtTopic + <span class="string">&quot;:tag1&quot;</span>, <span class="string">&quot;I&#x27;m from tag1&quot;</span>);　　</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-消费端"><a href="#4-消费端" class="headerlink" title="4. 消费端"></a>4. 消费端</h4><p>在消息消费端，只需要根据发送消息的类型实现RocketMQListener<T>并将它声明成Spring @Service和@RocketMQMessageListener，同时在相应的onMessage()方法里对拉取到的消息做处理。在@RocketMQMessageListener注解中可以定义如下具体的消费属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;message-ext-topic&quot;, selectorExpress = &quot;tag1&quot;, consumerGroup = &quot;$&#123;spring.application.name&#125;-message-ext-consumer&quot;)</span>　　</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageExtConsumer</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">MessageExt</span>&gt;, <span class="title">RocketMQPushConsumerLifecycleListener</span> </span>&#123;　　</span><br><span class="line">    <span class="meta">@Override</span>　　</span><br><span class="line">    <span class="comment">// 实现消息的消费处理　　</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageExt message)</span> </span>&#123;　　</span><br><span class="line">        System.out.printf(<span class="string">&quot;------- MessageExtConsumer received message, msgId:%s, body:%s %n &quot;</span>, message.getMsgId(), <span class="keyword">new</span> String(message.getBody()));　　&#125;　　</span><br><span class="line">    <span class="comment">// 设置从当前时间点开始消费消息　　</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareStart</span><span class="params">(DefaultMQPushConsumer consumer)</span> </span>&#123;　</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_TIMESTAMP);     consumer.setConsumeTimestamp(UtilAll.timeMillisToHumanString3(</span><br><span class="line">            System.currentTimeMillis()</span><br><span class="line">        ));　　</span><br><span class="line">    &#125;　　</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5-发送事务消息"><a href="#5-发送事务消息" class="headerlink" title="5. 发送事务消息"></a>5. 发送事务消息</h4><p>对于事务消息与普通消息发送只在消息发布端区别，在消费端编写代码是没有区别的，所以这里只介绍消息发送端。发送事务消息需要在发送端做如下的编程处理：</p>
<h5 id="5-1-定义回查实现类"><a href="#5-1-定义回查实现类" class="headerlink" title="5.1 定义回查实现类"></a>5.1 定义回查实现类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造Spring Message请求消息　　</span></span><br><span class="line">Message msg = MessageBuilder.withPayload(<span class="string">&quot;Hello RocketMQ &quot;</span> + i).　　setHeader(RocketMQHeaders.KEYS, <span class="string">&quot;KEY_&quot;</span> + i).build();　　</span><br><span class="line"><span class="comment">// 指定在@RocketMQTransactionListener中声明的txProducerGroup, 使用这个事务发布者组来发送事务消息和回查状态　　</span></span><br><span class="line">SendResult sendResult = rocketMQTemplate.sendMessageInTransaction(TX_PGROUP_NAME, msg, <span class="keyword">null</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="RocketMQ的Stream用法"><a href="#RocketMQ的Stream用法" class="headerlink" title="RocketMQ的Stream用法"></a>RocketMQ的Stream用法</h3><p>String Cloud Stream 是一个消息收发的框架，它提供了一套标准，应用程序只需要按照它的标准进行消息的收发，而不用关注具体的实现机制。具体的实现可以基于不同的中间件进行不同的实现。官方已经提供了Kafka和RabbitMQ的实现，RocketMQ的实现由Alibaba负责</p>
<h4 id="1-引用依赖"><a href="#1-引用依赖" class="headerlink" title="1. 引用依赖"></a>1. 引用依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rocketmq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-指定需要使用的binding"><a href="#2-指定需要使用的binding" class="headerlink" title="2. 指定需要使用的binding"></a>2. 指定需要使用的binding</h4><p>通过在配置类上使用@EnableBinding指定需要使用的Binding，它指定的是一个接口，在对应的接口中会定义一些标注了@Input或@Output的方法，它们各对应一个Binding，一个接口中可以有多个Binding。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MatchSink</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收队列1</span></span><br><span class="line">    String IN_NEW_ORDER = <span class="string">&quot;in-new-order&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//接收队列2</span></span><br><span class="line">    String IN_CANCEL_ORDER = <span class="string">&quot;in-cancel-order&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送队列1</span></span><br><span class="line">    String OUT_ORDER_ALTER = <span class="string">&quot;out-order-alter&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//发送队列2</span></span><br><span class="line">    String OUT_NEW_TRADE = <span class="string">&quot;out-new-trade&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发送队列3</span></span><br><span class="line">    String OUT_PUSH_DEPTH = <span class="string">&quot;out-push-depth&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Input(MatchSink.IN_NEW_ORDER)</span></span><br><span class="line">    <span class="function">SubscribableChannel <span class="title">inNewOrder</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Input(MatchSink.IN_CANCEL_ORDER)</span></span><br><span class="line">    <span class="function">SubscribableChannel <span class="title">inCancelOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Output(MatchSink.OUT_ORDER_ALTER)</span></span><br><span class="line">    <span class="function">MessageChannel <span class="title">outOrderAlter</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Output(MatchSink.OUT_NEW_TRADE)</span></span><br><span class="line">    <span class="function">MessageChannel <span class="title">outNewTrade</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Output(MatchSink.OUT_PUSH_DEPTH)</span></span><br><span class="line">    <span class="function">MessageChannel <span class="title">pushDepth</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-发送消息"><a href="#3-发送消息" class="headerlink" title="3. 发送消息"></a>3. 发送消息</h4><p>@Output类型的Binding是用来发消息的，SpringCloud会自动提供@EnableBinding指定接口的实现，所以使用的时候可以直接注入MatchSink类型的bean，然后通过调用标注了@Output的方法拿到MessageChannel实例，通过它的send()方法进行消息发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding(MatchSink.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceProducer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MatchSink source;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessages</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        Message&lt;String&gt; message = MessageBuilder.withPayload(msg).build;</span><br><span class="line">        source.outOrderAlter().send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-消息发送路由"><a href="#4-消息发送路由" class="headerlink" title="4. 消息发送路由"></a>4. 消息发送路由</h4><p>那么发送的消息会发到哪呢，可以通过配置文件指定Binding的实际目的地，对应于RocketMQ就是一个Topic</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">rocketmq:</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">name-server:</span> <span class="number">192.168</span><span class="number">.211</span><span class="number">.224</span><span class="string">:9876</span> <span class="comment">#指定rocketMQ nameServer</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">out-order-alter:</span> </span><br><span class="line">          <span class="attr">destination:</span> <span class="string">order-alter-topic</span> <span class="comment">#实际发送的rocket topic</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment">#默认即json,可以替换</span></span><br><span class="line">        <span class="attr">out-new-trade:</span> </span><br><span class="line">          <span class="attr">destination:</span> <span class="string">new-trade-topic</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span></span><br><span class="line">        <span class="attr">out-push-depth:</span> </span><br><span class="line">          <span class="attr">destination:</span> <span class="string">push-depth-topic</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5-消息消费路由"><a href="#5-消息消费路由" class="headerlink" title="5. 消息消费路由"></a>5. 消息消费路由</h4><p>作为消费者的Binding也必须指定对应的目的地，还必须指定一个消费者分组group，相同group的消费者可以共同消费相同destination的消息，分担压力(同group竞争消费，不同group广播消费)</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">rocketmq:</span></span><br><span class="line">        <span class="attr">binder:</span></span><br><span class="line">          <span class="attr">name-server:</span> <span class="number">192.168</span><span class="number">.211</span><span class="number">.224</span><span class="string">:9876</span> <span class="comment">#指定rocketMQ nameServer</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">in-new-order:</span> </span><br><span class="line">          <span class="attr">destination:</span> <span class="string">new-order-topic</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">match-order</span></span><br><span class="line">          <span class="attr">consumer:</span></span><br><span class="line">            <span class="attr">max-attempts:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">in-cancel-order:</span> </span><br><span class="line">          <span class="attr">destination:</span> <span class="string">cancel-order-topic</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">match-cancel</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="6-消息消费"><a href="#6-消息消费" class="headerlink" title="6. 消息消费"></a>6. 消息消费</h4><p>接收消息也需要定义相应的Binding，也需要通过@EnableBinding指定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableBinding(MatchSink.class)</span></span><br><span class="line"><span class="meta">@StreamListener(MatchSink.IN_NEW_ORDER)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">new_order</span><span class="params">(Flux&lt;String&gt; flux)</span> </span>&#123;</span><br><span class="line">		flux.subscribe(message -&gt; &#123;</span><br><span class="line">			MatchOrder order = JSON.parseObject(message, MatchOrder.class);</span><br><span class="line">			</span><br><span class="line">			OrderProducer producer = <span class="keyword">new</span> OrderProducer(ringBuffer);</span><br><span class="line">			<span class="keyword">if</span> (order.getUid().longValue() == <span class="number">1</span>) &#123;</span><br><span class="line">				start = System.currentTimeMillis();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (order.getUid().longValue() % <span class="number">10000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				log.info(<span class="string">&quot;当前是第：&quot;</span> + order.getUid() + <span class="string">&quot;条数据，耗时：&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot;(毫秒)&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			producer.onData(order);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="7-消息消费异常"><a href="#7-消息消费异常" class="headerlink" title="7. 消息消费异常"></a>7. 消息消费异常</h4><p>如果消息处理失败，Spring Cloud会把失败的消息转到名为<destination>.<group>.errors的Channel，并可通过@ServiceActivator方法进行接收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ServiceActivator(inputChannel = &quot;new-order-topic.match-order.errors&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleConsumeUserError</span><span class="params">(ErrorMessage message)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;收到处理失败的消息&#123;&#125;&quot;</span>, message.getPayload());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>全局异常处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@StreamListener(&quot;errorChannel&quot;)</span> <span class="comment">//全局异常通道名称</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleErrors</span><span class="params">(ErrorMessage message)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;默认的消息失败处理器收到处理失败的消息: &#123;&#125;，headers：&#123;&#125;&quot;</span>, message.getOriginalMessage(), message.getHeaders());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>























      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/20/Dubbo%E3%80%81Netty%E3%80%81JMS%E3%80%81AMQP/" data-id="ckk50chc5000legmzb9v28xt2" data-title="Dubbo、Netty、JMS、AMQP" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">框架及中间件</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/01/20/Nginx%E3%80%81MyCat%E3%80%81MongoDB/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Nginx、Mycat、MongoDB
        
      </div>
    </a>
  
  
    <a href="/2021/01/20/cms%E5%8F%8A%E9%9D%99%E6%80%81%E5%8C%96/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">cms及静态化</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80/" rel="tag">java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" rel="tag">大数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">框架及中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 16.67px;">java基础</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 10px;">大数据</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 13.33px;">服务器</a> <a href="/tags/%E6%A1%86%E6%9E%B6%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 20px;">框架及中间件</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/20/Arthas/">Arthas</a>
          </li>
        
          <li>
            <a href="/2021/01/20/COLA/">COLA</a>
          </li>
        
          <li>
            <a href="/2021/01/20/HazelCast%E3%80%81Ignite/">HazelCast、Ignite</a>
          </li>
        
          <li>
            <a href="/2021/01/20/Shiro%E3%80%81Spring%20Security/">Shiro、Spring Security</a>
          </li>
        
          <li>
            <a href="/2021/01/20/cucumber/">cucumber</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>